// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/AvanconStatus.proto

#ifndef PROTOBUF_proto_2fAvanconStatus_2eproto__INCLUDED
#define PROTOBUF_proto_2fAvanconStatus_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "proto/SubsystemIds.pb.h"
// @@protoc_insertion_point(includes)

namespace analogic {
namespace ancp00 {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_proto_2fAvanconStatus_2eproto();
void protobuf_AssignDesc_proto_2fAvanconStatus_2eproto();
void protobuf_ShutdownFile_proto_2fAvanconStatus_2eproto();

class AvanconStatusMsg;
class Conveyor;
class ConveyorMotorCmd;
class ConveyorMotorCmdMsg;
class Motor;
class RfidReader;
class Sensor;

enum RfidReader_RfidState {
  RfidReader_RfidState_UNKNOWN = 0,
  RfidReader_RfidState_FAULT = 1,
  RfidReader_RfidState_GOOD = 2,
  RfidReader_RfidState_RfidReader_RfidState_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  RfidReader_RfidState_RfidReader_RfidState_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool RfidReader_RfidState_IsValid(int value);
const RfidReader_RfidState RfidReader_RfidState_RfidState_MIN = RfidReader_RfidState_UNKNOWN;
const RfidReader_RfidState RfidReader_RfidState_RfidState_MAX = RfidReader_RfidState_GOOD;
const int RfidReader_RfidState_RfidState_ARRAYSIZE = RfidReader_RfidState_RfidState_MAX + 1;

const ::google::protobuf::EnumDescriptor* RfidReader_RfidState_descriptor();
inline const ::std::string& RfidReader_RfidState_Name(RfidReader_RfidState value) {
  return ::google::protobuf::internal::NameOfEnum(
    RfidReader_RfidState_descriptor(), value);
}
inline bool RfidReader_RfidState_Parse(
    const ::std::string& name, RfidReader_RfidState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RfidReader_RfidState>(
    RfidReader_RfidState_descriptor(), name, value);
}
enum Sensor_SensorState {
  Sensor_SensorState_UNKNOWN = 0,
  Sensor_SensorState_BLOCKED = 1,
  Sensor_SensorState_UNBLOCKED = 2,
  Sensor_SensorState_Sensor_SensorState_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Sensor_SensorState_Sensor_SensorState_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Sensor_SensorState_IsValid(int value);
const Sensor_SensorState Sensor_SensorState_SensorState_MIN = Sensor_SensorState_UNKNOWN;
const Sensor_SensorState Sensor_SensorState_SensorState_MAX = Sensor_SensorState_UNBLOCKED;
const int Sensor_SensorState_SensorState_ARRAYSIZE = Sensor_SensorState_SensorState_MAX + 1;

const ::google::protobuf::EnumDescriptor* Sensor_SensorState_descriptor();
inline const ::std::string& Sensor_SensorState_Name(Sensor_SensorState value) {
  return ::google::protobuf::internal::NameOfEnum(
    Sensor_SensorState_descriptor(), value);
}
inline bool Sensor_SensorState_Parse(
    const ::std::string& name, Sensor_SensorState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Sensor_SensorState>(
    Sensor_SensorState_descriptor(), name, value);
}
enum Conveyor_ConveyorState {
  Conveyor_ConveyorState_UNKNOWN = 0,
  Conveyor_ConveyorState_STOPPED = 1,
  Conveyor_ConveyorState_RUNNING = 2,
  Conveyor_ConveyorState_Conveyor_ConveyorState_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Conveyor_ConveyorState_Conveyor_ConveyorState_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Conveyor_ConveyorState_IsValid(int value);
const Conveyor_ConveyorState Conveyor_ConveyorState_ConveyorState_MIN = Conveyor_ConveyorState_UNKNOWN;
const Conveyor_ConveyorState Conveyor_ConveyorState_ConveyorState_MAX = Conveyor_ConveyorState_RUNNING;
const int Conveyor_ConveyorState_ConveyorState_ARRAYSIZE = Conveyor_ConveyorState_ConveyorState_MAX + 1;

const ::google::protobuf::EnumDescriptor* Conveyor_ConveyorState_descriptor();
inline const ::std::string& Conveyor_ConveyorState_Name(Conveyor_ConveyorState value) {
  return ::google::protobuf::internal::NameOfEnum(
    Conveyor_ConveyorState_descriptor(), value);
}
inline bool Conveyor_ConveyorState_Parse(
    const ::std::string& name, Conveyor_ConveyorState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Conveyor_ConveyorState>(
    Conveyor_ConveyorState_descriptor(), name, value);
}
enum Conveyor_DiverterPosition {
  Conveyor_DiverterPosition_DEG_0 = 0,
  Conveyor_DiverterPosition_DEG_30 = 1,
  Conveyor_DiverterPosition_DEG_45 = 2,
  Conveyor_DiverterPosition_DEG_90 = 3,
  Conveyor_DiverterPosition_Conveyor_DiverterPosition_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Conveyor_DiverterPosition_Conveyor_DiverterPosition_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Conveyor_DiverterPosition_IsValid(int value);
const Conveyor_DiverterPosition Conveyor_DiverterPosition_DiverterPosition_MIN = Conveyor_DiverterPosition_DEG_0;
const Conveyor_DiverterPosition Conveyor_DiverterPosition_DiverterPosition_MAX = Conveyor_DiverterPosition_DEG_90;
const int Conveyor_DiverterPosition_DiverterPosition_ARRAYSIZE = Conveyor_DiverterPosition_DiverterPosition_MAX + 1;

const ::google::protobuf::EnumDescriptor* Conveyor_DiverterPosition_descriptor();
inline const ::std::string& Conveyor_DiverterPosition_Name(Conveyor_DiverterPosition value) {
  return ::google::protobuf::internal::NameOfEnum(
    Conveyor_DiverterPosition_descriptor(), value);
}
inline bool Conveyor_DiverterPosition_Parse(
    const ::std::string& name, Conveyor_DiverterPosition* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Conveyor_DiverterPosition>(
    Conveyor_DiverterPosition_descriptor(), name, value);
}
enum ConveyorMotorCmd_Command {
  ConveyorMotorCmd_Command_RUN = 0,
  ConveyorMotorCmd_Command_STOP = 1,
  ConveyorMotorCmd_Command_RESET = 2,
  ConveyorMotorCmd_Command_RUN_REVERSE = 3,
  ConveyorMotorCmd_Command_ConveyorMotorCmd_Command_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ConveyorMotorCmd_Command_ConveyorMotorCmd_Command_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ConveyorMotorCmd_Command_IsValid(int value);
const ConveyorMotorCmd_Command ConveyorMotorCmd_Command_Command_MIN = ConveyorMotorCmd_Command_RUN;
const ConveyorMotorCmd_Command ConveyorMotorCmd_Command_Command_MAX = ConveyorMotorCmd_Command_RUN_REVERSE;
const int ConveyorMotorCmd_Command_Command_ARRAYSIZE = ConveyorMotorCmd_Command_Command_MAX + 1;

const ::google::protobuf::EnumDescriptor* ConveyorMotorCmd_Command_descriptor();
inline const ::std::string& ConveyorMotorCmd_Command_Name(ConveyorMotorCmd_Command value) {
  return ::google::protobuf::internal::NameOfEnum(
    ConveyorMotorCmd_Command_descriptor(), value);
}
inline bool ConveyorMotorCmd_Command_Parse(
    const ::std::string& name, ConveyorMotorCmd_Command* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ConveyorMotorCmd_Command>(
    ConveyorMotorCmd_Command_descriptor(), name, value);
}
enum ConveyorConfig {
  LEFT_HAND = 0,
  RIGHT_HAND = 1,
  ConveyorConfig_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ConveyorConfig_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ConveyorConfig_IsValid(int value);
const ConveyorConfig ConveyorConfig_MIN = LEFT_HAND;
const ConveyorConfig ConveyorConfig_MAX = RIGHT_HAND;
const int ConveyorConfig_ARRAYSIZE = ConveyorConfig_MAX + 1;

const ::google::protobuf::EnumDescriptor* ConveyorConfig_descriptor();
inline const ::std::string& ConveyorConfig_Name(ConveyorConfig value) {
  return ::google::protobuf::internal::NameOfEnum(
    ConveyorConfig_descriptor(), value);
}
inline bool ConveyorConfig_Parse(
    const ::std::string& name, ConveyorConfig* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ConveyorConfig>(
    ConveyorConfig_descriptor(), name, value);
}
// ===================================================================

class Motor : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:analogic.ancp00.Motor) */ {
 public:
  Motor();
  virtual ~Motor();

  Motor(const Motor& from);

  inline Motor& operator=(const Motor& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Motor& default_instance();

  void Swap(Motor* other);

  // implements Message ----------------------------------------------

  inline Motor* New() const { return New(NULL); }

  Motor* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Motor& from);
  void MergeFrom(const Motor& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Motor* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string addr = 1;
  void clear_addr();
  static const int kAddrFieldNumber = 1;
  const ::std::string& addr() const;
  void set_addr(const ::std::string& value);
  void set_addr(const char* value);
  void set_addr(const char* value, size_t size);
  ::std::string* mutable_addr();
  ::std::string* release_addr();
  void set_allocated_addr(::std::string* addr);

  // optional bool present = 2;
  void clear_present();
  static const int kPresentFieldNumber = 2;
  bool present() const;
  void set_present(bool value);

  // @@protoc_insertion_point(class_scope:analogic.ancp00.Motor)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr addr_;
  bool present_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_proto_2fAvanconStatus_2eproto();
  friend void protobuf_AssignDesc_proto_2fAvanconStatus_2eproto();
  friend void protobuf_ShutdownFile_proto_2fAvanconStatus_2eproto();

  void InitAsDefaultInstance();
  static Motor* default_instance_;
};
// -------------------------------------------------------------------

class RfidReader : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:analogic.ancp00.RfidReader) */ {
 public:
  RfidReader();
  virtual ~RfidReader();

  RfidReader(const RfidReader& from);

  inline RfidReader& operator=(const RfidReader& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RfidReader& default_instance();

  void Swap(RfidReader* other);

  // implements Message ----------------------------------------------

  inline RfidReader* New() const { return New(NULL); }

  RfidReader* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RfidReader& from);
  void MergeFrom(const RfidReader& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RfidReader* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef RfidReader_RfidState RfidState;
  static const RfidState UNKNOWN =
    RfidReader_RfidState_UNKNOWN;
  static const RfidState FAULT =
    RfidReader_RfidState_FAULT;
  static const RfidState GOOD =
    RfidReader_RfidState_GOOD;
  static inline bool RfidState_IsValid(int value) {
    return RfidReader_RfidState_IsValid(value);
  }
  static const RfidState RfidState_MIN =
    RfidReader_RfidState_RfidState_MIN;
  static const RfidState RfidState_MAX =
    RfidReader_RfidState_RfidState_MAX;
  static const int RfidState_ARRAYSIZE =
    RfidReader_RfidState_RfidState_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RfidState_descriptor() {
    return RfidReader_RfidState_descriptor();
  }
  static inline const ::std::string& RfidState_Name(RfidState value) {
    return RfidReader_RfidState_Name(value);
  }
  static inline bool RfidState_Parse(const ::std::string& name,
      RfidState* value) {
    return RfidReader_RfidState_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string tag = 1;
  void clear_tag();
  static const int kTagFieldNumber = 1;
  const ::std::string& tag() const;
  void set_tag(const ::std::string& value);
  void set_tag(const char* value);
  void set_tag(const char* value, size_t size);
  ::std::string* mutable_tag();
  ::std::string* release_tag();
  void set_allocated_tag(::std::string* tag);

  // optional .analogic.ancp00.RfidReader.RfidState state = 2;
  void clear_state();
  static const int kStateFieldNumber = 2;
  ::analogic::ancp00::RfidReader_RfidState state() const;
  void set_state(::analogic::ancp00::RfidReader_RfidState value);

  // optional string ip_addr = 3;
  void clear_ip_addr();
  static const int kIpAddrFieldNumber = 3;
  const ::std::string& ip_addr() const;
  void set_ip_addr(const ::std::string& value);
  void set_ip_addr(const char* value);
  void set_ip_addr(const char* value, size_t size);
  ::std::string* mutable_ip_addr();
  ::std::string* release_ip_addr();
  void set_allocated_ip_addr(::std::string* ip_addr);

  // @@protoc_insertion_point(class_scope:analogic.ancp00.RfidReader)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr tag_;
  ::google::protobuf::internal::ArenaStringPtr ip_addr_;
  int state_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_proto_2fAvanconStatus_2eproto();
  friend void protobuf_AssignDesc_proto_2fAvanconStatus_2eproto();
  friend void protobuf_ShutdownFile_proto_2fAvanconStatus_2eproto();

  void InitAsDefaultInstance();
  static RfidReader* default_instance_;
};
// -------------------------------------------------------------------

class Sensor : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:analogic.ancp00.Sensor) */ {
 public:
  Sensor();
  virtual ~Sensor();

  Sensor(const Sensor& from);

  inline Sensor& operator=(const Sensor& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Sensor& default_instance();

  void Swap(Sensor* other);

  // implements Message ----------------------------------------------

  inline Sensor* New() const { return New(NULL); }

  Sensor* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Sensor& from);
  void MergeFrom(const Sensor& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Sensor* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Sensor_SensorState SensorState;
  static const SensorState UNKNOWN =
    Sensor_SensorState_UNKNOWN;
  static const SensorState BLOCKED =
    Sensor_SensorState_BLOCKED;
  static const SensorState UNBLOCKED =
    Sensor_SensorState_UNBLOCKED;
  static inline bool SensorState_IsValid(int value) {
    return Sensor_SensorState_IsValid(value);
  }
  static const SensorState SensorState_MIN =
    Sensor_SensorState_SensorState_MIN;
  static const SensorState SensorState_MAX =
    Sensor_SensorState_SensorState_MAX;
  static const int SensorState_ARRAYSIZE =
    Sensor_SensorState_SensorState_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SensorState_descriptor() {
    return Sensor_SensorState_descriptor();
  }
  static inline const ::std::string& SensorState_Name(SensorState value) {
    return Sensor_SensorState_Name(value);
  }
  static inline bool SensorState_Parse(const ::std::string& name,
      SensorState* value) {
    return Sensor_SensorState_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional int32 sensor_id = 2;
  void clear_sensor_id();
  static const int kSensorIdFieldNumber = 2;
  ::google::protobuf::int32 sensor_id() const;
  void set_sensor_id(::google::protobuf::int32 value);

  // optional .analogic.ancp00.Sensor.SensorState state = 3;
  void clear_state();
  static const int kStateFieldNumber = 3;
  ::analogic::ancp00::Sensor_SensorState state() const;
  void set_state(::analogic::ancp00::Sensor_SensorState value);

  // optional string address = 4;
  void clear_address();
  static const int kAddressFieldNumber = 4;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  void set_address(const char* value);
  void set_address(const char* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // optional bool present = 5;
  void clear_present();
  static const int kPresentFieldNumber = 5;
  bool present() const;
  void set_present(bool value);

  // @@protoc_insertion_point(class_scope:analogic.ancp00.Sensor)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::int32 sensor_id_;
  int state_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  bool present_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_proto_2fAvanconStatus_2eproto();
  friend void protobuf_AssignDesc_proto_2fAvanconStatus_2eproto();
  friend void protobuf_ShutdownFile_proto_2fAvanconStatus_2eproto();

  void InitAsDefaultInstance();
  static Sensor* default_instance_;
};
// -------------------------------------------------------------------

class Conveyor : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:analogic.ancp00.Conveyor) */ {
 public:
  Conveyor();
  virtual ~Conveyor();

  Conveyor(const Conveyor& from);

  inline Conveyor& operator=(const Conveyor& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Conveyor& default_instance();

  void Swap(Conveyor* other);

  // implements Message ----------------------------------------------

  inline Conveyor* New() const { return New(NULL); }

  Conveyor* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Conveyor& from);
  void MergeFrom(const Conveyor& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Conveyor* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Conveyor_ConveyorState ConveyorState;
  static const ConveyorState UNKNOWN =
    Conveyor_ConveyorState_UNKNOWN;
  static const ConveyorState STOPPED =
    Conveyor_ConveyorState_STOPPED;
  static const ConveyorState RUNNING =
    Conveyor_ConveyorState_RUNNING;
  static inline bool ConveyorState_IsValid(int value) {
    return Conveyor_ConveyorState_IsValid(value);
  }
  static const ConveyorState ConveyorState_MIN =
    Conveyor_ConveyorState_ConveyorState_MIN;
  static const ConveyorState ConveyorState_MAX =
    Conveyor_ConveyorState_ConveyorState_MAX;
  static const int ConveyorState_ARRAYSIZE =
    Conveyor_ConveyorState_ConveyorState_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ConveyorState_descriptor() {
    return Conveyor_ConveyorState_descriptor();
  }
  static inline const ::std::string& ConveyorState_Name(ConveyorState value) {
    return Conveyor_ConveyorState_Name(value);
  }
  static inline bool ConveyorState_Parse(const ::std::string& name,
      ConveyorState* value) {
    return Conveyor_ConveyorState_Parse(name, value);
  }

  typedef Conveyor_DiverterPosition DiverterPosition;
  static const DiverterPosition DEG_0 =
    Conveyor_DiverterPosition_DEG_0;
  static const DiverterPosition DEG_30 =
    Conveyor_DiverterPosition_DEG_30;
  static const DiverterPosition DEG_45 =
    Conveyor_DiverterPosition_DEG_45;
  static const DiverterPosition DEG_90 =
    Conveyor_DiverterPosition_DEG_90;
  static inline bool DiverterPosition_IsValid(int value) {
    return Conveyor_DiverterPosition_IsValid(value);
  }
  static const DiverterPosition DiverterPosition_MIN =
    Conveyor_DiverterPosition_DiverterPosition_MIN;
  static const DiverterPosition DiverterPosition_MAX =
    Conveyor_DiverterPosition_DiverterPosition_MAX;
  static const int DiverterPosition_ARRAYSIZE =
    Conveyor_DiverterPosition_DiverterPosition_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  DiverterPosition_descriptor() {
    return Conveyor_DiverterPosition_descriptor();
  }
  static inline const ::std::string& DiverterPosition_Name(DiverterPosition value) {
    return Conveyor_DiverterPosition_Name(value);
  }
  static inline bool DiverterPosition_Parse(const ::std::string& name,
      DiverterPosition* value) {
    return Conveyor_DiverterPosition_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional int32 zone_id = 1;
  void clear_zone_id();
  static const int kZoneIdFieldNumber = 1;
  ::google::protobuf::int32 zone_id() const;
  void set_zone_id(::google::protobuf::int32 value);

  // optional .analogic.ancp00.Conveyor.ConveyorState state = 2;
  void clear_state();
  static const int kStateFieldNumber = 2;
  ::analogic::ancp00::Conveyor_ConveyorState state() const;
  void set_state(::analogic::ancp00::Conveyor_ConveyorState value);

  // optional bool rtr = 3;
  void clear_rtr();
  static const int kRtrFieldNumber = 3;
  bool rtr() const;
  void set_rtr(bool value);

  // optional bool rts = 4;
  void clear_rts();
  static const int kRtsFieldNumber = 4;
  bool rts() const;
  void set_rts(bool value);

  // repeated .analogic.ancp00.Sensor sensor = 5;
  int sensor_size() const;
  void clear_sensor();
  static const int kSensorFieldNumber = 5;
  const ::analogic::ancp00::Sensor& sensor(int index) const;
  ::analogic::ancp00::Sensor* mutable_sensor(int index);
  ::analogic::ancp00::Sensor* add_sensor();
  ::google::protobuf::RepeatedPtrField< ::analogic::ancp00::Sensor >*
      mutable_sensor();
  const ::google::protobuf::RepeatedPtrField< ::analogic::ancp00::Sensor >&
      sensor() const;

  // repeated .analogic.ancp00.Motor motor = 6;
  int motor_size() const;
  void clear_motor();
  static const int kMotorFieldNumber = 6;
  const ::analogic::ancp00::Motor& motor(int index) const;
  ::analogic::ancp00::Motor* mutable_motor(int index);
  ::analogic::ancp00::Motor* add_motor();
  ::google::protobuf::RepeatedPtrField< ::analogic::ancp00::Motor >*
      mutable_motor();
  const ::google::protobuf::RepeatedPtrField< ::analogic::ancp00::Motor >&
      motor() const;

  // optional bool is_diverter = 7;
  void clear_is_diverter();
  static const int kIsDiverterFieldNumber = 7;
  bool is_diverter() const;
  void set_is_diverter(bool value);

  // optional .analogic.ancp00.Conveyor.DiverterPosition diverter_pos = 8;
  void clear_diverter_pos();
  static const int kDiverterPosFieldNumber = 8;
  ::analogic::ancp00::Conveyor_DiverterPosition diverter_pos() const;
  void set_diverter_pos(::analogic::ancp00::Conveyor_DiverterPosition value);

  // optional int32 bags_in_zone = 9;
  void clear_bags_in_zone();
  static const int kBagsInZoneFieldNumber = 9;
  ::google::protobuf::int32 bags_in_zone() const;
  void set_bags_in_zone(::google::protobuf::int32 value);

  // optional string zone_id_name = 10;
  void clear_zone_id_name();
  static const int kZoneIdNameFieldNumber = 10;
  const ::std::string& zone_id_name() const;
  void set_zone_id_name(const ::std::string& value);
  void set_zone_id_name(const char* value);
  void set_zone_id_name(const char* value, size_t size);
  ::std::string* mutable_zone_id_name();
  ::std::string* release_zone_id_name();
  void set_allocated_zone_id_name(::std::string* zone_id_name);

  // optional bool zone_jammed = 11;
  void clear_zone_jammed();
  static const int kZoneJammedFieldNumber = 11;
  bool zone_jammed() const;
  void set_zone_jammed(bool value);

  // @@protoc_insertion_point(class_scope:analogic.ancp00.Conveyor)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::int32 zone_id_;
  int state_;
  ::google::protobuf::RepeatedPtrField< ::analogic::ancp00::Sensor > sensor_;
  ::google::protobuf::RepeatedPtrField< ::analogic::ancp00::Motor > motor_;
  bool rtr_;
  bool rts_;
  bool is_diverter_;
  bool zone_jammed_;
  int diverter_pos_;
  ::google::protobuf::internal::ArenaStringPtr zone_id_name_;
  ::google::protobuf::int32 bags_in_zone_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_proto_2fAvanconStatus_2eproto();
  friend void protobuf_AssignDesc_proto_2fAvanconStatus_2eproto();
  friend void protobuf_ShutdownFile_proto_2fAvanconStatus_2eproto();

  void InitAsDefaultInstance();
  static Conveyor* default_instance_;
};
// -------------------------------------------------------------------

class AvanconStatusMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:analogic.ancp00.AvanconStatusMsg) */ {
 public:
  AvanconStatusMsg();
  virtual ~AvanconStatusMsg();

  AvanconStatusMsg(const AvanconStatusMsg& from);

  inline AvanconStatusMsg& operator=(const AvanconStatusMsg& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AvanconStatusMsg& default_instance();

  void Swap(AvanconStatusMsg* other);

  // implements Message ----------------------------------------------

  inline AvanconStatusMsg* New() const { return New(NULL); }

  AvanconStatusMsg* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AvanconStatusMsg& from);
  void MergeFrom(const AvanconStatusMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AvanconStatusMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string time_stamp = 1;
  void clear_time_stamp();
  static const int kTimeStampFieldNumber = 1;
  const ::std::string& time_stamp() const;
  void set_time_stamp(const ::std::string& value);
  void set_time_stamp(const char* value);
  void set_time_stamp(const char* value, size_t size);
  ::std::string* mutable_time_stamp();
  ::std::string* release_time_stamp();
  void set_allocated_time_stamp(::std::string* time_stamp);

  // optional int32 bhs_configuration = 2;
  void clear_bhs_configuration();
  static const int kBhsConfigurationFieldNumber = 2;
  ::google::protobuf::int32 bhs_configuration() const;
  void set_bhs_configuration(::google::protobuf::int32 value);

  // optional int32 plc_configuration = 3;
  void clear_plc_configuration();
  static const int kPlcConfigurationFieldNumber = 3;
  ::google::protobuf::int32 plc_configuration() const;
  void set_plc_configuration(::google::protobuf::int32 value);

  // optional string plc_version = 4;
  void clear_plc_version();
  static const int kPlcVersionFieldNumber = 4;
  const ::std::string& plc_version() const;
  void set_plc_version(const ::std::string& value);
  void set_plc_version(const char* value);
  void set_plc_version(const char* value, size_t size);
  ::std::string* mutable_plc_version();
  ::std::string* release_plc_version();
  void set_allocated_plc_version(::std::string* plc_version);

  // optional string bhs_version = 5;
  void clear_bhs_version();
  static const int kBhsVersionFieldNumber = 5;
  const ::std::string& bhs_version() const;
  void set_bhs_version(const ::std::string& value);
  void set_bhs_version(const char* value);
  void set_bhs_version(const char* value, size_t size);
  ::std::string* mutable_bhs_version();
  ::std::string* release_bhs_version();
  void set_allocated_bhs_version(::std::string* bhs_version);

  // optional .analogic.ancp00.ConveyorConfig conv_config = 6;
  void clear_conv_config();
  static const int kConvConfigFieldNumber = 6;
  ::analogic::ancp00::ConveyorConfig conv_config() const;
  void set_conv_config(::analogic::ancp00::ConveyorConfig value);

  // optional string scanner_state = 7;
  void clear_scanner_state();
  static const int kScannerStateFieldNumber = 7;
  const ::std::string& scanner_state() const;
  void set_scanner_state(const ::std::string& value);
  void set_scanner_state(const char* value);
  void set_scanner_state(const char* value, size_t size);
  ::std::string* mutable_scanner_state();
  ::std::string* release_scanner_state();
  void set_allocated_scanner_state(::std::string* scanner_state);

  // optional string scanner_substate = 8;
  void clear_scanner_substate();
  static const int kScannerSubstateFieldNumber = 8;
  const ::std::string& scanner_substate() const;
  void set_scanner_substate(const ::std::string& value);
  void set_scanner_substate(const char* value);
  void set_scanner_substate(const char* value, size_t size);
  ::std::string* mutable_scanner_substate();
  ::std::string* release_scanner_substate();
  void set_allocated_scanner_substate(::std::string* scanner_substate);

  // optional string bin_type = 9;
  void clear_bin_type();
  static const int kBinTypeFieldNumber = 9;
  const ::std::string& bin_type() const;
  void set_bin_type(const ::std::string& value);
  void set_bin_type(const char* value);
  void set_bin_type(const char* value, size_t size);
  ::std::string* mutable_bin_type();
  ::std::string* release_bin_type();
  void set_allocated_bin_type(::std::string* bin_type);

  // optional string last_bhs_fault = 10;
  void clear_last_bhs_fault();
  static const int kLastBhsFaultFieldNumber = 10;
  const ::std::string& last_bhs_fault() const;
  void set_last_bhs_fault(const ::std::string& value);
  void set_last_bhs_fault(const char* value);
  void set_last_bhs_fault(const char* value, size_t size);
  ::std::string* mutable_last_bhs_fault();
  ::std::string* release_last_bhs_fault();
  void set_allocated_last_bhs_fault(::std::string* last_bhs_fault);

  // optional string plc_state = 11;
  void clear_plc_state();
  static const int kPlcStateFieldNumber = 11;
  const ::std::string& plc_state() const;
  void set_plc_state(const ::std::string& value);
  void set_plc_state(const char* value);
  void set_plc_state(const char* value, size_t size);
  ::std::string* mutable_plc_state();
  ::std::string* release_plc_state();
  void set_allocated_plc_state(::std::string* plc_state);

  // optional string last_plc_fault = 12;
  void clear_last_plc_fault();
  static const int kLastPlcFaultFieldNumber = 12;
  const ::std::string& last_plc_fault() const;
  void set_last_plc_fault(const ::std::string& value);
  void set_last_plc_fault(const char* value);
  void set_last_plc_fault(const char* value, size_t size);
  ::std::string* mutable_last_plc_fault();
  ::std::string* release_last_plc_fault();
  void set_allocated_last_plc_fault(::std::string* last_plc_fault);

  // optional int32 attenuation_distance_mm = 13;
  void clear_attenuation_distance_mm();
  static const int kAttenuationDistanceMmFieldNumber = 13;
  ::google::protobuf::int32 attenuation_distance_mm() const;
  void set_attenuation_distance_mm(::google::protobuf::int32 value);

  // optional int32 attenuation_window_mm = 14;
  void clear_attenuation_window_mm();
  static const int kAttenuationWindowMmFieldNumber = 14;
  ::google::protobuf::int32 attenuation_window_mm() const;
  void set_attenuation_window_mm(::google::protobuf::int32 value);

  // optional bool in_dieback = 15;
  void clear_in_dieback();
  static const int kInDiebackFieldNumber = 15;
  bool in_dieback() const;
  void set_in_dieback(bool value);

  // optional bool forced_divert = 16;
  void clear_forced_divert();
  static const int kForcedDivertFieldNumber = 16;
  bool forced_divert() const;
  void set_forced_divert(bool value);

  // optional bool divert_warning = 17;
  void clear_divert_warning();
  static const int kDivertWarningFieldNumber = 17;
  bool divert_warning() const;
  void set_divert_warning(bool value);

  // optional .analogic.ancp00.RfidReader entrance_rfid = 18;
  bool has_entrance_rfid() const;
  void clear_entrance_rfid();
  static const int kEntranceRfidFieldNumber = 18;
  const ::analogic::ancp00::RfidReader& entrance_rfid() const;
  ::analogic::ancp00::RfidReader* mutable_entrance_rfid();
  ::analogic::ancp00::RfidReader* release_entrance_rfid();
  void set_allocated_entrance_rfid(::analogic::ancp00::RfidReader* entrance_rfid);

  // optional .analogic.ancp00.RfidReader exit_rfid = 19;
  bool has_exit_rfid() const;
  void clear_exit_rfid();
  static const int kExitRfidFieldNumber = 19;
  const ::analogic::ancp00::RfidReader& exit_rfid() const;
  ::analogic::ancp00::RfidReader* mutable_exit_rfid();
  ::analogic::ancp00::RfidReader* release_exit_rfid();
  void set_allocated_exit_rfid(::analogic::ancp00::RfidReader* exit_rfid);

  // repeated .analogic.ancp00.Conveyor conveyor = 20;
  int conveyor_size() const;
  void clear_conveyor();
  static const int kConveyorFieldNumber = 20;
  const ::analogic::ancp00::Conveyor& conveyor(int index) const;
  ::analogic::ancp00::Conveyor* mutable_conveyor(int index);
  ::analogic::ancp00::Conveyor* add_conveyor();
  ::google::protobuf::RepeatedPtrField< ::analogic::ancp00::Conveyor >*
      mutable_conveyor();
  const ::google::protobuf::RepeatedPtrField< ::analogic::ancp00::Conveyor >&
      conveyor() const;

  // optional bool bhs_warning = 21;
  void clear_bhs_warning();
  static const int kBhsWarningFieldNumber = 21;
  bool bhs_warning() const;
  void set_bhs_warning(bool value);

  // optional bool sensor_warning = 22;
  void clear_sensor_warning();
  static const int kSensorWarningFieldNumber = 22;
  bool sensor_warning() const;
  void set_sensor_warning(bool value);

  // optional bool Z5_exception = 23;
  void clear_z5_exception();
  static const int kZ5ExceptionFieldNumber = 23;
  bool z5_exception() const;
  void set_z5_exception(bool value);

  // optional bool Z4_longbag = 24;
  void clear_z4_longbag();
  static const int kZ4LongbagFieldNumber = 24;
  bool z4_longbag() const;
  void set_z4_longbag(bool value);

  // optional bool external_warning = 25;
  void clear_external_warning();
  static const int kExternalWarningFieldNumber = 25;
  bool external_warning() const;
  void set_external_warning(bool value);

  // optional int32 total_attenuation_events = 26;
  void clear_total_attenuation_events();
  static const int kTotalAttenuationEventsFieldNumber = 26;
  ::google::protobuf::int32 total_attenuation_events() const;
  void set_total_attenuation_events(::google::protobuf::int32 value);

  // optional int32 total_entrance_events = 27;
  void clear_total_entrance_events();
  static const int kTotalEntranceEventsFieldNumber = 27;
  ::google::protobuf::int32 total_entrance_events() const;
  void set_total_entrance_events(::google::protobuf::int32 value);

  // optional int32 total_exit_events = 28;
  void clear_total_exit_events();
  static const int kTotalExitEventsFieldNumber = 28;
  ::google::protobuf::int32 total_exit_events() const;
  void set_total_exit_events(::google::protobuf::int32 value);

  // optional int32 total_operator_cleared = 29;
  void clear_total_operator_cleared();
  static const int kTotalOperatorClearedFieldNumber = 29;
  ::google::protobuf::int32 total_operator_cleared() const;
  void set_total_operator_cleared(::google::protobuf::int32 value);

  // optional int32 total_operator_rejected = 30;
  void clear_total_operator_rejected();
  static const int kTotalOperatorRejectedFieldNumber = 30;
  ::google::protobuf::int32 total_operator_rejected() const;
  void set_total_operator_rejected(::google::protobuf::int32 value);

  // optional int32 total_lost_tracking = 31;
  void clear_total_lost_tracking();
  static const int kTotalLostTrackingFieldNumber = 31;
  ::google::protobuf::int32 total_lost_tracking() const;
  void set_total_lost_tracking(::google::protobuf::int32 value);

  // optional int32 total_unlinked = 32;
  void clear_total_unlinked();
  static const int kTotalUnlinkedFieldNumber = 32;
  ::google::protobuf::int32 total_unlinked() const;
  void set_total_unlinked(::google::protobuf::int32 value);

  // optional int32 total_entrance_rfid_misreads = 33;
  void clear_total_entrance_rfid_misreads();
  static const int kTotalEntranceRfidMisreadsFieldNumber = 33;
  ::google::protobuf::int32 total_entrance_rfid_misreads() const;
  void set_total_entrance_rfid_misreads(::google::protobuf::int32 value);

  // optional int32 total_exit_rfid_misreads = 34;
  void clear_total_exit_rfid_misreads();
  static const int kTotalExitRfidMisreadsFieldNumber = 34;
  ::google::protobuf::int32 total_exit_rfid_misreads() const;
  void set_total_exit_rfid_misreads(::google::protobuf::int32 value);

  // optional int32 total_oversize_bags = 35;
  void clear_total_oversize_bags();
  static const int kTotalOversizeBagsFieldNumber = 35;
  ::google::protobuf::int32 total_oversize_bags() const;
  void set_total_oversize_bags(::google::protobuf::int32 value);

  // optional int32 total_cut_bags = 36;
  void clear_total_cut_bags();
  static const int kTotalCutBagsFieldNumber = 36;
  ::google::protobuf::int32 total_cut_bags() const;
  void set_total_cut_bags(::google::protobuf::int32 value);

  // optional bool master_bag_jam = 37;
  void clear_master_bag_jam();
  static const int kMasterBagJamFieldNumber = 37;
  bool master_bag_jam() const;
  void set_master_bag_jam(bool value);

  // optional int32 bag_jam_bits = 38;
  void clear_bag_jam_bits();
  static const int kBagJamBitsFieldNumber = 38;
  ::google::protobuf::int32 bag_jam_bits() const;
  void set_bag_jam_bits(::google::protobuf::int32 value);

  // optional int32 attenuation_start_buffer_mm = 39;
  void clear_attenuation_start_buffer_mm();
  static const int kAttenuationStartBufferMmFieldNumber = 39;
  ::google::protobuf::int32 attenuation_start_buffer_mm() const;
  void set_attenuation_start_buffer_mm(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:analogic.ancp00.AvanconStatusMsg)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr time_stamp_;
  ::google::protobuf::int32 bhs_configuration_;
  ::google::protobuf::int32 plc_configuration_;
  ::google::protobuf::internal::ArenaStringPtr plc_version_;
  ::google::protobuf::internal::ArenaStringPtr bhs_version_;
  ::google::protobuf::internal::ArenaStringPtr scanner_state_;
  ::google::protobuf::internal::ArenaStringPtr scanner_substate_;
  ::google::protobuf::internal::ArenaStringPtr bin_type_;
  int conv_config_;
  ::google::protobuf::int32 attenuation_distance_mm_;
  ::google::protobuf::internal::ArenaStringPtr last_bhs_fault_;
  ::google::protobuf::internal::ArenaStringPtr plc_state_;
  ::google::protobuf::internal::ArenaStringPtr last_plc_fault_;
  ::google::protobuf::int32 attenuation_window_mm_;
  bool in_dieback_;
  bool forced_divert_;
  bool divert_warning_;
  bool bhs_warning_;
  ::analogic::ancp00::RfidReader* entrance_rfid_;
  ::analogic::ancp00::RfidReader* exit_rfid_;
  ::google::protobuf::RepeatedPtrField< ::analogic::ancp00::Conveyor > conveyor_;
  bool sensor_warning_;
  bool z5_exception_;
  bool z4_longbag_;
  bool external_warning_;
  ::google::protobuf::int32 total_attenuation_events_;
  ::google::protobuf::int32 total_entrance_events_;
  ::google::protobuf::int32 total_exit_events_;
  ::google::protobuf::int32 total_operator_cleared_;
  ::google::protobuf::int32 total_operator_rejected_;
  ::google::protobuf::int32 total_lost_tracking_;
  ::google::protobuf::int32 total_unlinked_;
  ::google::protobuf::int32 total_entrance_rfid_misreads_;
  ::google::protobuf::int32 total_exit_rfid_misreads_;
  ::google::protobuf::int32 total_oversize_bags_;
  ::google::protobuf::int32 total_cut_bags_;
  bool master_bag_jam_;
  ::google::protobuf::int32 bag_jam_bits_;
  ::google::protobuf::int32 attenuation_start_buffer_mm_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_proto_2fAvanconStatus_2eproto();
  friend void protobuf_AssignDesc_proto_2fAvanconStatus_2eproto();
  friend void protobuf_ShutdownFile_proto_2fAvanconStatus_2eproto();

  void InitAsDefaultInstance();
  static AvanconStatusMsg* default_instance_;
};
// -------------------------------------------------------------------

class ConveyorMotorCmd : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:analogic.ancp00.ConveyorMotorCmd) */ {
 public:
  ConveyorMotorCmd();
  virtual ~ConveyorMotorCmd();

  ConveyorMotorCmd(const ConveyorMotorCmd& from);

  inline ConveyorMotorCmd& operator=(const ConveyorMotorCmd& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConveyorMotorCmd& default_instance();

  void Swap(ConveyorMotorCmd* other);

  // implements Message ----------------------------------------------

  inline ConveyorMotorCmd* New() const { return New(NULL); }

  ConveyorMotorCmd* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConveyorMotorCmd& from);
  void MergeFrom(const ConveyorMotorCmd& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ConveyorMotorCmd* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ConveyorMotorCmd_Command Command;
  static const Command RUN =
    ConveyorMotorCmd_Command_RUN;
  static const Command STOP =
    ConveyorMotorCmd_Command_STOP;
  static const Command RESET =
    ConveyorMotorCmd_Command_RESET;
  static const Command RUN_REVERSE =
    ConveyorMotorCmd_Command_RUN_REVERSE;
  static inline bool Command_IsValid(int value) {
    return ConveyorMotorCmd_Command_IsValid(value);
  }
  static const Command Command_MIN =
    ConveyorMotorCmd_Command_Command_MIN;
  static const Command Command_MAX =
    ConveyorMotorCmd_Command_Command_MAX;
  static const int Command_ARRAYSIZE =
    ConveyorMotorCmd_Command_Command_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Command_descriptor() {
    return ConveyorMotorCmd_Command_descriptor();
  }
  static inline const ::std::string& Command_Name(Command value) {
    return ConveyorMotorCmd_Command_Name(value);
  }
  static inline bool Command_Parse(const ::std::string& name,
      Command* value) {
    return ConveyorMotorCmd_Command_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional int32 zone_id = 1;
  void clear_zone_id();
  static const int kZoneIdFieldNumber = 1;
  ::google::protobuf::int32 zone_id() const;
  void set_zone_id(::google::protobuf::int32 value);

  // optional bool is_diverter = 2;
  void clear_is_diverter();
  static const int kIsDiverterFieldNumber = 2;
  bool is_diverter() const;
  void set_is_diverter(bool value);

  // optional bool divert = 3;
  void clear_divert();
  static const int kDivertFieldNumber = 3;
  bool divert() const;
  void set_divert(bool value);

  // optional .analogic.ancp00.ConveyorMotorCmd.Command cmd = 4;
  void clear_cmd();
  static const int kCmdFieldNumber = 4;
  ::analogic::ancp00::ConveyorMotorCmd_Command cmd() const;
  void set_cmd(::analogic::ancp00::ConveyorMotorCmd_Command value);

  // @@protoc_insertion_point(class_scope:analogic.ancp00.ConveyorMotorCmd)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::int32 zone_id_;
  bool is_diverter_;
  bool divert_;
  int cmd_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_proto_2fAvanconStatus_2eproto();
  friend void protobuf_AssignDesc_proto_2fAvanconStatus_2eproto();
  friend void protobuf_ShutdownFile_proto_2fAvanconStatus_2eproto();

  void InitAsDefaultInstance();
  static ConveyorMotorCmd* default_instance_;
};
// -------------------------------------------------------------------

class ConveyorMotorCmdMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:analogic.ancp00.ConveyorMotorCmdMsg) */ {
 public:
  ConveyorMotorCmdMsg();
  virtual ~ConveyorMotorCmdMsg();

  ConveyorMotorCmdMsg(const ConveyorMotorCmdMsg& from);

  inline ConveyorMotorCmdMsg& operator=(const ConveyorMotorCmdMsg& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConveyorMotorCmdMsg& default_instance();

  void Swap(ConveyorMotorCmdMsg* other);

  // implements Message ----------------------------------------------

  inline ConveyorMotorCmdMsg* New() const { return New(NULL); }

  ConveyorMotorCmdMsg* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConveyorMotorCmdMsg& from);
  void MergeFrom(const ConveyorMotorCmdMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ConveyorMotorCmdMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .analogic.ancp00.ConveyorMotorCmd cmds = 1;
  int cmds_size() const;
  void clear_cmds();
  static const int kCmdsFieldNumber = 1;
  const ::analogic::ancp00::ConveyorMotorCmd& cmds(int index) const;
  ::analogic::ancp00::ConveyorMotorCmd* mutable_cmds(int index);
  ::analogic::ancp00::ConveyorMotorCmd* add_cmds();
  ::google::protobuf::RepeatedPtrField< ::analogic::ancp00::ConveyorMotorCmd >*
      mutable_cmds();
  const ::google::protobuf::RepeatedPtrField< ::analogic::ancp00::ConveyorMotorCmd >&
      cmds() const;

  // @@protoc_insertion_point(class_scope:analogic.ancp00.ConveyorMotorCmdMsg)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::analogic::ancp00::ConveyorMotorCmd > cmds_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_proto_2fAvanconStatus_2eproto();
  friend void protobuf_AssignDesc_proto_2fAvanconStatus_2eproto();
  friend void protobuf_ShutdownFile_proto_2fAvanconStatus_2eproto();

  void InitAsDefaultInstance();
  static ConveyorMotorCmdMsg* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Motor

// optional string addr = 1;
inline void Motor::clear_addr() {
  addr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Motor::addr() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.Motor.addr)
  return addr_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Motor::set_addr(const ::std::string& value) {
  
  addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:analogic.ancp00.Motor.addr)
}
inline void Motor::set_addr(const char* value) {
  
  addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:analogic.ancp00.Motor.addr)
}
inline void Motor::set_addr(const char* value, size_t size) {
  
  addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:analogic.ancp00.Motor.addr)
}
inline ::std::string* Motor::mutable_addr() {
  
  // @@protoc_insertion_point(field_mutable:analogic.ancp00.Motor.addr)
  return addr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Motor::release_addr() {
  // @@protoc_insertion_point(field_release:analogic.ancp00.Motor.addr)
  
  return addr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Motor::set_allocated_addr(::std::string* addr) {
  if (addr != NULL) {
    
  } else {
    
  }
  addr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), addr);
  // @@protoc_insertion_point(field_set_allocated:analogic.ancp00.Motor.addr)
}

// optional bool present = 2;
inline void Motor::clear_present() {
  present_ = false;
}
inline bool Motor::present() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.Motor.present)
  return present_;
}
inline void Motor::set_present(bool value) {
  
  present_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.Motor.present)
}

// -------------------------------------------------------------------

// RfidReader

// optional string tag = 1;
inline void RfidReader::clear_tag() {
  tag_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RfidReader::tag() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.RfidReader.tag)
  return tag_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RfidReader::set_tag(const ::std::string& value) {
  
  tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:analogic.ancp00.RfidReader.tag)
}
inline void RfidReader::set_tag(const char* value) {
  
  tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:analogic.ancp00.RfidReader.tag)
}
inline void RfidReader::set_tag(const char* value, size_t size) {
  
  tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:analogic.ancp00.RfidReader.tag)
}
inline ::std::string* RfidReader::mutable_tag() {
  
  // @@protoc_insertion_point(field_mutable:analogic.ancp00.RfidReader.tag)
  return tag_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RfidReader::release_tag() {
  // @@protoc_insertion_point(field_release:analogic.ancp00.RfidReader.tag)
  
  return tag_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RfidReader::set_allocated_tag(::std::string* tag) {
  if (tag != NULL) {
    
  } else {
    
  }
  tag_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tag);
  // @@protoc_insertion_point(field_set_allocated:analogic.ancp00.RfidReader.tag)
}

// optional .analogic.ancp00.RfidReader.RfidState state = 2;
inline void RfidReader::clear_state() {
  state_ = 0;
}
inline ::analogic::ancp00::RfidReader_RfidState RfidReader::state() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.RfidReader.state)
  return static_cast< ::analogic::ancp00::RfidReader_RfidState >(state_);
}
inline void RfidReader::set_state(::analogic::ancp00::RfidReader_RfidState value) {
  
  state_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.RfidReader.state)
}

// optional string ip_addr = 3;
inline void RfidReader::clear_ip_addr() {
  ip_addr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RfidReader::ip_addr() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.RfidReader.ip_addr)
  return ip_addr_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RfidReader::set_ip_addr(const ::std::string& value) {
  
  ip_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:analogic.ancp00.RfidReader.ip_addr)
}
inline void RfidReader::set_ip_addr(const char* value) {
  
  ip_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:analogic.ancp00.RfidReader.ip_addr)
}
inline void RfidReader::set_ip_addr(const char* value, size_t size) {
  
  ip_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:analogic.ancp00.RfidReader.ip_addr)
}
inline ::std::string* RfidReader::mutable_ip_addr() {
  
  // @@protoc_insertion_point(field_mutable:analogic.ancp00.RfidReader.ip_addr)
  return ip_addr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RfidReader::release_ip_addr() {
  // @@protoc_insertion_point(field_release:analogic.ancp00.RfidReader.ip_addr)
  
  return ip_addr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RfidReader::set_allocated_ip_addr(::std::string* ip_addr) {
  if (ip_addr != NULL) {
    
  } else {
    
  }
  ip_addr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip_addr);
  // @@protoc_insertion_point(field_set_allocated:analogic.ancp00.RfidReader.ip_addr)
}

// -------------------------------------------------------------------

// Sensor

// optional int32 sensor_id = 2;
inline void Sensor::clear_sensor_id() {
  sensor_id_ = 0;
}
inline ::google::protobuf::int32 Sensor::sensor_id() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.Sensor.sensor_id)
  return sensor_id_;
}
inline void Sensor::set_sensor_id(::google::protobuf::int32 value) {
  
  sensor_id_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.Sensor.sensor_id)
}

// optional .analogic.ancp00.Sensor.SensorState state = 3;
inline void Sensor::clear_state() {
  state_ = 0;
}
inline ::analogic::ancp00::Sensor_SensorState Sensor::state() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.Sensor.state)
  return static_cast< ::analogic::ancp00::Sensor_SensorState >(state_);
}
inline void Sensor::set_state(::analogic::ancp00::Sensor_SensorState value) {
  
  state_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.Sensor.state)
}

// optional string address = 4;
inline void Sensor::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Sensor::address() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.Sensor.address)
  return address_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Sensor::set_address(const ::std::string& value) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:analogic.ancp00.Sensor.address)
}
inline void Sensor::set_address(const char* value) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:analogic.ancp00.Sensor.address)
}
inline void Sensor::set_address(const char* value, size_t size) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:analogic.ancp00.Sensor.address)
}
inline ::std::string* Sensor::mutable_address() {
  
  // @@protoc_insertion_point(field_mutable:analogic.ancp00.Sensor.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Sensor::release_address() {
  // @@protoc_insertion_point(field_release:analogic.ancp00.Sensor.address)
  
  return address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Sensor::set_allocated_address(::std::string* address) {
  if (address != NULL) {
    
  } else {
    
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:analogic.ancp00.Sensor.address)
}

// optional bool present = 5;
inline void Sensor::clear_present() {
  present_ = false;
}
inline bool Sensor::present() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.Sensor.present)
  return present_;
}
inline void Sensor::set_present(bool value) {
  
  present_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.Sensor.present)
}

// -------------------------------------------------------------------

// Conveyor

// optional int32 zone_id = 1;
inline void Conveyor::clear_zone_id() {
  zone_id_ = 0;
}
inline ::google::protobuf::int32 Conveyor::zone_id() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.Conveyor.zone_id)
  return zone_id_;
}
inline void Conveyor::set_zone_id(::google::protobuf::int32 value) {
  
  zone_id_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.Conveyor.zone_id)
}

// optional .analogic.ancp00.Conveyor.ConveyorState state = 2;
inline void Conveyor::clear_state() {
  state_ = 0;
}
inline ::analogic::ancp00::Conveyor_ConveyorState Conveyor::state() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.Conveyor.state)
  return static_cast< ::analogic::ancp00::Conveyor_ConveyorState >(state_);
}
inline void Conveyor::set_state(::analogic::ancp00::Conveyor_ConveyorState value) {
  
  state_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.Conveyor.state)
}

// optional bool rtr = 3;
inline void Conveyor::clear_rtr() {
  rtr_ = false;
}
inline bool Conveyor::rtr() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.Conveyor.rtr)
  return rtr_;
}
inline void Conveyor::set_rtr(bool value) {
  
  rtr_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.Conveyor.rtr)
}

// optional bool rts = 4;
inline void Conveyor::clear_rts() {
  rts_ = false;
}
inline bool Conveyor::rts() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.Conveyor.rts)
  return rts_;
}
inline void Conveyor::set_rts(bool value) {
  
  rts_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.Conveyor.rts)
}

// repeated .analogic.ancp00.Sensor sensor = 5;
inline int Conveyor::sensor_size() const {
  return sensor_.size();
}
inline void Conveyor::clear_sensor() {
  sensor_.Clear();
}
inline const ::analogic::ancp00::Sensor& Conveyor::sensor(int index) const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.Conveyor.sensor)
  return sensor_.Get(index);
}
inline ::analogic::ancp00::Sensor* Conveyor::mutable_sensor(int index) {
  // @@protoc_insertion_point(field_mutable:analogic.ancp00.Conveyor.sensor)
  return sensor_.Mutable(index);
}
inline ::analogic::ancp00::Sensor* Conveyor::add_sensor() {
  // @@protoc_insertion_point(field_add:analogic.ancp00.Conveyor.sensor)
  return sensor_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::analogic::ancp00::Sensor >*
Conveyor::mutable_sensor() {
  // @@protoc_insertion_point(field_mutable_list:analogic.ancp00.Conveyor.sensor)
  return &sensor_;
}
inline const ::google::protobuf::RepeatedPtrField< ::analogic::ancp00::Sensor >&
Conveyor::sensor() const {
  // @@protoc_insertion_point(field_list:analogic.ancp00.Conveyor.sensor)
  return sensor_;
}

// repeated .analogic.ancp00.Motor motor = 6;
inline int Conveyor::motor_size() const {
  return motor_.size();
}
inline void Conveyor::clear_motor() {
  motor_.Clear();
}
inline const ::analogic::ancp00::Motor& Conveyor::motor(int index) const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.Conveyor.motor)
  return motor_.Get(index);
}
inline ::analogic::ancp00::Motor* Conveyor::mutable_motor(int index) {
  // @@protoc_insertion_point(field_mutable:analogic.ancp00.Conveyor.motor)
  return motor_.Mutable(index);
}
inline ::analogic::ancp00::Motor* Conveyor::add_motor() {
  // @@protoc_insertion_point(field_add:analogic.ancp00.Conveyor.motor)
  return motor_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::analogic::ancp00::Motor >*
Conveyor::mutable_motor() {
  // @@protoc_insertion_point(field_mutable_list:analogic.ancp00.Conveyor.motor)
  return &motor_;
}
inline const ::google::protobuf::RepeatedPtrField< ::analogic::ancp00::Motor >&
Conveyor::motor() const {
  // @@protoc_insertion_point(field_list:analogic.ancp00.Conveyor.motor)
  return motor_;
}

// optional bool is_diverter = 7;
inline void Conveyor::clear_is_diverter() {
  is_diverter_ = false;
}
inline bool Conveyor::is_diverter() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.Conveyor.is_diverter)
  return is_diverter_;
}
inline void Conveyor::set_is_diverter(bool value) {
  
  is_diverter_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.Conveyor.is_diverter)
}

// optional .analogic.ancp00.Conveyor.DiverterPosition diverter_pos = 8;
inline void Conveyor::clear_diverter_pos() {
  diverter_pos_ = 0;
}
inline ::analogic::ancp00::Conveyor_DiverterPosition Conveyor::diverter_pos() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.Conveyor.diverter_pos)
  return static_cast< ::analogic::ancp00::Conveyor_DiverterPosition >(diverter_pos_);
}
inline void Conveyor::set_diverter_pos(::analogic::ancp00::Conveyor_DiverterPosition value) {
  
  diverter_pos_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.Conveyor.diverter_pos)
}

// optional int32 bags_in_zone = 9;
inline void Conveyor::clear_bags_in_zone() {
  bags_in_zone_ = 0;
}
inline ::google::protobuf::int32 Conveyor::bags_in_zone() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.Conveyor.bags_in_zone)
  return bags_in_zone_;
}
inline void Conveyor::set_bags_in_zone(::google::protobuf::int32 value) {
  
  bags_in_zone_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.Conveyor.bags_in_zone)
}

// optional string zone_id_name = 10;
inline void Conveyor::clear_zone_id_name() {
  zone_id_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Conveyor::zone_id_name() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.Conveyor.zone_id_name)
  return zone_id_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Conveyor::set_zone_id_name(const ::std::string& value) {
  
  zone_id_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:analogic.ancp00.Conveyor.zone_id_name)
}
inline void Conveyor::set_zone_id_name(const char* value) {
  
  zone_id_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:analogic.ancp00.Conveyor.zone_id_name)
}
inline void Conveyor::set_zone_id_name(const char* value, size_t size) {
  
  zone_id_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:analogic.ancp00.Conveyor.zone_id_name)
}
inline ::std::string* Conveyor::mutable_zone_id_name() {
  
  // @@protoc_insertion_point(field_mutable:analogic.ancp00.Conveyor.zone_id_name)
  return zone_id_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Conveyor::release_zone_id_name() {
  // @@protoc_insertion_point(field_release:analogic.ancp00.Conveyor.zone_id_name)
  
  return zone_id_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Conveyor::set_allocated_zone_id_name(::std::string* zone_id_name) {
  if (zone_id_name != NULL) {
    
  } else {
    
  }
  zone_id_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), zone_id_name);
  // @@protoc_insertion_point(field_set_allocated:analogic.ancp00.Conveyor.zone_id_name)
}

// optional bool zone_jammed = 11;
inline void Conveyor::clear_zone_jammed() {
  zone_jammed_ = false;
}
inline bool Conveyor::zone_jammed() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.Conveyor.zone_jammed)
  return zone_jammed_;
}
inline void Conveyor::set_zone_jammed(bool value) {
  
  zone_jammed_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.Conveyor.zone_jammed)
}

// -------------------------------------------------------------------

// AvanconStatusMsg

// optional string time_stamp = 1;
inline void AvanconStatusMsg::clear_time_stamp() {
  time_stamp_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AvanconStatusMsg::time_stamp() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.AvanconStatusMsg.time_stamp)
  return time_stamp_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AvanconStatusMsg::set_time_stamp(const ::std::string& value) {
  
  time_stamp_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:analogic.ancp00.AvanconStatusMsg.time_stamp)
}
inline void AvanconStatusMsg::set_time_stamp(const char* value) {
  
  time_stamp_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:analogic.ancp00.AvanconStatusMsg.time_stamp)
}
inline void AvanconStatusMsg::set_time_stamp(const char* value, size_t size) {
  
  time_stamp_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:analogic.ancp00.AvanconStatusMsg.time_stamp)
}
inline ::std::string* AvanconStatusMsg::mutable_time_stamp() {
  
  // @@protoc_insertion_point(field_mutable:analogic.ancp00.AvanconStatusMsg.time_stamp)
  return time_stamp_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AvanconStatusMsg::release_time_stamp() {
  // @@protoc_insertion_point(field_release:analogic.ancp00.AvanconStatusMsg.time_stamp)
  
  return time_stamp_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AvanconStatusMsg::set_allocated_time_stamp(::std::string* time_stamp) {
  if (time_stamp != NULL) {
    
  } else {
    
  }
  time_stamp_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), time_stamp);
  // @@protoc_insertion_point(field_set_allocated:analogic.ancp00.AvanconStatusMsg.time_stamp)
}

// optional int32 bhs_configuration = 2;
inline void AvanconStatusMsg::clear_bhs_configuration() {
  bhs_configuration_ = 0;
}
inline ::google::protobuf::int32 AvanconStatusMsg::bhs_configuration() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.AvanconStatusMsg.bhs_configuration)
  return bhs_configuration_;
}
inline void AvanconStatusMsg::set_bhs_configuration(::google::protobuf::int32 value) {
  
  bhs_configuration_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.AvanconStatusMsg.bhs_configuration)
}

// optional int32 plc_configuration = 3;
inline void AvanconStatusMsg::clear_plc_configuration() {
  plc_configuration_ = 0;
}
inline ::google::protobuf::int32 AvanconStatusMsg::plc_configuration() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.AvanconStatusMsg.plc_configuration)
  return plc_configuration_;
}
inline void AvanconStatusMsg::set_plc_configuration(::google::protobuf::int32 value) {
  
  plc_configuration_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.AvanconStatusMsg.plc_configuration)
}

// optional string plc_version = 4;
inline void AvanconStatusMsg::clear_plc_version() {
  plc_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AvanconStatusMsg::plc_version() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.AvanconStatusMsg.plc_version)
  return plc_version_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AvanconStatusMsg::set_plc_version(const ::std::string& value) {
  
  plc_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:analogic.ancp00.AvanconStatusMsg.plc_version)
}
inline void AvanconStatusMsg::set_plc_version(const char* value) {
  
  plc_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:analogic.ancp00.AvanconStatusMsg.plc_version)
}
inline void AvanconStatusMsg::set_plc_version(const char* value, size_t size) {
  
  plc_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:analogic.ancp00.AvanconStatusMsg.plc_version)
}
inline ::std::string* AvanconStatusMsg::mutable_plc_version() {
  
  // @@protoc_insertion_point(field_mutable:analogic.ancp00.AvanconStatusMsg.plc_version)
  return plc_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AvanconStatusMsg::release_plc_version() {
  // @@protoc_insertion_point(field_release:analogic.ancp00.AvanconStatusMsg.plc_version)
  
  return plc_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AvanconStatusMsg::set_allocated_plc_version(::std::string* plc_version) {
  if (plc_version != NULL) {
    
  } else {
    
  }
  plc_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), plc_version);
  // @@protoc_insertion_point(field_set_allocated:analogic.ancp00.AvanconStatusMsg.plc_version)
}

// optional string bhs_version = 5;
inline void AvanconStatusMsg::clear_bhs_version() {
  bhs_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AvanconStatusMsg::bhs_version() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.AvanconStatusMsg.bhs_version)
  return bhs_version_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AvanconStatusMsg::set_bhs_version(const ::std::string& value) {
  
  bhs_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:analogic.ancp00.AvanconStatusMsg.bhs_version)
}
inline void AvanconStatusMsg::set_bhs_version(const char* value) {
  
  bhs_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:analogic.ancp00.AvanconStatusMsg.bhs_version)
}
inline void AvanconStatusMsg::set_bhs_version(const char* value, size_t size) {
  
  bhs_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:analogic.ancp00.AvanconStatusMsg.bhs_version)
}
inline ::std::string* AvanconStatusMsg::mutable_bhs_version() {
  
  // @@protoc_insertion_point(field_mutable:analogic.ancp00.AvanconStatusMsg.bhs_version)
  return bhs_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AvanconStatusMsg::release_bhs_version() {
  // @@protoc_insertion_point(field_release:analogic.ancp00.AvanconStatusMsg.bhs_version)
  
  return bhs_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AvanconStatusMsg::set_allocated_bhs_version(::std::string* bhs_version) {
  if (bhs_version != NULL) {
    
  } else {
    
  }
  bhs_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bhs_version);
  // @@protoc_insertion_point(field_set_allocated:analogic.ancp00.AvanconStatusMsg.bhs_version)
}

// optional .analogic.ancp00.ConveyorConfig conv_config = 6;
inline void AvanconStatusMsg::clear_conv_config() {
  conv_config_ = 0;
}
inline ::analogic::ancp00::ConveyorConfig AvanconStatusMsg::conv_config() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.AvanconStatusMsg.conv_config)
  return static_cast< ::analogic::ancp00::ConveyorConfig >(conv_config_);
}
inline void AvanconStatusMsg::set_conv_config(::analogic::ancp00::ConveyorConfig value) {
  
  conv_config_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.AvanconStatusMsg.conv_config)
}

// optional string scanner_state = 7;
inline void AvanconStatusMsg::clear_scanner_state() {
  scanner_state_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AvanconStatusMsg::scanner_state() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.AvanconStatusMsg.scanner_state)
  return scanner_state_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AvanconStatusMsg::set_scanner_state(const ::std::string& value) {
  
  scanner_state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:analogic.ancp00.AvanconStatusMsg.scanner_state)
}
inline void AvanconStatusMsg::set_scanner_state(const char* value) {
  
  scanner_state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:analogic.ancp00.AvanconStatusMsg.scanner_state)
}
inline void AvanconStatusMsg::set_scanner_state(const char* value, size_t size) {
  
  scanner_state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:analogic.ancp00.AvanconStatusMsg.scanner_state)
}
inline ::std::string* AvanconStatusMsg::mutable_scanner_state() {
  
  // @@protoc_insertion_point(field_mutable:analogic.ancp00.AvanconStatusMsg.scanner_state)
  return scanner_state_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AvanconStatusMsg::release_scanner_state() {
  // @@protoc_insertion_point(field_release:analogic.ancp00.AvanconStatusMsg.scanner_state)
  
  return scanner_state_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AvanconStatusMsg::set_allocated_scanner_state(::std::string* scanner_state) {
  if (scanner_state != NULL) {
    
  } else {
    
  }
  scanner_state_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), scanner_state);
  // @@protoc_insertion_point(field_set_allocated:analogic.ancp00.AvanconStatusMsg.scanner_state)
}

// optional string scanner_substate = 8;
inline void AvanconStatusMsg::clear_scanner_substate() {
  scanner_substate_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AvanconStatusMsg::scanner_substate() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.AvanconStatusMsg.scanner_substate)
  return scanner_substate_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AvanconStatusMsg::set_scanner_substate(const ::std::string& value) {
  
  scanner_substate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:analogic.ancp00.AvanconStatusMsg.scanner_substate)
}
inline void AvanconStatusMsg::set_scanner_substate(const char* value) {
  
  scanner_substate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:analogic.ancp00.AvanconStatusMsg.scanner_substate)
}
inline void AvanconStatusMsg::set_scanner_substate(const char* value, size_t size) {
  
  scanner_substate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:analogic.ancp00.AvanconStatusMsg.scanner_substate)
}
inline ::std::string* AvanconStatusMsg::mutable_scanner_substate() {
  
  // @@protoc_insertion_point(field_mutable:analogic.ancp00.AvanconStatusMsg.scanner_substate)
  return scanner_substate_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AvanconStatusMsg::release_scanner_substate() {
  // @@protoc_insertion_point(field_release:analogic.ancp00.AvanconStatusMsg.scanner_substate)
  
  return scanner_substate_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AvanconStatusMsg::set_allocated_scanner_substate(::std::string* scanner_substate) {
  if (scanner_substate != NULL) {
    
  } else {
    
  }
  scanner_substate_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), scanner_substate);
  // @@protoc_insertion_point(field_set_allocated:analogic.ancp00.AvanconStatusMsg.scanner_substate)
}

// optional string bin_type = 9;
inline void AvanconStatusMsg::clear_bin_type() {
  bin_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AvanconStatusMsg::bin_type() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.AvanconStatusMsg.bin_type)
  return bin_type_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AvanconStatusMsg::set_bin_type(const ::std::string& value) {
  
  bin_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:analogic.ancp00.AvanconStatusMsg.bin_type)
}
inline void AvanconStatusMsg::set_bin_type(const char* value) {
  
  bin_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:analogic.ancp00.AvanconStatusMsg.bin_type)
}
inline void AvanconStatusMsg::set_bin_type(const char* value, size_t size) {
  
  bin_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:analogic.ancp00.AvanconStatusMsg.bin_type)
}
inline ::std::string* AvanconStatusMsg::mutable_bin_type() {
  
  // @@protoc_insertion_point(field_mutable:analogic.ancp00.AvanconStatusMsg.bin_type)
  return bin_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AvanconStatusMsg::release_bin_type() {
  // @@protoc_insertion_point(field_release:analogic.ancp00.AvanconStatusMsg.bin_type)
  
  return bin_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AvanconStatusMsg::set_allocated_bin_type(::std::string* bin_type) {
  if (bin_type != NULL) {
    
  } else {
    
  }
  bin_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bin_type);
  // @@protoc_insertion_point(field_set_allocated:analogic.ancp00.AvanconStatusMsg.bin_type)
}

// optional string last_bhs_fault = 10;
inline void AvanconStatusMsg::clear_last_bhs_fault() {
  last_bhs_fault_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AvanconStatusMsg::last_bhs_fault() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.AvanconStatusMsg.last_bhs_fault)
  return last_bhs_fault_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AvanconStatusMsg::set_last_bhs_fault(const ::std::string& value) {
  
  last_bhs_fault_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:analogic.ancp00.AvanconStatusMsg.last_bhs_fault)
}
inline void AvanconStatusMsg::set_last_bhs_fault(const char* value) {
  
  last_bhs_fault_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:analogic.ancp00.AvanconStatusMsg.last_bhs_fault)
}
inline void AvanconStatusMsg::set_last_bhs_fault(const char* value, size_t size) {
  
  last_bhs_fault_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:analogic.ancp00.AvanconStatusMsg.last_bhs_fault)
}
inline ::std::string* AvanconStatusMsg::mutable_last_bhs_fault() {
  
  // @@protoc_insertion_point(field_mutable:analogic.ancp00.AvanconStatusMsg.last_bhs_fault)
  return last_bhs_fault_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AvanconStatusMsg::release_last_bhs_fault() {
  // @@protoc_insertion_point(field_release:analogic.ancp00.AvanconStatusMsg.last_bhs_fault)
  
  return last_bhs_fault_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AvanconStatusMsg::set_allocated_last_bhs_fault(::std::string* last_bhs_fault) {
  if (last_bhs_fault != NULL) {
    
  } else {
    
  }
  last_bhs_fault_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), last_bhs_fault);
  // @@protoc_insertion_point(field_set_allocated:analogic.ancp00.AvanconStatusMsg.last_bhs_fault)
}

// optional string plc_state = 11;
inline void AvanconStatusMsg::clear_plc_state() {
  plc_state_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AvanconStatusMsg::plc_state() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.AvanconStatusMsg.plc_state)
  return plc_state_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AvanconStatusMsg::set_plc_state(const ::std::string& value) {
  
  plc_state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:analogic.ancp00.AvanconStatusMsg.plc_state)
}
inline void AvanconStatusMsg::set_plc_state(const char* value) {
  
  plc_state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:analogic.ancp00.AvanconStatusMsg.plc_state)
}
inline void AvanconStatusMsg::set_plc_state(const char* value, size_t size) {
  
  plc_state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:analogic.ancp00.AvanconStatusMsg.plc_state)
}
inline ::std::string* AvanconStatusMsg::mutable_plc_state() {
  
  // @@protoc_insertion_point(field_mutable:analogic.ancp00.AvanconStatusMsg.plc_state)
  return plc_state_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AvanconStatusMsg::release_plc_state() {
  // @@protoc_insertion_point(field_release:analogic.ancp00.AvanconStatusMsg.plc_state)
  
  return plc_state_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AvanconStatusMsg::set_allocated_plc_state(::std::string* plc_state) {
  if (plc_state != NULL) {
    
  } else {
    
  }
  plc_state_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), plc_state);
  // @@protoc_insertion_point(field_set_allocated:analogic.ancp00.AvanconStatusMsg.plc_state)
}

// optional string last_plc_fault = 12;
inline void AvanconStatusMsg::clear_last_plc_fault() {
  last_plc_fault_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AvanconStatusMsg::last_plc_fault() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.AvanconStatusMsg.last_plc_fault)
  return last_plc_fault_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AvanconStatusMsg::set_last_plc_fault(const ::std::string& value) {
  
  last_plc_fault_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:analogic.ancp00.AvanconStatusMsg.last_plc_fault)
}
inline void AvanconStatusMsg::set_last_plc_fault(const char* value) {
  
  last_plc_fault_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:analogic.ancp00.AvanconStatusMsg.last_plc_fault)
}
inline void AvanconStatusMsg::set_last_plc_fault(const char* value, size_t size) {
  
  last_plc_fault_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:analogic.ancp00.AvanconStatusMsg.last_plc_fault)
}
inline ::std::string* AvanconStatusMsg::mutable_last_plc_fault() {
  
  // @@protoc_insertion_point(field_mutable:analogic.ancp00.AvanconStatusMsg.last_plc_fault)
  return last_plc_fault_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AvanconStatusMsg::release_last_plc_fault() {
  // @@protoc_insertion_point(field_release:analogic.ancp00.AvanconStatusMsg.last_plc_fault)
  
  return last_plc_fault_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AvanconStatusMsg::set_allocated_last_plc_fault(::std::string* last_plc_fault) {
  if (last_plc_fault != NULL) {
    
  } else {
    
  }
  last_plc_fault_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), last_plc_fault);
  // @@protoc_insertion_point(field_set_allocated:analogic.ancp00.AvanconStatusMsg.last_plc_fault)
}

// optional int32 attenuation_distance_mm = 13;
inline void AvanconStatusMsg::clear_attenuation_distance_mm() {
  attenuation_distance_mm_ = 0;
}
inline ::google::protobuf::int32 AvanconStatusMsg::attenuation_distance_mm() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.AvanconStatusMsg.attenuation_distance_mm)
  return attenuation_distance_mm_;
}
inline void AvanconStatusMsg::set_attenuation_distance_mm(::google::protobuf::int32 value) {
  
  attenuation_distance_mm_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.AvanconStatusMsg.attenuation_distance_mm)
}

// optional int32 attenuation_window_mm = 14;
inline void AvanconStatusMsg::clear_attenuation_window_mm() {
  attenuation_window_mm_ = 0;
}
inline ::google::protobuf::int32 AvanconStatusMsg::attenuation_window_mm() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.AvanconStatusMsg.attenuation_window_mm)
  return attenuation_window_mm_;
}
inline void AvanconStatusMsg::set_attenuation_window_mm(::google::protobuf::int32 value) {
  
  attenuation_window_mm_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.AvanconStatusMsg.attenuation_window_mm)
}

// optional bool in_dieback = 15;
inline void AvanconStatusMsg::clear_in_dieback() {
  in_dieback_ = false;
}
inline bool AvanconStatusMsg::in_dieback() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.AvanconStatusMsg.in_dieback)
  return in_dieback_;
}
inline void AvanconStatusMsg::set_in_dieback(bool value) {
  
  in_dieback_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.AvanconStatusMsg.in_dieback)
}

// optional bool forced_divert = 16;
inline void AvanconStatusMsg::clear_forced_divert() {
  forced_divert_ = false;
}
inline bool AvanconStatusMsg::forced_divert() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.AvanconStatusMsg.forced_divert)
  return forced_divert_;
}
inline void AvanconStatusMsg::set_forced_divert(bool value) {
  
  forced_divert_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.AvanconStatusMsg.forced_divert)
}

// optional bool divert_warning = 17;
inline void AvanconStatusMsg::clear_divert_warning() {
  divert_warning_ = false;
}
inline bool AvanconStatusMsg::divert_warning() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.AvanconStatusMsg.divert_warning)
  return divert_warning_;
}
inline void AvanconStatusMsg::set_divert_warning(bool value) {
  
  divert_warning_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.AvanconStatusMsg.divert_warning)
}

// optional .analogic.ancp00.RfidReader entrance_rfid = 18;
inline bool AvanconStatusMsg::has_entrance_rfid() const {
  return !_is_default_instance_ && entrance_rfid_ != NULL;
}
inline void AvanconStatusMsg::clear_entrance_rfid() {
  if (GetArenaNoVirtual() == NULL && entrance_rfid_ != NULL) delete entrance_rfid_;
  entrance_rfid_ = NULL;
}
inline const ::analogic::ancp00::RfidReader& AvanconStatusMsg::entrance_rfid() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.AvanconStatusMsg.entrance_rfid)
  return entrance_rfid_ != NULL ? *entrance_rfid_ : *default_instance_->entrance_rfid_;
}
inline ::analogic::ancp00::RfidReader* AvanconStatusMsg::mutable_entrance_rfid() {
  
  if (entrance_rfid_ == NULL) {
    entrance_rfid_ = new ::analogic::ancp00::RfidReader;
  }
  // @@protoc_insertion_point(field_mutable:analogic.ancp00.AvanconStatusMsg.entrance_rfid)
  return entrance_rfid_;
}
inline ::analogic::ancp00::RfidReader* AvanconStatusMsg::release_entrance_rfid() {
  // @@protoc_insertion_point(field_release:analogic.ancp00.AvanconStatusMsg.entrance_rfid)
  
  ::analogic::ancp00::RfidReader* temp = entrance_rfid_;
  entrance_rfid_ = NULL;
  return temp;
}
inline void AvanconStatusMsg::set_allocated_entrance_rfid(::analogic::ancp00::RfidReader* entrance_rfid) {
  delete entrance_rfid_;
  entrance_rfid_ = entrance_rfid;
  if (entrance_rfid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:analogic.ancp00.AvanconStatusMsg.entrance_rfid)
}

// optional .analogic.ancp00.RfidReader exit_rfid = 19;
inline bool AvanconStatusMsg::has_exit_rfid() const {
  return !_is_default_instance_ && exit_rfid_ != NULL;
}
inline void AvanconStatusMsg::clear_exit_rfid() {
  if (GetArenaNoVirtual() == NULL && exit_rfid_ != NULL) delete exit_rfid_;
  exit_rfid_ = NULL;
}
inline const ::analogic::ancp00::RfidReader& AvanconStatusMsg::exit_rfid() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.AvanconStatusMsg.exit_rfid)
  return exit_rfid_ != NULL ? *exit_rfid_ : *default_instance_->exit_rfid_;
}
inline ::analogic::ancp00::RfidReader* AvanconStatusMsg::mutable_exit_rfid() {
  
  if (exit_rfid_ == NULL) {
    exit_rfid_ = new ::analogic::ancp00::RfidReader;
  }
  // @@protoc_insertion_point(field_mutable:analogic.ancp00.AvanconStatusMsg.exit_rfid)
  return exit_rfid_;
}
inline ::analogic::ancp00::RfidReader* AvanconStatusMsg::release_exit_rfid() {
  // @@protoc_insertion_point(field_release:analogic.ancp00.AvanconStatusMsg.exit_rfid)
  
  ::analogic::ancp00::RfidReader* temp = exit_rfid_;
  exit_rfid_ = NULL;
  return temp;
}
inline void AvanconStatusMsg::set_allocated_exit_rfid(::analogic::ancp00::RfidReader* exit_rfid) {
  delete exit_rfid_;
  exit_rfid_ = exit_rfid;
  if (exit_rfid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:analogic.ancp00.AvanconStatusMsg.exit_rfid)
}

// repeated .analogic.ancp00.Conveyor conveyor = 20;
inline int AvanconStatusMsg::conveyor_size() const {
  return conveyor_.size();
}
inline void AvanconStatusMsg::clear_conveyor() {
  conveyor_.Clear();
}
inline const ::analogic::ancp00::Conveyor& AvanconStatusMsg::conveyor(int index) const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.AvanconStatusMsg.conveyor)
  return conveyor_.Get(index);
}
inline ::analogic::ancp00::Conveyor* AvanconStatusMsg::mutable_conveyor(int index) {
  // @@protoc_insertion_point(field_mutable:analogic.ancp00.AvanconStatusMsg.conveyor)
  return conveyor_.Mutable(index);
}
inline ::analogic::ancp00::Conveyor* AvanconStatusMsg::add_conveyor() {
  // @@protoc_insertion_point(field_add:analogic.ancp00.AvanconStatusMsg.conveyor)
  return conveyor_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::analogic::ancp00::Conveyor >*
AvanconStatusMsg::mutable_conveyor() {
  // @@protoc_insertion_point(field_mutable_list:analogic.ancp00.AvanconStatusMsg.conveyor)
  return &conveyor_;
}
inline const ::google::protobuf::RepeatedPtrField< ::analogic::ancp00::Conveyor >&
AvanconStatusMsg::conveyor() const {
  // @@protoc_insertion_point(field_list:analogic.ancp00.AvanconStatusMsg.conveyor)
  return conveyor_;
}

// optional bool bhs_warning = 21;
inline void AvanconStatusMsg::clear_bhs_warning() {
  bhs_warning_ = false;
}
inline bool AvanconStatusMsg::bhs_warning() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.AvanconStatusMsg.bhs_warning)
  return bhs_warning_;
}
inline void AvanconStatusMsg::set_bhs_warning(bool value) {
  
  bhs_warning_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.AvanconStatusMsg.bhs_warning)
}

// optional bool sensor_warning = 22;
inline void AvanconStatusMsg::clear_sensor_warning() {
  sensor_warning_ = false;
}
inline bool AvanconStatusMsg::sensor_warning() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.AvanconStatusMsg.sensor_warning)
  return sensor_warning_;
}
inline void AvanconStatusMsg::set_sensor_warning(bool value) {
  
  sensor_warning_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.AvanconStatusMsg.sensor_warning)
}

// optional bool Z5_exception = 23;
inline void AvanconStatusMsg::clear_z5_exception() {
  z5_exception_ = false;
}
inline bool AvanconStatusMsg::z5_exception() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.AvanconStatusMsg.Z5_exception)
  return z5_exception_;
}
inline void AvanconStatusMsg::set_z5_exception(bool value) {
  
  z5_exception_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.AvanconStatusMsg.Z5_exception)
}

// optional bool Z4_longbag = 24;
inline void AvanconStatusMsg::clear_z4_longbag() {
  z4_longbag_ = false;
}
inline bool AvanconStatusMsg::z4_longbag() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.AvanconStatusMsg.Z4_longbag)
  return z4_longbag_;
}
inline void AvanconStatusMsg::set_z4_longbag(bool value) {
  
  z4_longbag_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.AvanconStatusMsg.Z4_longbag)
}

// optional bool external_warning = 25;
inline void AvanconStatusMsg::clear_external_warning() {
  external_warning_ = false;
}
inline bool AvanconStatusMsg::external_warning() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.AvanconStatusMsg.external_warning)
  return external_warning_;
}
inline void AvanconStatusMsg::set_external_warning(bool value) {
  
  external_warning_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.AvanconStatusMsg.external_warning)
}

// optional int32 total_attenuation_events = 26;
inline void AvanconStatusMsg::clear_total_attenuation_events() {
  total_attenuation_events_ = 0;
}
inline ::google::protobuf::int32 AvanconStatusMsg::total_attenuation_events() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.AvanconStatusMsg.total_attenuation_events)
  return total_attenuation_events_;
}
inline void AvanconStatusMsg::set_total_attenuation_events(::google::protobuf::int32 value) {
  
  total_attenuation_events_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.AvanconStatusMsg.total_attenuation_events)
}

// optional int32 total_entrance_events = 27;
inline void AvanconStatusMsg::clear_total_entrance_events() {
  total_entrance_events_ = 0;
}
inline ::google::protobuf::int32 AvanconStatusMsg::total_entrance_events() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.AvanconStatusMsg.total_entrance_events)
  return total_entrance_events_;
}
inline void AvanconStatusMsg::set_total_entrance_events(::google::protobuf::int32 value) {
  
  total_entrance_events_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.AvanconStatusMsg.total_entrance_events)
}

// optional int32 total_exit_events = 28;
inline void AvanconStatusMsg::clear_total_exit_events() {
  total_exit_events_ = 0;
}
inline ::google::protobuf::int32 AvanconStatusMsg::total_exit_events() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.AvanconStatusMsg.total_exit_events)
  return total_exit_events_;
}
inline void AvanconStatusMsg::set_total_exit_events(::google::protobuf::int32 value) {
  
  total_exit_events_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.AvanconStatusMsg.total_exit_events)
}

// optional int32 total_operator_cleared = 29;
inline void AvanconStatusMsg::clear_total_operator_cleared() {
  total_operator_cleared_ = 0;
}
inline ::google::protobuf::int32 AvanconStatusMsg::total_operator_cleared() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.AvanconStatusMsg.total_operator_cleared)
  return total_operator_cleared_;
}
inline void AvanconStatusMsg::set_total_operator_cleared(::google::protobuf::int32 value) {
  
  total_operator_cleared_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.AvanconStatusMsg.total_operator_cleared)
}

// optional int32 total_operator_rejected = 30;
inline void AvanconStatusMsg::clear_total_operator_rejected() {
  total_operator_rejected_ = 0;
}
inline ::google::protobuf::int32 AvanconStatusMsg::total_operator_rejected() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.AvanconStatusMsg.total_operator_rejected)
  return total_operator_rejected_;
}
inline void AvanconStatusMsg::set_total_operator_rejected(::google::protobuf::int32 value) {
  
  total_operator_rejected_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.AvanconStatusMsg.total_operator_rejected)
}

// optional int32 total_lost_tracking = 31;
inline void AvanconStatusMsg::clear_total_lost_tracking() {
  total_lost_tracking_ = 0;
}
inline ::google::protobuf::int32 AvanconStatusMsg::total_lost_tracking() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.AvanconStatusMsg.total_lost_tracking)
  return total_lost_tracking_;
}
inline void AvanconStatusMsg::set_total_lost_tracking(::google::protobuf::int32 value) {
  
  total_lost_tracking_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.AvanconStatusMsg.total_lost_tracking)
}

// optional int32 total_unlinked = 32;
inline void AvanconStatusMsg::clear_total_unlinked() {
  total_unlinked_ = 0;
}
inline ::google::protobuf::int32 AvanconStatusMsg::total_unlinked() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.AvanconStatusMsg.total_unlinked)
  return total_unlinked_;
}
inline void AvanconStatusMsg::set_total_unlinked(::google::protobuf::int32 value) {
  
  total_unlinked_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.AvanconStatusMsg.total_unlinked)
}

// optional int32 total_entrance_rfid_misreads = 33;
inline void AvanconStatusMsg::clear_total_entrance_rfid_misreads() {
  total_entrance_rfid_misreads_ = 0;
}
inline ::google::protobuf::int32 AvanconStatusMsg::total_entrance_rfid_misreads() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.AvanconStatusMsg.total_entrance_rfid_misreads)
  return total_entrance_rfid_misreads_;
}
inline void AvanconStatusMsg::set_total_entrance_rfid_misreads(::google::protobuf::int32 value) {
  
  total_entrance_rfid_misreads_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.AvanconStatusMsg.total_entrance_rfid_misreads)
}

// optional int32 total_exit_rfid_misreads = 34;
inline void AvanconStatusMsg::clear_total_exit_rfid_misreads() {
  total_exit_rfid_misreads_ = 0;
}
inline ::google::protobuf::int32 AvanconStatusMsg::total_exit_rfid_misreads() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.AvanconStatusMsg.total_exit_rfid_misreads)
  return total_exit_rfid_misreads_;
}
inline void AvanconStatusMsg::set_total_exit_rfid_misreads(::google::protobuf::int32 value) {
  
  total_exit_rfid_misreads_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.AvanconStatusMsg.total_exit_rfid_misreads)
}

// optional int32 total_oversize_bags = 35;
inline void AvanconStatusMsg::clear_total_oversize_bags() {
  total_oversize_bags_ = 0;
}
inline ::google::protobuf::int32 AvanconStatusMsg::total_oversize_bags() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.AvanconStatusMsg.total_oversize_bags)
  return total_oversize_bags_;
}
inline void AvanconStatusMsg::set_total_oversize_bags(::google::protobuf::int32 value) {
  
  total_oversize_bags_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.AvanconStatusMsg.total_oversize_bags)
}

// optional int32 total_cut_bags = 36;
inline void AvanconStatusMsg::clear_total_cut_bags() {
  total_cut_bags_ = 0;
}
inline ::google::protobuf::int32 AvanconStatusMsg::total_cut_bags() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.AvanconStatusMsg.total_cut_bags)
  return total_cut_bags_;
}
inline void AvanconStatusMsg::set_total_cut_bags(::google::protobuf::int32 value) {
  
  total_cut_bags_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.AvanconStatusMsg.total_cut_bags)
}

// optional bool master_bag_jam = 37;
inline void AvanconStatusMsg::clear_master_bag_jam() {
  master_bag_jam_ = false;
}
inline bool AvanconStatusMsg::master_bag_jam() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.AvanconStatusMsg.master_bag_jam)
  return master_bag_jam_;
}
inline void AvanconStatusMsg::set_master_bag_jam(bool value) {
  
  master_bag_jam_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.AvanconStatusMsg.master_bag_jam)
}

// optional int32 bag_jam_bits = 38;
inline void AvanconStatusMsg::clear_bag_jam_bits() {
  bag_jam_bits_ = 0;
}
inline ::google::protobuf::int32 AvanconStatusMsg::bag_jam_bits() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.AvanconStatusMsg.bag_jam_bits)
  return bag_jam_bits_;
}
inline void AvanconStatusMsg::set_bag_jam_bits(::google::protobuf::int32 value) {
  
  bag_jam_bits_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.AvanconStatusMsg.bag_jam_bits)
}

// optional int32 attenuation_start_buffer_mm = 39;
inline void AvanconStatusMsg::clear_attenuation_start_buffer_mm() {
  attenuation_start_buffer_mm_ = 0;
}
inline ::google::protobuf::int32 AvanconStatusMsg::attenuation_start_buffer_mm() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.AvanconStatusMsg.attenuation_start_buffer_mm)
  return attenuation_start_buffer_mm_;
}
inline void AvanconStatusMsg::set_attenuation_start_buffer_mm(::google::protobuf::int32 value) {
  
  attenuation_start_buffer_mm_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.AvanconStatusMsg.attenuation_start_buffer_mm)
}

// -------------------------------------------------------------------

// ConveyorMotorCmd

// optional int32 zone_id = 1;
inline void ConveyorMotorCmd::clear_zone_id() {
  zone_id_ = 0;
}
inline ::google::protobuf::int32 ConveyorMotorCmd::zone_id() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.ConveyorMotorCmd.zone_id)
  return zone_id_;
}
inline void ConveyorMotorCmd::set_zone_id(::google::protobuf::int32 value) {
  
  zone_id_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.ConveyorMotorCmd.zone_id)
}

// optional bool is_diverter = 2;
inline void ConveyorMotorCmd::clear_is_diverter() {
  is_diverter_ = false;
}
inline bool ConveyorMotorCmd::is_diverter() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.ConveyorMotorCmd.is_diverter)
  return is_diverter_;
}
inline void ConveyorMotorCmd::set_is_diverter(bool value) {
  
  is_diverter_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.ConveyorMotorCmd.is_diverter)
}

// optional bool divert = 3;
inline void ConveyorMotorCmd::clear_divert() {
  divert_ = false;
}
inline bool ConveyorMotorCmd::divert() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.ConveyorMotorCmd.divert)
  return divert_;
}
inline void ConveyorMotorCmd::set_divert(bool value) {
  
  divert_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.ConveyorMotorCmd.divert)
}

// optional .analogic.ancp00.ConveyorMotorCmd.Command cmd = 4;
inline void ConveyorMotorCmd::clear_cmd() {
  cmd_ = 0;
}
inline ::analogic::ancp00::ConveyorMotorCmd_Command ConveyorMotorCmd::cmd() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.ConveyorMotorCmd.cmd)
  return static_cast< ::analogic::ancp00::ConveyorMotorCmd_Command >(cmd_);
}
inline void ConveyorMotorCmd::set_cmd(::analogic::ancp00::ConveyorMotorCmd_Command value) {
  
  cmd_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.ConveyorMotorCmd.cmd)
}

// -------------------------------------------------------------------

// ConveyorMotorCmdMsg

// repeated .analogic.ancp00.ConveyorMotorCmd cmds = 1;
inline int ConveyorMotorCmdMsg::cmds_size() const {
  return cmds_.size();
}
inline void ConveyorMotorCmdMsg::clear_cmds() {
  cmds_.Clear();
}
inline const ::analogic::ancp00::ConveyorMotorCmd& ConveyorMotorCmdMsg::cmds(int index) const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.ConveyorMotorCmdMsg.cmds)
  return cmds_.Get(index);
}
inline ::analogic::ancp00::ConveyorMotorCmd* ConveyorMotorCmdMsg::mutable_cmds(int index) {
  // @@protoc_insertion_point(field_mutable:analogic.ancp00.ConveyorMotorCmdMsg.cmds)
  return cmds_.Mutable(index);
}
inline ::analogic::ancp00::ConveyorMotorCmd* ConveyorMotorCmdMsg::add_cmds() {
  // @@protoc_insertion_point(field_add:analogic.ancp00.ConveyorMotorCmdMsg.cmds)
  return cmds_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::analogic::ancp00::ConveyorMotorCmd >*
ConveyorMotorCmdMsg::mutable_cmds() {
  // @@protoc_insertion_point(field_mutable_list:analogic.ancp00.ConveyorMotorCmdMsg.cmds)
  return &cmds_;
}
inline const ::google::protobuf::RepeatedPtrField< ::analogic::ancp00::ConveyorMotorCmd >&
ConveyorMotorCmdMsg::cmds() const {
  // @@protoc_insertion_point(field_list:analogic.ancp00.ConveyorMotorCmdMsg.cmds)
  return cmds_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace ancp00
}  // namespace analogic

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::analogic::ancp00::RfidReader_RfidState> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::analogic::ancp00::RfidReader_RfidState>() {
  return ::analogic::ancp00::RfidReader_RfidState_descriptor();
}
template <> struct is_proto_enum< ::analogic::ancp00::Sensor_SensorState> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::analogic::ancp00::Sensor_SensorState>() {
  return ::analogic::ancp00::Sensor_SensorState_descriptor();
}
template <> struct is_proto_enum< ::analogic::ancp00::Conveyor_ConveyorState> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::analogic::ancp00::Conveyor_ConveyorState>() {
  return ::analogic::ancp00::Conveyor_ConveyorState_descriptor();
}
template <> struct is_proto_enum< ::analogic::ancp00::Conveyor_DiverterPosition> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::analogic::ancp00::Conveyor_DiverterPosition>() {
  return ::analogic::ancp00::Conveyor_DiverterPosition_descriptor();
}
template <> struct is_proto_enum< ::analogic::ancp00::ConveyorMotorCmd_Command> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::analogic::ancp00::ConveyorMotorCmd_Command>() {
  return ::analogic::ancp00::ConveyorMotorCmd_Command_descriptor();
}
template <> struct is_proto_enum< ::analogic::ancp00::ConveyorConfig> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::analogic::ancp00::ConveyorConfig>() {
  return ::analogic::ancp00::ConveyorConfig_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_proto_2fAvanconStatus_2eproto__INCLUDED
