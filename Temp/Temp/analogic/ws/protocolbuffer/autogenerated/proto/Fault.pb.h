// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/Fault.proto

#ifndef PROTOBUF_proto_2fFault_2eproto__INCLUDED
#define PROTOBUF_proto_2fFault_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "proto/SubsystemIds.pb.h"
// @@protoc_insertion_point(includes)

namespace analogic {
namespace ancp00 {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_proto_2fFault_2eproto();
void protobuf_AssignDesc_proto_2fFault_2eproto();
void protobuf_ShutdownFile_proto_2fFault_2eproto();

class BLMFault;
class BhsFault;
class CommFault;
class ComputerFault;
class DrbFault;
class Fault;
class FaultData;
class FaultFilterCondition;
class GenericFault;
class InterlockFault;
class MotorControlFault;
class NimFault;
class PowerlinkFault;
class ReconFault;
class SafetyIoFault;
class TempHumidityFault;
class UpsFault;
class XrayControlFault;

enum FaultData_FAULT_LEVEL {
  FaultData_FAULT_LEVEL_FAULT_NOTICE = 0,
  FaultData_FAULT_LEVEL_FAULT_WARNING = 1,
  FaultData_FAULT_LEVEL_FAULT_ERROR = 2,
  FaultData_FAULT_LEVEL_FAULT_FATAL = 3,
  FaultData_FAULT_LEVEL_FAULT_SHUTDOWN = 4,
  FaultData_FAULT_LEVEL_FaultData_FAULT_LEVEL_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  FaultData_FAULT_LEVEL_FaultData_FAULT_LEVEL_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool FaultData_FAULT_LEVEL_IsValid(int value);
const FaultData_FAULT_LEVEL FaultData_FAULT_LEVEL_FAULT_LEVEL_MIN = FaultData_FAULT_LEVEL_FAULT_NOTICE;
const FaultData_FAULT_LEVEL FaultData_FAULT_LEVEL_FAULT_LEVEL_MAX = FaultData_FAULT_LEVEL_FAULT_SHUTDOWN;
const int FaultData_FAULT_LEVEL_FAULT_LEVEL_ARRAYSIZE = FaultData_FAULT_LEVEL_FAULT_LEVEL_MAX + 1;

const ::google::protobuf::EnumDescriptor* FaultData_FAULT_LEVEL_descriptor();
inline const ::std::string& FaultData_FAULT_LEVEL_Name(FaultData_FAULT_LEVEL value) {
  return ::google::protobuf::internal::NameOfEnum(
    FaultData_FAULT_LEVEL_descriptor(), value);
}
inline bool FaultData_FAULT_LEVEL_Parse(
    const ::std::string& name, FaultData_FAULT_LEVEL* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FaultData_FAULT_LEVEL>(
    FaultData_FAULT_LEVEL_descriptor(), name, value);
}
enum GenericFault_FAULT_ID {
  GenericFault_FAULT_ID_NOT_USED = 0,
  GenericFault_FAULT_ID_MSG_NOT_RECEIVED = 1000,
  GenericFault_FAULT_ID_MSG_NOT_SENT = 1001,
  GenericFault_FAULT_ID_MSG_REPLY_ERROR = 1002,
  GenericFault_FAULT_ID_MSG_REPLY_UNKNOWN = 1003,
  GenericFault_FAULT_ID_DEADLINE_REACHED = 1004,
  GenericFault_FAULT_ID_EVENT_PUBLISH_FAULT = 1005,
  GenericFault_FAULT_ID_PERSIST_DATA_FAULT = 1006,
  GenericFault_FAULT_ID_RETRIEVE_DATA_FAULT = 1007,
  GenericFault_FAULT_ID_INTERLOCK_VIOLATION = 1008,
  GenericFault_FAULT_ID_UNKNOWN_COMMAND_FAULT = 1009,
  GenericFault_FAULT_ID_COMMAND_FAILURE = 1010,
  GenericFault_FAULT_ID_RPC_START_FAILURE = 1011,
  GenericFault_FAULT_ID_RPC_CANNOT_START_FAILURE = 1012,
  GenericFault_FAULT_ID_CONTROL_SEQUENCE_ERROR = 1013,
  GenericFault_FAULT_ID_CONTROL_SEQUENCE_TIMEOUT = 1014,
  GenericFault_FAULT_ID_PROCESS_EXITED = 1015,
  GenericFault_FAULT_ID_ESTOP_PRESSED = 1016,
  GenericFault_FAULT_ID_SYSTEM_COMM_ERROR = 1017,
  GenericFault_FAULT_ID_ESTOP_RELEASED = 1018,
  GenericFault_FAULT_ID_HARD_DRIVE_SPACE_EXCEEDED = 1019,
  GenericFault_FAULT_ID_RAID_NOT_FOUND = 1020,
  GenericFault_FAULT_ID_NETWORK_SPEED_THROTTLED = 1021,
  GenericFault_FAULT_ID_SOFTWARE_INTRUSION_DETECTED = 1022,
  GenericFault_FAULT_ID_GenericFault_FAULT_ID_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  GenericFault_FAULT_ID_GenericFault_FAULT_ID_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool GenericFault_FAULT_ID_IsValid(int value);
const GenericFault_FAULT_ID GenericFault_FAULT_ID_FAULT_ID_MIN = GenericFault_FAULT_ID_NOT_USED;
const GenericFault_FAULT_ID GenericFault_FAULT_ID_FAULT_ID_MAX = GenericFault_FAULT_ID_SOFTWARE_INTRUSION_DETECTED;
const int GenericFault_FAULT_ID_FAULT_ID_ARRAYSIZE = GenericFault_FAULT_ID_FAULT_ID_MAX + 1;

const ::google::protobuf::EnumDescriptor* GenericFault_FAULT_ID_descriptor();
inline const ::std::string& GenericFault_FAULT_ID_Name(GenericFault_FAULT_ID value) {
  return ::google::protobuf::internal::NameOfEnum(
    GenericFault_FAULT_ID_descriptor(), value);
}
inline bool GenericFault_FAULT_ID_Parse(
    const ::std::string& name, GenericFault_FAULT_ID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GenericFault_FAULT_ID>(
    GenericFault_FAULT_ID_descriptor(), name, value);
}
enum XrayControlFault_FAULT_ID {
  XrayControlFault_FAULT_ID_NOT_USED = 0,
  XrayControlFault_FAULT_ID_ANONYMOUS_IO_FAULT = 2000,
  XrayControlFault_FAULT_ID_RCB_FAULT = 2001,
  XrayControlFault_FAULT_ID_DISK_SPEED_FAULT = 2002,
  XrayControlFault_FAULT_ID_XRAY_VOLTAGE_FAULT = 2003,
  XrayControlFault_FAULT_ID_XRAY_CURRENT_FAULT = 2004,
  XrayControlFault_FAULT_ID_POWERLINK_COMMAND_FAULT = 2005,
  XrayControlFault_FAULT_ID_XRAY_CMD_BITS_MISMATCH_FAULT = 2006,
  XrayControlFault_FAULT_ID_XRAY_ARC_FAULT = 2007,
  XrayControlFault_FAULT_ID_XRAY_ANODE_OVER_KV_FAULT = 2008,
  XrayControlFault_FAULT_ID_XRAY_CATHODE_OVER_KV_FAULT = 2009,
  XrayControlFault_FAULT_ID_INTERLOCK_OPEN_FAULT = 2010,
  XrayControlFault_FAULT_ID_OVERTEMP_FAULT = 2011,
  XrayControlFault_FAULT_ID_OVER_CURRENT_FAULT = 2012,
  XrayControlFault_FAULT_ID_OVER_VOLTAGE_FAULT = 2013,
  XrayControlFault_FAULT_ID_POWER_LIMIT_FAULT = 2014,
  XrayControlFault_FAULT_ID_REGULATION_FAULT = 2015,
  XrayControlFault_FAULT_ID_XrayControlFault_FAULT_ID_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  XrayControlFault_FAULT_ID_XrayControlFault_FAULT_ID_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool XrayControlFault_FAULT_ID_IsValid(int value);
const XrayControlFault_FAULT_ID XrayControlFault_FAULT_ID_FAULT_ID_MIN = XrayControlFault_FAULT_ID_NOT_USED;
const XrayControlFault_FAULT_ID XrayControlFault_FAULT_ID_FAULT_ID_MAX = XrayControlFault_FAULT_ID_REGULATION_FAULT;
const int XrayControlFault_FAULT_ID_FAULT_ID_ARRAYSIZE = XrayControlFault_FAULT_ID_FAULT_ID_MAX + 1;

const ::google::protobuf::EnumDescriptor* XrayControlFault_FAULT_ID_descriptor();
inline const ::std::string& XrayControlFault_FAULT_ID_Name(XrayControlFault_FAULT_ID value) {
  return ::google::protobuf::internal::NameOfEnum(
    XrayControlFault_FAULT_ID_descriptor(), value);
}
inline bool XrayControlFault_FAULT_ID_Parse(
    const ::std::string& name, XrayControlFault_FAULT_ID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<XrayControlFault_FAULT_ID>(
    XrayControlFault_FAULT_ID_descriptor(), name, value);
}
enum MotorControlFault_FAULT_ID {
  MotorControlFault_FAULT_ID_NOT_USED = 0,
  MotorControlFault_FAULT_ID_ANONYMOUS_IO_FAULT = 3000,
  MotorControlFault_FAULT_ID_SAFETY_IO_FAULT = 3001,
  MotorControlFault_FAULT_ID_MOTOR_DRIVE_FAULT = 3002,
  MotorControlFault_FAULT_ID_MotorControlFault_FAULT_ID_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  MotorControlFault_FAULT_ID_MotorControlFault_FAULT_ID_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool MotorControlFault_FAULT_ID_IsValid(int value);
const MotorControlFault_FAULT_ID MotorControlFault_FAULT_ID_FAULT_ID_MIN = MotorControlFault_FAULT_ID_NOT_USED;
const MotorControlFault_FAULT_ID MotorControlFault_FAULT_ID_FAULT_ID_MAX = MotorControlFault_FAULT_ID_MOTOR_DRIVE_FAULT;
const int MotorControlFault_FAULT_ID_FAULT_ID_ARRAYSIZE = MotorControlFault_FAULT_ID_FAULT_ID_MAX + 1;

const ::google::protobuf::EnumDescriptor* MotorControlFault_FAULT_ID_descriptor();
inline const ::std::string& MotorControlFault_FAULT_ID_Name(MotorControlFault_FAULT_ID value) {
  return ::google::protobuf::internal::NameOfEnum(
    MotorControlFault_FAULT_ID_descriptor(), value);
}
inline bool MotorControlFault_FAULT_ID_Parse(
    const ::std::string& name, MotorControlFault_FAULT_ID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MotorControlFault_FAULT_ID>(
    MotorControlFault_FAULT_ID_descriptor(), name, value);
}
enum PowerlinkFault_FAULT_ID {
  PowerlinkFault_FAULT_ID_NOT_USED = 0,
  PowerlinkFault_FAULT_ID_STATUS_FAULT = 4000,
  PowerlinkFault_FAULT_ID_POWERLINK_DISABLED = 4001,
  PowerlinkFault_FAULT_ID_PowerlinkFault_FAULT_ID_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  PowerlinkFault_FAULT_ID_PowerlinkFault_FAULT_ID_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool PowerlinkFault_FAULT_ID_IsValid(int value);
const PowerlinkFault_FAULT_ID PowerlinkFault_FAULT_ID_FAULT_ID_MIN = PowerlinkFault_FAULT_ID_NOT_USED;
const PowerlinkFault_FAULT_ID PowerlinkFault_FAULT_ID_FAULT_ID_MAX = PowerlinkFault_FAULT_ID_POWERLINK_DISABLED;
const int PowerlinkFault_FAULT_ID_FAULT_ID_ARRAYSIZE = PowerlinkFault_FAULT_ID_FAULT_ID_MAX + 1;

const ::google::protobuf::EnumDescriptor* PowerlinkFault_FAULT_ID_descriptor();
inline const ::std::string& PowerlinkFault_FAULT_ID_Name(PowerlinkFault_FAULT_ID value) {
  return ::google::protobuf::internal::NameOfEnum(
    PowerlinkFault_FAULT_ID_descriptor(), value);
}
inline bool PowerlinkFault_FAULT_ID_Parse(
    const ::std::string& name, PowerlinkFault_FAULT_ID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PowerlinkFault_FAULT_ID>(
    PowerlinkFault_FAULT_ID_descriptor(), name, value);
}
enum SafetyIoFault_FAULT_ID {
  SafetyIoFault_FAULT_ID_NOT_USED = 0,
  SafetyIoFault_FAULT_ID_XRAY_FAULT_CLEAR_TIMEOUT = 5000,
  SafetyIoFault_FAULT_ID_ESTOP = 5001,
  SafetyIoFault_FAULT_ID_ACCESS_PANEL = 5002,
  SafetyIoFault_FAULT_ID_CONTACTOR = 5003,
  SafetyIoFault_FAULT_ID_ENVELOPE_SENSOR = 5004,
  SafetyIoFault_FAULT_ID_STANDSTILL_MONITOR = 5005,
  SafetyIoFault_FAULT_ID_SPEED_FAULT = 5006,
  SafetyIoFault_FAULT_ID_UNKNOWN = 5007,
  SafetyIoFault_FAULT_ID_ENTRANCE_ESTOP_PRESSED = 5008,
  SafetyIoFault_FAULT_ID_EXIT_ESTOP_PRESSED = 5009,
  SafetyIoFault_FAULT_ID_CONSOLE_ESTOP_PRESSED = 5010,
  SafetyIoFault_FAULT_ID_REMOTE_ESTOP_PRESSED = 5011,
  SafetyIoFault_FAULT_ID_MOTION_CONTACTORS_STATUS_FAULT = 5012,
  SafetyIoFault_FAULT_ID_POWERLINK_CONTACTORS_STATUS_FAULT = 5013,
  SafetyIoFault_FAULT_ID_ROTATIONAL_ENVELOPE_VIOLATION_SENSOR_FAULT = 5014,
  SafetyIoFault_FAULT_ID_STANDSTILL_MONITOR_FAULT = 5015,
  SafetyIoFault_FAULT_ID_OVERSPEED_FAULT = 5016,
  SafetyIoFault_FAULT_ID_ACCESS_PANELS_LOCKING_FAULT = 5017,
  SafetyIoFault_FAULT_ID_LEFT_ACCESS_PANEL_INTERLOCK_FAULT = 5018,
  SafetyIoFault_FAULT_ID_LEFT_ACCESS_PANEL_SOLENOID_STATUS_FAULT = 5019,
  SafetyIoFault_FAULT_ID_LEFT_ACCESS_PANEL_SOLENOID_LOCKED_STATUS_FAULT = 5020,
  SafetyIoFault_FAULT_ID_RIGHT_ACCESS_PANEL_INTERLOCK_FAULT = 5021,
  SafetyIoFault_FAULT_ID_RIGHT_ACCESS_PANEL_SOLENOID_STATUS_FAULT = 5022,
  SafetyIoFault_FAULT_ID_RIGHT_ACCESS_PANEL_SOLENOID_LOCKED_STATUS_FAULT = 5023,
  SafetyIoFault_FAULT_ID_MANUAL_RESET_NEEDED = 5024,
  SafetyIoFault_FAULT_ID_ENCODER_FAULT = 5025,
  SafetyIoFault_FAULT_ID_SafetyIoFault_FAULT_ID_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SafetyIoFault_FAULT_ID_SafetyIoFault_FAULT_ID_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SafetyIoFault_FAULT_ID_IsValid(int value);
const SafetyIoFault_FAULT_ID SafetyIoFault_FAULT_ID_FAULT_ID_MIN = SafetyIoFault_FAULT_ID_NOT_USED;
const SafetyIoFault_FAULT_ID SafetyIoFault_FAULT_ID_FAULT_ID_MAX = SafetyIoFault_FAULT_ID_ENCODER_FAULT;
const int SafetyIoFault_FAULT_ID_FAULT_ID_ARRAYSIZE = SafetyIoFault_FAULT_ID_FAULT_ID_MAX + 1;

const ::google::protobuf::EnumDescriptor* SafetyIoFault_FAULT_ID_descriptor();
inline const ::std::string& SafetyIoFault_FAULT_ID_Name(SafetyIoFault_FAULT_ID value) {
  return ::google::protobuf::internal::NameOfEnum(
    SafetyIoFault_FAULT_ID_descriptor(), value);
}
inline bool SafetyIoFault_FAULT_ID_Parse(
    const ::std::string& name, SafetyIoFault_FAULT_ID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SafetyIoFault_FAULT_ID>(
    SafetyIoFault_FAULT_ID_descriptor(), name, value);
}
enum ReconFault_FAULT_ID {
  ReconFault_FAULT_ID_NOT_USED = 0,
  ReconFault_FAULT_ID_FILE_READ_ERROR = 6000,
  ReconFault_FAULT_ID_GENERAL_INIT_ERROR = 6001,
  ReconFault_FAULT_ID_GPU_LIB_INIT_ERROR = 6002,
  ReconFault_FAULT_ID_OFFSET_CAL_FAULT = 6003,
  ReconFault_FAULT_ID_AIR_CAL_FAULT = 6004,
  ReconFault_FAULT_ID_NOT_READY_FOR_CMD_FAULT = 6005,
  ReconFault_FAULT_ID_MANUAL_BAD_DETS_UPDATE_FAULT = 6006,
  ReconFault_FAULT_ID_BUFFER_POOL_FAULT = 6007,
  ReconFault_FAULT_ID_VIEW_SUBSCRIBE_TIMEOUT = 6008,
  ReconFault_FAULT_ID_RECON_VIEW_BLOCK_FAULT = 6009,
  ReconFault_FAULT_ID_TOO_MANY_BAD_VIEWS = 6010,
  ReconFault_FAULT_ID_DYNAMIC_CAL_FAULT = 6011,
  ReconFault_FAULT_ID_DEFAULT_CAL_FILE_FAULT = 6012,
  ReconFault_FAULT_ID_ReconFault_FAULT_ID_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ReconFault_FAULT_ID_ReconFault_FAULT_ID_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ReconFault_FAULT_ID_IsValid(int value);
const ReconFault_FAULT_ID ReconFault_FAULT_ID_FAULT_ID_MIN = ReconFault_FAULT_ID_NOT_USED;
const ReconFault_FAULT_ID ReconFault_FAULT_ID_FAULT_ID_MAX = ReconFault_FAULT_ID_DEFAULT_CAL_FILE_FAULT;
const int ReconFault_FAULT_ID_FAULT_ID_ARRAYSIZE = ReconFault_FAULT_ID_FAULT_ID_MAX + 1;

const ::google::protobuf::EnumDescriptor* ReconFault_FAULT_ID_descriptor();
inline const ::std::string& ReconFault_FAULT_ID_Name(ReconFault_FAULT_ID value) {
  return ::google::protobuf::internal::NameOfEnum(
    ReconFault_FAULT_ID_descriptor(), value);
}
inline bool ReconFault_FAULT_ID_Parse(
    const ::std::string& name, ReconFault_FAULT_ID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ReconFault_FAULT_ID>(
    ReconFault_FAULT_ID_descriptor(), name, value);
}
enum DrbFault_FAULT_ID {
  DrbFault_FAULT_ID_NOT_USED = 0,
  DrbFault_FAULT_ID_DRB_NOTIFICATION = 7000,
  DrbFault_FAULT_ID_DrbFault_FAULT_ID_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DrbFault_FAULT_ID_DrbFault_FAULT_ID_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DrbFault_FAULT_ID_IsValid(int value);
const DrbFault_FAULT_ID DrbFault_FAULT_ID_FAULT_ID_MIN = DrbFault_FAULT_ID_NOT_USED;
const DrbFault_FAULT_ID DrbFault_FAULT_ID_FAULT_ID_MAX = DrbFault_FAULT_ID_DRB_NOTIFICATION;
const int DrbFault_FAULT_ID_FAULT_ID_ARRAYSIZE = DrbFault_FAULT_ID_FAULT_ID_MAX + 1;

const ::google::protobuf::EnumDescriptor* DrbFault_FAULT_ID_descriptor();
inline const ::std::string& DrbFault_FAULT_ID_Name(DrbFault_FAULT_ID value) {
  return ::google::protobuf::internal::NameOfEnum(
    DrbFault_FAULT_ID_descriptor(), value);
}
inline bool DrbFault_FAULT_ID_Parse(
    const ::std::string& name, DrbFault_FAULT_ID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DrbFault_FAULT_ID>(
    DrbFault_FAULT_ID_descriptor(), name, value);
}
enum NimFault_FAULT_ID {
  NimFault_FAULT_ID_NOT_USED = 0,
  NimFault_FAULT_ID_OVER_MAX_BAG_QUEUE = 8000,
  NimFault_FAULT_ID_INVALID_BAG_DATA = 8001,
  NimFault_FAULT_ID_NETWORK_DISCONNECT = 8002,
  NimFault_FAULT_ID_NimFault_FAULT_ID_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  NimFault_FAULT_ID_NimFault_FAULT_ID_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool NimFault_FAULT_ID_IsValid(int value);
const NimFault_FAULT_ID NimFault_FAULT_ID_FAULT_ID_MIN = NimFault_FAULT_ID_NOT_USED;
const NimFault_FAULT_ID NimFault_FAULT_ID_FAULT_ID_MAX = NimFault_FAULT_ID_NETWORK_DISCONNECT;
const int NimFault_FAULT_ID_FAULT_ID_ARRAYSIZE = NimFault_FAULT_ID_FAULT_ID_MAX + 1;

const ::google::protobuf::EnumDescriptor* NimFault_FAULT_ID_descriptor();
inline const ::std::string& NimFault_FAULT_ID_Name(NimFault_FAULT_ID value) {
  return ::google::protobuf::internal::NameOfEnum(
    NimFault_FAULT_ID_descriptor(), value);
}
inline bool NimFault_FAULT_ID_Parse(
    const ::std::string& name, NimFault_FAULT_ID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NimFault_FAULT_ID>(
    NimFault_FAULT_ID_descriptor(), name, value);
}
enum TempHumidityFault_FAULT_ID {
  TempHumidityFault_FAULT_ID_NOT_USED = 0,
  TempHumidityFault_FAULT_ID_HIGH_TEMPERATURE_WARNING = 9000,
  TempHumidityFault_FAULT_ID_HIGH_TEMPERATURE_FAULT = 9001,
  TempHumidityFault_FAULT_ID_TempHumidityFault_FAULT_ID_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TempHumidityFault_FAULT_ID_TempHumidityFault_FAULT_ID_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TempHumidityFault_FAULT_ID_IsValid(int value);
const TempHumidityFault_FAULT_ID TempHumidityFault_FAULT_ID_FAULT_ID_MIN = TempHumidityFault_FAULT_ID_NOT_USED;
const TempHumidityFault_FAULT_ID TempHumidityFault_FAULT_ID_FAULT_ID_MAX = TempHumidityFault_FAULT_ID_HIGH_TEMPERATURE_FAULT;
const int TempHumidityFault_FAULT_ID_FAULT_ID_ARRAYSIZE = TempHumidityFault_FAULT_ID_FAULT_ID_MAX + 1;

const ::google::protobuf::EnumDescriptor* TempHumidityFault_FAULT_ID_descriptor();
inline const ::std::string& TempHumidityFault_FAULT_ID_Name(TempHumidityFault_FAULT_ID value) {
  return ::google::protobuf::internal::NameOfEnum(
    TempHumidityFault_FAULT_ID_descriptor(), value);
}
inline bool TempHumidityFault_FAULT_ID_Parse(
    const ::std::string& name, TempHumidityFault_FAULT_ID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TempHumidityFault_FAULT_ID>(
    TempHumidityFault_FAULT_ID_descriptor(), name, value);
}
enum BLMFault_FAULT_ID {
  BLMFault_FAULT_ID_NOT_USED = 0,
  BLMFault_FAULT_ID_UNK_BLM_ERROR = 10000,
  BLMFault_FAULT_ID_UNK_BLM_WARNING = 10001,
  BLMFault_FAULT_ID_OUT_OF_BAGS = 10002,
  BLMFault_FAULT_ID_LOW_ON_BAGS = 10003,
  BLMFault_FAULT_ID_BAG_PROCESSING_ERROR = 10004,
  BLMFault_FAULT_ID_BLMFault_FAULT_ID_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  BLMFault_FAULT_ID_BLMFault_FAULT_ID_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool BLMFault_FAULT_ID_IsValid(int value);
const BLMFault_FAULT_ID BLMFault_FAULT_ID_FAULT_ID_MIN = BLMFault_FAULT_ID_NOT_USED;
const BLMFault_FAULT_ID BLMFault_FAULT_ID_FAULT_ID_MAX = BLMFault_FAULT_ID_BAG_PROCESSING_ERROR;
const int BLMFault_FAULT_ID_FAULT_ID_ARRAYSIZE = BLMFault_FAULT_ID_FAULT_ID_MAX + 1;

const ::google::protobuf::EnumDescriptor* BLMFault_FAULT_ID_descriptor();
inline const ::std::string& BLMFault_FAULT_ID_Name(BLMFault_FAULT_ID value) {
  return ::google::protobuf::internal::NameOfEnum(
    BLMFault_FAULT_ID_descriptor(), value);
}
inline bool BLMFault_FAULT_ID_Parse(
    const ::std::string& name, BLMFault_FAULT_ID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BLMFault_FAULT_ID>(
    BLMFault_FAULT_ID_descriptor(), name, value);
}
enum BhsFault_FAULT_ID {
  BhsFault_FAULT_ID_NOT_USED = 0,
  BhsFault_FAULT_ID_MODBUS_PLC_CONNECTION_ERROR = 11000,
  BhsFault_FAULT_ID_MODBUS_ENTRANCE_RFID_CONNECTION_ERROR = 11001,
  BhsFault_FAULT_ID_MODBUS_EXIT_RFID_CONNECTION_ERROR = 11002,
  BhsFault_FAULT_ID_BAG_JAM_ERROR = 11003,
  BhsFault_FAULT_ID_GENERAL_BHS_ERROR = 11004,
  BhsFault_FAULT_ID_BHS_NOT_RTR = 11005,
  BhsFault_FAULT_ID_ENTRANCE_BAG_JAM_ERROR = 11006,
  BhsFault_FAULT_ID_EXIT_BAG_JAM_ERROR = 11007,
  BhsFault_FAULT_ID_TUNNEL_BAG_JAM_ERROR = 11008,
  BhsFault_FAULT_ID_MOTOR_SLAVE_MISSING_ZONE2 = 11100,
  BhsFault_FAULT_ID_SENSOR_SLAVE_MISSING_ZONE2 = 11101,
  BhsFault_FAULT_ID_MOTOR_POWER_FAILURE_ZONE2 = 11102,
  BhsFault_FAULT_ID_SENSOR_POWER_FAILURE_ZONE2 = 11103,
  BhsFault_FAULT_ID_MOTOR_UNDER_VOLTAGE_ZONE2 = 11104,
  BhsFault_FAULT_ID_MOTOR_OVER_CURRENT_ZONE2 = 11105,
  BhsFault_FAULT_ID_MOTOR_SLAVE_MISSING_ZONE3 = 11106,
  BhsFault_FAULT_ID_SENSOR_SLAVE_MISSING_ZONE3 = 11107,
  BhsFault_FAULT_ID_MOTOR_POWER_FAILURE_ZONE3 = 11108,
  BhsFault_FAULT_ID_SENSOR_POWER_FAILURE_ZONE3 = 11109,
  BhsFault_FAULT_ID_MOTOR_UNDER_VOLTAGE_ZONE3 = 11110,
  BhsFault_FAULT_ID_MOTOR_OVER_CURRENT_ZONE3 = 11111,
  BhsFault_FAULT_ID_MOTOR_SLAVE_MISSING_ZONE3B = 11112,
  BhsFault_FAULT_ID_SENSOR_SLAVE_MISSING_ZONE3B = 11113,
  BhsFault_FAULT_ID_MOTOR_POWER_FAILURE_ZONE3B = 11114,
  BhsFault_FAULT_ID_SENSOR_POWER_FAILURE_ZONE3B = 11115,
  BhsFault_FAULT_ID_MOTOR_UNDER_VOLTAGE_ZONE3B = 11116,
  BhsFault_FAULT_ID_MOTOR_OVER_CURRENT_ZONE3B = 11117,
  BhsFault_FAULT_ID_MOTOR_SLAVE_MISSING_ZONE4 = 11118,
  BhsFault_FAULT_ID_SENSOR_SLAVE_MISSING_ZONE4 = 11119,
  BhsFault_FAULT_ID_MOTOR_POWER_FAILURE_ZONE4 = 11120,
  BhsFault_FAULT_ID_SENSOR_POWER_FAILURE_ZONE4 = 11121,
  BhsFault_FAULT_ID_MOTOR_UNDER_VOLTAGE_ZONE4 = 11122,
  BhsFault_FAULT_ID_MOTOR_OVER_CURRENT_ZONE4 = 11123,
  BhsFault_FAULT_ID_MOTOR_SLAVE_MISSING_ZONE7 = 11124,
  BhsFault_FAULT_ID_SENSOR_SLAVE_MISSING_ZONE7 = 11125,
  BhsFault_FAULT_ID_MOTOR_POWER_FAILURE_ZONE7 = 11126,
  BhsFault_FAULT_ID_SENSOR_POWER_FAILURE_ZONE7 = 11127,
  BhsFault_FAULT_ID_MOTOR_UNDER_VOLTAGE_ZONE7 = 11128,
  BhsFault_FAULT_ID_MOTOR_OVER_CURRENT_ZONE7 = 11129,
  BhsFault_FAULT_ID_MOTOR_SLAVE_MISSING_ZONE8 = 11130,
  BhsFault_FAULT_ID_SENSOR_SLAVE_MISSING_ZONE8 = 11131,
  BhsFault_FAULT_ID_MOTOR_POWER_FAILURE_ZONE8 = 11132,
  BhsFault_FAULT_ID_SENSOR_POWER_FAILURE_ZONE8 = 11133,
  BhsFault_FAULT_ID_MOTOR_UNDER_VOLTAGE_ZONE8 = 11134,
  BhsFault_FAULT_ID_MOTOR_OVER_CURRENT_ZONE8 = 11135,
  BhsFault_FAULT_ID_DIVERTER_SLAVE_MISSING_ZONE5 = 11136,
  BhsFault_FAULT_ID_ROLLER_SLAVE_MISSING_ZONE5 = 11137,
  BhsFault_FAULT_ID_ROLLER_AT_FAULT_ZONE5 = 11138,
  BhsFault_FAULT_ID_DIVERTER_AT_FAULT_ZONE5 = 11139,
  BhsFault_FAULT_ID_ROLLER_UNDER_VOLTAGE_ZONE5 = 11140,
  BhsFault_FAULT_ID_ROLLER_OVER_CURRENT_ZONE5 = 11141,
  BhsFault_FAULT_ID_DIVERTER_UNDER_VOLTAGE_ZONE5 = 11142,
  BhsFault_FAULT_ID_DIVERTER_OVER_CURRENT_ZONE5 = 11143,
  BhsFault_FAULT_ID_DIVERTER_SLAVE_MISSING_ZONE6 = 11144,
  BhsFault_FAULT_ID_ROLLER_SLAVE_MISSING_ZONE6 = 11145,
  BhsFault_FAULT_ID_ROLLER_AT_FAULT_ZONE6 = 11146,
  BhsFault_FAULT_ID_DIVERTER_AT_FAULT_ZONE6 = 11147,
  BhsFault_FAULT_ID_ROLLER_UNDER_VOLTAGE_ZONE6 = 11148,
  BhsFault_FAULT_ID_ROLLER_OVER_CURRENT_ZONE6 = 11149,
  BhsFault_FAULT_ID_DIVERTER_UNDER_VOLTAGE_ZONE6 = 11150,
  BhsFault_FAULT_ID_DIVERTER_OVER_CURRENT_ZONE6 = 11151,
  BhsFault_FAULT_ID_ASI_TERMINAL_MISSING = 11152,
  BhsFault_FAULT_ID_ASI_MODULE_ERROR = 11153,
  BhsFault_FAULT_ID_DIVERTER_DIRECTION_CONFIG_ERROR = 11154,
  BhsFault_FAULT_ID_BhsFault_FAULT_ID_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  BhsFault_FAULT_ID_BhsFault_FAULT_ID_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool BhsFault_FAULT_ID_IsValid(int value);
const BhsFault_FAULT_ID BhsFault_FAULT_ID_FAULT_ID_MIN = BhsFault_FAULT_ID_NOT_USED;
const BhsFault_FAULT_ID BhsFault_FAULT_ID_FAULT_ID_MAX = BhsFault_FAULT_ID_DIVERTER_DIRECTION_CONFIG_ERROR;
const int BhsFault_FAULT_ID_FAULT_ID_ARRAYSIZE = BhsFault_FAULT_ID_FAULT_ID_MAX + 1;

const ::google::protobuf::EnumDescriptor* BhsFault_FAULT_ID_descriptor();
inline const ::std::string& BhsFault_FAULT_ID_Name(BhsFault_FAULT_ID value) {
  return ::google::protobuf::internal::NameOfEnum(
    BhsFault_FAULT_ID_descriptor(), value);
}
inline bool BhsFault_FAULT_ID_Parse(
    const ::std::string& name, BhsFault_FAULT_ID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BhsFault_FAULT_ID>(
    BhsFault_FAULT_ID_descriptor(), name, value);
}
enum CommFault_FAULT_ID {
  CommFault_FAULT_ID_NOT_USED = 0,
  CommFault_FAULT_ID_SYSTEM_COMM_ERROR = 12000,
  CommFault_FAULT_ID_NETWORK_OFFLINE = 120001,
  CommFault_FAULT_ID_BHS_OFFLINE = 12002,
  CommFault_FAULT_ID_SCC_OFFLINE = 12003,
  CommFault_FAULT_ID_UPS_OFFLINE = 12004,
  CommFault_FAULT_ID_DRB_OFFLINE = 12005,
  CommFault_FAULT_ID_SAFETY_IO_OFFLINE = 12006,
  CommFault_FAULT_ID_RCB_OFFLINE = 12007,
  CommFault_FAULT_ID_XRAY_OFFLINE = 12008,
  CommFault_FAULT_ID_SERIAL_SERVER_1_OFFLINE = 12009,
  CommFault_FAULT_ID_SERIAL_SERVER_2_OFFLINE = 12010,
  CommFault_FAULT_ID_GANTRY_OFFLINE = 12011,
  CommFault_FAULT_ID_CONVEYOR_OFFLINE = 12012,
  CommFault_FAULT_ID_TEMP_HUMIDITY_SENSOR_OFFLINE = 12013,
  CommFault_FAULT_ID_POWERLINK_OFFLINE = 12014,
  CommFault_FAULT_ID_DCB_1_OFFLINE = 12015,
  CommFault_FAULT_ID_DCB_2_OFFLINE = 12016,
  CommFault_FAULT_ID_DCB_3_OFFLINE = 12017,
  CommFault_FAULT_ID_DCB_4_OFFLINE = 12018,
  CommFault_FAULT_ID_DCB_5_OFFLINE = 12019,
  CommFault_FAULT_ID_POWER_METER_OFFLINE = 12020,
  CommFault_FAULT_ID_CommFault_FAULT_ID_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  CommFault_FAULT_ID_CommFault_FAULT_ID_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool CommFault_FAULT_ID_IsValid(int value);
const CommFault_FAULT_ID CommFault_FAULT_ID_FAULT_ID_MIN = CommFault_FAULT_ID_NOT_USED;
const CommFault_FAULT_ID CommFault_FAULT_ID_FAULT_ID_MAX = CommFault_FAULT_ID_NETWORK_OFFLINE;
const int CommFault_FAULT_ID_FAULT_ID_ARRAYSIZE = CommFault_FAULT_ID_FAULT_ID_MAX + 1;

const ::google::protobuf::EnumDescriptor* CommFault_FAULT_ID_descriptor();
inline const ::std::string& CommFault_FAULT_ID_Name(CommFault_FAULT_ID value) {
  return ::google::protobuf::internal::NameOfEnum(
    CommFault_FAULT_ID_descriptor(), value);
}
inline bool CommFault_FAULT_ID_Parse(
    const ::std::string& name, CommFault_FAULT_ID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CommFault_FAULT_ID>(
    CommFault_FAULT_ID_descriptor(), name, value);
}
enum UpsFault_FAULT_ID {
  UpsFault_FAULT_ID_NOT_USED = 0,
  UpsFault_FAULT_ID_UPS_BAD_COMM = 13000,
  UpsFault_FAULT_ID_UPS_NO_COMM = 13001,
  UpsFault_FAULT_ID_UPS_ON_BATTERY_POWER = 13002,
  UpsFault_FAULT_ID_UPS_LOW_BATTERY = 13003,
  UpsFault_FAULT_ID_UPSMON_NO_PARENT = 13004,
  UpsFault_FAULT_ID_UPS_REPLACE_BATTERY = 13005,
  UpsFault_FAULT_ID_UpsFault_FAULT_ID_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  UpsFault_FAULT_ID_UpsFault_FAULT_ID_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool UpsFault_FAULT_ID_IsValid(int value);
const UpsFault_FAULT_ID UpsFault_FAULT_ID_FAULT_ID_MIN = UpsFault_FAULT_ID_NOT_USED;
const UpsFault_FAULT_ID UpsFault_FAULT_ID_FAULT_ID_MAX = UpsFault_FAULT_ID_UPS_REPLACE_BATTERY;
const int UpsFault_FAULT_ID_FAULT_ID_ARRAYSIZE = UpsFault_FAULT_ID_FAULT_ID_MAX + 1;

const ::google::protobuf::EnumDescriptor* UpsFault_FAULT_ID_descriptor();
inline const ::std::string& UpsFault_FAULT_ID_Name(UpsFault_FAULT_ID value) {
  return ::google::protobuf::internal::NameOfEnum(
    UpsFault_FAULT_ID_descriptor(), value);
}
inline bool UpsFault_FAULT_ID_Parse(
    const ::std::string& name, UpsFault_FAULT_ID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UpsFault_FAULT_ID>(
    UpsFault_FAULT_ID_descriptor(), name, value);
}
enum ComputerFault_FAULT_ID {
  ComputerFault_FAULT_ID_NOT_USED = 0,
  ComputerFault_FAULT_ID_COMPUTER_DRIVE_FULL = 14000,
  ComputerFault_FAULT_ID_COMPUTER_RAID_NOT_MOUNTED = 14001,
  ComputerFault_FAULT_ID_COMPUTER_NETWORK_LOW_SPEED = 14002,
  ComputerFault_FAULT_ID_ComputerFault_FAULT_ID_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ComputerFault_FAULT_ID_ComputerFault_FAULT_ID_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ComputerFault_FAULT_ID_IsValid(int value);
const ComputerFault_FAULT_ID ComputerFault_FAULT_ID_FAULT_ID_MIN = ComputerFault_FAULT_ID_NOT_USED;
const ComputerFault_FAULT_ID ComputerFault_FAULT_ID_FAULT_ID_MAX = ComputerFault_FAULT_ID_COMPUTER_NETWORK_LOW_SPEED;
const int ComputerFault_FAULT_ID_FAULT_ID_ARRAYSIZE = ComputerFault_FAULT_ID_FAULT_ID_MAX + 1;

const ::google::protobuf::EnumDescriptor* ComputerFault_FAULT_ID_descriptor();
inline const ::std::string& ComputerFault_FAULT_ID_Name(ComputerFault_FAULT_ID value) {
  return ::google::protobuf::internal::NameOfEnum(
    ComputerFault_FAULT_ID_descriptor(), value);
}
inline bool ComputerFault_FAULT_ID_Parse(
    const ::std::string& name, ComputerFault_FAULT_ID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ComputerFault_FAULT_ID>(
    ComputerFault_FAULT_ID_descriptor(), name, value);
}
enum InterlockFault_FAULT_ID {
  InterlockFault_FAULT_ID_NOT_USED = 0,
  InterlockFault_FAULT_ID_CANNOT_REVERSE_CONVEYOR_IN_SCAN_MODE = 15000,
  InterlockFault_FAULT_ID_XRAY_CONTROL_MOTION_KEYSWITCH_INTERLOCK_VIOLATION = 15001,
  InterlockFault_FAULT_ID_ACCESS_PANEL_INTERLOCK_VIOLATION = 15002,
  InterlockFault_FAULT_ID_GANTRY_NOT_AT_SPEED_NOR_AT_HOME_INTERLOCK_VIOLATION = 15003,
  InterlockFault_FAULT_ID_CANNOT_MAXIMIXE_XRAYS_NOT_ON = 15004,
  InterlockFault_FAULT_ID_OPERATOR_NOT_PRESENT = 15005,
  InterlockFault_FAULT_ID_InterlockFault_FAULT_ID_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  InterlockFault_FAULT_ID_InterlockFault_FAULT_ID_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool InterlockFault_FAULT_ID_IsValid(int value);
const InterlockFault_FAULT_ID InterlockFault_FAULT_ID_FAULT_ID_MIN = InterlockFault_FAULT_ID_NOT_USED;
const InterlockFault_FAULT_ID InterlockFault_FAULT_ID_FAULT_ID_MAX = InterlockFault_FAULT_ID_OPERATOR_NOT_PRESENT;
const int InterlockFault_FAULT_ID_FAULT_ID_ARRAYSIZE = InterlockFault_FAULT_ID_FAULT_ID_MAX + 1;

const ::google::protobuf::EnumDescriptor* InterlockFault_FAULT_ID_descriptor();
inline const ::std::string& InterlockFault_FAULT_ID_Name(InterlockFault_FAULT_ID value) {
  return ::google::protobuf::internal::NameOfEnum(
    InterlockFault_FAULT_ID_descriptor(), value);
}
inline bool InterlockFault_FAULT_ID_Parse(
    const ::std::string& name, InterlockFault_FAULT_ID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<InterlockFault_FAULT_ID>(
    InterlockFault_FAULT_ID_descriptor(), name, value);
}
enum Fault_FAULT_ID {
  Fault_FAULT_ID_NOT_USED = 0,
  Fault_FAULT_ID_Fault_FAULT_ID_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Fault_FAULT_ID_Fault_FAULT_ID_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Fault_FAULT_ID_IsValid(int value);
const Fault_FAULT_ID Fault_FAULT_ID_FAULT_ID_MIN = Fault_FAULT_ID_NOT_USED;
const Fault_FAULT_ID Fault_FAULT_ID_FAULT_ID_MAX = Fault_FAULT_ID_NOT_USED;
const int Fault_FAULT_ID_FAULT_ID_ARRAYSIZE = Fault_FAULT_ID_FAULT_ID_MAX + 1;

const ::google::protobuf::EnumDescriptor* Fault_FAULT_ID_descriptor();
inline const ::std::string& Fault_FAULT_ID_Name(Fault_FAULT_ID value) {
  return ::google::protobuf::internal::NameOfEnum(
    Fault_FAULT_ID_descriptor(), value);
}
inline bool Fault_FAULT_ID_Parse(
    const ::std::string& name, Fault_FAULT_ID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Fault_FAULT_ID>(
    Fault_FAULT_ID_descriptor(), name, value);
}
enum FaultFilterCondition_CONDITION_ID {
  FaultFilterCondition_CONDITION_ID_NOT_USED = 0,
  FaultFilterCondition_CONDITION_ID_ESTOP = 1,
  FaultFilterCondition_CONDITION_ID_POWERLINK_DISABLED = 2,
  FaultFilterCondition_CONDITION_ID_XRAY_MOTOR_POWER_KEY_SWITCH_DISABLED = 4,
  FaultFilterCondition_CONDITION_ID_DOOR_INTERLOCK_VIOLATION = 8,
  FaultFilterCondition_CONDITION_ID_RAID_FAULT = 16,
  FaultFilterCondition_CONDITION_ID_ON_BATTERY_POWER = 32,
  FaultFilterCondition_CONDITION_ID_FaultFilterCondition_CONDITION_ID_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  FaultFilterCondition_CONDITION_ID_FaultFilterCondition_CONDITION_ID_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool FaultFilterCondition_CONDITION_ID_IsValid(int value);
const FaultFilterCondition_CONDITION_ID FaultFilterCondition_CONDITION_ID_CONDITION_ID_MIN = FaultFilterCondition_CONDITION_ID_NOT_USED;
const FaultFilterCondition_CONDITION_ID FaultFilterCondition_CONDITION_ID_CONDITION_ID_MAX = FaultFilterCondition_CONDITION_ID_ON_BATTERY_POWER;
const int FaultFilterCondition_CONDITION_ID_CONDITION_ID_ARRAYSIZE = FaultFilterCondition_CONDITION_ID_CONDITION_ID_MAX + 1;

const ::google::protobuf::EnumDescriptor* FaultFilterCondition_CONDITION_ID_descriptor();
inline const ::std::string& FaultFilterCondition_CONDITION_ID_Name(FaultFilterCondition_CONDITION_ID value) {
  return ::google::protobuf::internal::NameOfEnum(
    FaultFilterCondition_CONDITION_ID_descriptor(), value);
}
inline bool FaultFilterCondition_CONDITION_ID_Parse(
    const ::std::string& name, FaultFilterCondition_CONDITION_ID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FaultFilterCondition_CONDITION_ID>(
    FaultFilterCondition_CONDITION_ID_descriptor(), name, value);
}
// ===================================================================

class FaultData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:analogic.ancp00.FaultData) */ {
 public:
  FaultData();
  virtual ~FaultData();

  FaultData(const FaultData& from);

  inline FaultData& operator=(const FaultData& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FaultData& default_instance();

  void Swap(FaultData* other);

  // implements Message ----------------------------------------------

  inline FaultData* New() const { return New(NULL); }

  FaultData* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FaultData& from);
  void MergeFrom(const FaultData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FaultData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef FaultData_FAULT_LEVEL FAULT_LEVEL;
  static const FAULT_LEVEL FAULT_NOTICE =
    FaultData_FAULT_LEVEL_FAULT_NOTICE;
  static const FAULT_LEVEL FAULT_WARNING =
    FaultData_FAULT_LEVEL_FAULT_WARNING;
  static const FAULT_LEVEL FAULT_ERROR =
    FaultData_FAULT_LEVEL_FAULT_ERROR;
  static const FAULT_LEVEL FAULT_FATAL =
    FaultData_FAULT_LEVEL_FAULT_FATAL;
  static const FAULT_LEVEL FAULT_SHUTDOWN =
    FaultData_FAULT_LEVEL_FAULT_SHUTDOWN;
  static inline bool FAULT_LEVEL_IsValid(int value) {
    return FaultData_FAULT_LEVEL_IsValid(value);
  }
  static const FAULT_LEVEL FAULT_LEVEL_MIN =
    FaultData_FAULT_LEVEL_FAULT_LEVEL_MIN;
  static const FAULT_LEVEL FAULT_LEVEL_MAX =
    FaultData_FAULT_LEVEL_FAULT_LEVEL_MAX;
  static const int FAULT_LEVEL_ARRAYSIZE =
    FaultData_FAULT_LEVEL_FAULT_LEVEL_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FAULT_LEVEL_descriptor() {
    return FaultData_FAULT_LEVEL_descriptor();
  }
  static inline const ::std::string& FAULT_LEVEL_Name(FAULT_LEVEL value) {
    return FaultData_FAULT_LEVEL_Name(value);
  }
  static inline bool FAULT_LEVEL_Parse(const ::std::string& name,
      FAULT_LEVEL* value) {
    return FaultData_FAULT_LEVEL_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .analogic.ancp00.SUBSYSTEM_ID subsys_id = 1;
  void clear_subsys_id();
  static const int kSubsysIdFieldNumber = 1;
  ::analogic::ancp00::SUBSYSTEM_ID subsys_id() const;
  void set_subsys_id(::analogic::ancp00::SUBSYSTEM_ID value);

  // optional .analogic.ancp00.FaultData.FAULT_LEVEL level = 2;
  void clear_level();
  static const int kLevelFieldNumber = 2;
  ::analogic::ancp00::FaultData_FAULT_LEVEL level() const;
  void set_level(::analogic::ancp00::FaultData_FAULT_LEVEL value);

  // optional uint64 id = 3;
  void clear_id();
  static const int kIdFieldNumber = 3;
  ::google::protobuf::uint64 id() const;
  void set_id(::google::protobuf::uint64 value);

  // optional uint64 epoch_time_ms = 4;
  void clear_epoch_time_ms();
  static const int kEpochTimeMsFieldNumber = 4;
  ::google::protobuf::uint64 epoch_time_ms() const;
  void set_epoch_time_ms(::google::protobuf::uint64 value);

  // optional string local_time_str = 5;
  void clear_local_time_str();
  static const int kLocalTimeStrFieldNumber = 5;
  const ::std::string& local_time_str() const;
  void set_local_time_str(const ::std::string& value);
  void set_local_time_str(const char* value);
  void set_local_time_str(const char* value, size_t size);
  ::std::string* mutable_local_time_str();
  ::std::string* release_local_time_str();
  void set_allocated_local_time_str(::std::string* local_time_str);

  // optional string text = 6;
  void clear_text();
  static const int kTextFieldNumber = 6;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // optional string key = 7;
  void clear_key();
  static const int kKeyFieldNumber = 7;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // optional string obj_key = 50;
  void clear_obj_key();
  static const int kObjKeyFieldNumber = 50;
  const ::std::string& obj_key() const;
  void set_obj_key(const ::std::string& value);
  void set_obj_key(const char* value);
  void set_obj_key(const char* value, size_t size);
  ::std::string* mutable_obj_key();
  ::std::string* release_obj_key();
  void set_allocated_obj_key(::std::string* obj_key);

  // optional string obj_data = 51;
  void clear_obj_data();
  static const int kObjDataFieldNumber = 51;
  const ::std::string& obj_data() const;
  void set_obj_data(const ::std::string& value);
  void set_obj_data(const char* value);
  void set_obj_data(const char* value, size_t size);
  ::std::string* mutable_obj_data();
  ::std::string* release_obj_data();
  void set_allocated_obj_data(::std::string* obj_data);

  // @@protoc_insertion_point(class_scope:analogic.ancp00.FaultData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  int subsys_id_;
  int level_;
  ::google::protobuf::uint64 id_;
  ::google::protobuf::uint64 epoch_time_ms_;
  ::google::protobuf::internal::ArenaStringPtr local_time_str_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr obj_key_;
  ::google::protobuf::internal::ArenaStringPtr obj_data_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_proto_2fFault_2eproto();
  friend void protobuf_AssignDesc_proto_2fFault_2eproto();
  friend void protobuf_ShutdownFile_proto_2fFault_2eproto();

  void InitAsDefaultInstance();
  static FaultData* default_instance_;
};
// -------------------------------------------------------------------

class GenericFault : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:analogic.ancp00.GenericFault) */ {
 public:
  GenericFault();
  virtual ~GenericFault();

  GenericFault(const GenericFault& from);

  inline GenericFault& operator=(const GenericFault& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GenericFault& default_instance();

  void Swap(GenericFault* other);

  // implements Message ----------------------------------------------

  inline GenericFault* New() const { return New(NULL); }

  GenericFault* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GenericFault& from);
  void MergeFrom(const GenericFault& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GenericFault* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef GenericFault_FAULT_ID FAULT_ID;
  static const FAULT_ID NOT_USED =
    GenericFault_FAULT_ID_NOT_USED;
  static const FAULT_ID MSG_NOT_RECEIVED =
    GenericFault_FAULT_ID_MSG_NOT_RECEIVED;
  static const FAULT_ID MSG_NOT_SENT =
    GenericFault_FAULT_ID_MSG_NOT_SENT;
  static const FAULT_ID MSG_REPLY_ERROR =
    GenericFault_FAULT_ID_MSG_REPLY_ERROR;
  static const FAULT_ID MSG_REPLY_UNKNOWN =
    GenericFault_FAULT_ID_MSG_REPLY_UNKNOWN;
  static const FAULT_ID DEADLINE_REACHED =
    GenericFault_FAULT_ID_DEADLINE_REACHED;
  static const FAULT_ID EVENT_PUBLISH_FAULT =
    GenericFault_FAULT_ID_EVENT_PUBLISH_FAULT;
  static const FAULT_ID PERSIST_DATA_FAULT =
    GenericFault_FAULT_ID_PERSIST_DATA_FAULT;
  static const FAULT_ID RETRIEVE_DATA_FAULT =
    GenericFault_FAULT_ID_RETRIEVE_DATA_FAULT;
  static const FAULT_ID INTERLOCK_VIOLATION =
    GenericFault_FAULT_ID_INTERLOCK_VIOLATION;
  static const FAULT_ID UNKNOWN_COMMAND_FAULT =
    GenericFault_FAULT_ID_UNKNOWN_COMMAND_FAULT;
  static const FAULT_ID COMMAND_FAILURE =
    GenericFault_FAULT_ID_COMMAND_FAILURE;
  static const FAULT_ID RPC_START_FAILURE =
    GenericFault_FAULT_ID_RPC_START_FAILURE;
  static const FAULT_ID RPC_CANNOT_START_FAILURE =
    GenericFault_FAULT_ID_RPC_CANNOT_START_FAILURE;
  static const FAULT_ID CONTROL_SEQUENCE_ERROR =
    GenericFault_FAULT_ID_CONTROL_SEQUENCE_ERROR;
  static const FAULT_ID CONTROL_SEQUENCE_TIMEOUT =
    GenericFault_FAULT_ID_CONTROL_SEQUENCE_TIMEOUT;
  static const FAULT_ID PROCESS_EXITED =
    GenericFault_FAULT_ID_PROCESS_EXITED;
  static const FAULT_ID ESTOP_PRESSED =
    GenericFault_FAULT_ID_ESTOP_PRESSED;
  static const FAULT_ID SYSTEM_COMM_ERROR =
    GenericFault_FAULT_ID_SYSTEM_COMM_ERROR;
  static const FAULT_ID ESTOP_RELEASED =
    GenericFault_FAULT_ID_ESTOP_RELEASED;
  static const FAULT_ID HARD_DRIVE_SPACE_EXCEEDED =
    GenericFault_FAULT_ID_HARD_DRIVE_SPACE_EXCEEDED;
  static const FAULT_ID RAID_NOT_FOUND =
    GenericFault_FAULT_ID_RAID_NOT_FOUND;
  static const FAULT_ID NETWORK_SPEED_THROTTLED =
    GenericFault_FAULT_ID_NETWORK_SPEED_THROTTLED;
  static const FAULT_ID SOFTWARE_INTRUSION_DETECTED =
    GenericFault_FAULT_ID_SOFTWARE_INTRUSION_DETECTED;
  static inline bool FAULT_ID_IsValid(int value) {
    return GenericFault_FAULT_ID_IsValid(value);
  }
  static const FAULT_ID FAULT_ID_MIN =
    GenericFault_FAULT_ID_FAULT_ID_MIN;
  static const FAULT_ID FAULT_ID_MAX =
    GenericFault_FAULT_ID_FAULT_ID_MAX;
  static const int FAULT_ID_ARRAYSIZE =
    GenericFault_FAULT_ID_FAULT_ID_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FAULT_ID_descriptor() {
    return GenericFault_FAULT_ID_descriptor();
  }
  static inline const ::std::string& FAULT_ID_Name(FAULT_ID value) {
    return GenericFault_FAULT_ID_Name(value);
  }
  static inline bool FAULT_ID_Parse(const ::std::string& name,
      FAULT_ID* value) {
    return GenericFault_FAULT_ID_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:analogic.ancp00.GenericFault)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_proto_2fFault_2eproto();
  friend void protobuf_AssignDesc_proto_2fFault_2eproto();
  friend void protobuf_ShutdownFile_proto_2fFault_2eproto();

  void InitAsDefaultInstance();
  static GenericFault* default_instance_;
};
// -------------------------------------------------------------------

class XrayControlFault : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:analogic.ancp00.XrayControlFault) */ {
 public:
  XrayControlFault();
  virtual ~XrayControlFault();

  XrayControlFault(const XrayControlFault& from);

  inline XrayControlFault& operator=(const XrayControlFault& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const XrayControlFault& default_instance();

  void Swap(XrayControlFault* other);

  // implements Message ----------------------------------------------

  inline XrayControlFault* New() const { return New(NULL); }

  XrayControlFault* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const XrayControlFault& from);
  void MergeFrom(const XrayControlFault& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(XrayControlFault* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef XrayControlFault_FAULT_ID FAULT_ID;
  static const FAULT_ID NOT_USED =
    XrayControlFault_FAULT_ID_NOT_USED;
  static const FAULT_ID ANONYMOUS_IO_FAULT =
    XrayControlFault_FAULT_ID_ANONYMOUS_IO_FAULT;
  static const FAULT_ID RCB_FAULT =
    XrayControlFault_FAULT_ID_RCB_FAULT;
  static const FAULT_ID DISK_SPEED_FAULT =
    XrayControlFault_FAULT_ID_DISK_SPEED_FAULT;
  static const FAULT_ID XRAY_VOLTAGE_FAULT =
    XrayControlFault_FAULT_ID_XRAY_VOLTAGE_FAULT;
  static const FAULT_ID XRAY_CURRENT_FAULT =
    XrayControlFault_FAULT_ID_XRAY_CURRENT_FAULT;
  static const FAULT_ID POWERLINK_COMMAND_FAULT =
    XrayControlFault_FAULT_ID_POWERLINK_COMMAND_FAULT;
  static const FAULT_ID XRAY_CMD_BITS_MISMATCH_FAULT =
    XrayControlFault_FAULT_ID_XRAY_CMD_BITS_MISMATCH_FAULT;
  static const FAULT_ID XRAY_ARC_FAULT =
    XrayControlFault_FAULT_ID_XRAY_ARC_FAULT;
  static const FAULT_ID XRAY_ANODE_OVER_KV_FAULT =
    XrayControlFault_FAULT_ID_XRAY_ANODE_OVER_KV_FAULT;
  static const FAULT_ID XRAY_CATHODE_OVER_KV_FAULT =
    XrayControlFault_FAULT_ID_XRAY_CATHODE_OVER_KV_FAULT;
  static const FAULT_ID INTERLOCK_OPEN_FAULT =
    XrayControlFault_FAULT_ID_INTERLOCK_OPEN_FAULT;
  static const FAULT_ID OVERTEMP_FAULT =
    XrayControlFault_FAULT_ID_OVERTEMP_FAULT;
  static const FAULT_ID OVER_CURRENT_FAULT =
    XrayControlFault_FAULT_ID_OVER_CURRENT_FAULT;
  static const FAULT_ID OVER_VOLTAGE_FAULT =
    XrayControlFault_FAULT_ID_OVER_VOLTAGE_FAULT;
  static const FAULT_ID POWER_LIMIT_FAULT =
    XrayControlFault_FAULT_ID_POWER_LIMIT_FAULT;
  static const FAULT_ID REGULATION_FAULT =
    XrayControlFault_FAULT_ID_REGULATION_FAULT;
  static inline bool FAULT_ID_IsValid(int value) {
    return XrayControlFault_FAULT_ID_IsValid(value);
  }
  static const FAULT_ID FAULT_ID_MIN =
    XrayControlFault_FAULT_ID_FAULT_ID_MIN;
  static const FAULT_ID FAULT_ID_MAX =
    XrayControlFault_FAULT_ID_FAULT_ID_MAX;
  static const int FAULT_ID_ARRAYSIZE =
    XrayControlFault_FAULT_ID_FAULT_ID_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FAULT_ID_descriptor() {
    return XrayControlFault_FAULT_ID_descriptor();
  }
  static inline const ::std::string& FAULT_ID_Name(FAULT_ID value) {
    return XrayControlFault_FAULT_ID_Name(value);
  }
  static inline bool FAULT_ID_Parse(const ::std::string& name,
      FAULT_ID* value) {
    return XrayControlFault_FAULT_ID_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:analogic.ancp00.XrayControlFault)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_proto_2fFault_2eproto();
  friend void protobuf_AssignDesc_proto_2fFault_2eproto();
  friend void protobuf_ShutdownFile_proto_2fFault_2eproto();

  void InitAsDefaultInstance();
  static XrayControlFault* default_instance_;
};
// -------------------------------------------------------------------

class MotorControlFault : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:analogic.ancp00.MotorControlFault) */ {
 public:
  MotorControlFault();
  virtual ~MotorControlFault();

  MotorControlFault(const MotorControlFault& from);

  inline MotorControlFault& operator=(const MotorControlFault& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MotorControlFault& default_instance();

  void Swap(MotorControlFault* other);

  // implements Message ----------------------------------------------

  inline MotorControlFault* New() const { return New(NULL); }

  MotorControlFault* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MotorControlFault& from);
  void MergeFrom(const MotorControlFault& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MotorControlFault* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef MotorControlFault_FAULT_ID FAULT_ID;
  static const FAULT_ID NOT_USED =
    MotorControlFault_FAULT_ID_NOT_USED;
  static const FAULT_ID ANONYMOUS_IO_FAULT =
    MotorControlFault_FAULT_ID_ANONYMOUS_IO_FAULT;
  static const FAULT_ID SAFETY_IO_FAULT =
    MotorControlFault_FAULT_ID_SAFETY_IO_FAULT;
  static const FAULT_ID MOTOR_DRIVE_FAULT =
    MotorControlFault_FAULT_ID_MOTOR_DRIVE_FAULT;
  static inline bool FAULT_ID_IsValid(int value) {
    return MotorControlFault_FAULT_ID_IsValid(value);
  }
  static const FAULT_ID FAULT_ID_MIN =
    MotorControlFault_FAULT_ID_FAULT_ID_MIN;
  static const FAULT_ID FAULT_ID_MAX =
    MotorControlFault_FAULT_ID_FAULT_ID_MAX;
  static const int FAULT_ID_ARRAYSIZE =
    MotorControlFault_FAULT_ID_FAULT_ID_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FAULT_ID_descriptor() {
    return MotorControlFault_FAULT_ID_descriptor();
  }
  static inline const ::std::string& FAULT_ID_Name(FAULT_ID value) {
    return MotorControlFault_FAULT_ID_Name(value);
  }
  static inline bool FAULT_ID_Parse(const ::std::string& name,
      FAULT_ID* value) {
    return MotorControlFault_FAULT_ID_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:analogic.ancp00.MotorControlFault)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_proto_2fFault_2eproto();
  friend void protobuf_AssignDesc_proto_2fFault_2eproto();
  friend void protobuf_ShutdownFile_proto_2fFault_2eproto();

  void InitAsDefaultInstance();
  static MotorControlFault* default_instance_;
};
// -------------------------------------------------------------------

class PowerlinkFault : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:analogic.ancp00.PowerlinkFault) */ {
 public:
  PowerlinkFault();
  virtual ~PowerlinkFault();

  PowerlinkFault(const PowerlinkFault& from);

  inline PowerlinkFault& operator=(const PowerlinkFault& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PowerlinkFault& default_instance();

  void Swap(PowerlinkFault* other);

  // implements Message ----------------------------------------------

  inline PowerlinkFault* New() const { return New(NULL); }

  PowerlinkFault* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PowerlinkFault& from);
  void MergeFrom(const PowerlinkFault& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PowerlinkFault* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef PowerlinkFault_FAULT_ID FAULT_ID;
  static const FAULT_ID NOT_USED =
    PowerlinkFault_FAULT_ID_NOT_USED;
  static const FAULT_ID STATUS_FAULT =
    PowerlinkFault_FAULT_ID_STATUS_FAULT;
  static const FAULT_ID POWERLINK_DISABLED =
    PowerlinkFault_FAULT_ID_POWERLINK_DISABLED;
  static inline bool FAULT_ID_IsValid(int value) {
    return PowerlinkFault_FAULT_ID_IsValid(value);
  }
  static const FAULT_ID FAULT_ID_MIN =
    PowerlinkFault_FAULT_ID_FAULT_ID_MIN;
  static const FAULT_ID FAULT_ID_MAX =
    PowerlinkFault_FAULT_ID_FAULT_ID_MAX;
  static const int FAULT_ID_ARRAYSIZE =
    PowerlinkFault_FAULT_ID_FAULT_ID_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FAULT_ID_descriptor() {
    return PowerlinkFault_FAULT_ID_descriptor();
  }
  static inline const ::std::string& FAULT_ID_Name(FAULT_ID value) {
    return PowerlinkFault_FAULT_ID_Name(value);
  }
  static inline bool FAULT_ID_Parse(const ::std::string& name,
      FAULT_ID* value) {
    return PowerlinkFault_FAULT_ID_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:analogic.ancp00.PowerlinkFault)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_proto_2fFault_2eproto();
  friend void protobuf_AssignDesc_proto_2fFault_2eproto();
  friend void protobuf_ShutdownFile_proto_2fFault_2eproto();

  void InitAsDefaultInstance();
  static PowerlinkFault* default_instance_;
};
// -------------------------------------------------------------------

class SafetyIoFault : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:analogic.ancp00.SafetyIoFault) */ {
 public:
  SafetyIoFault();
  virtual ~SafetyIoFault();

  SafetyIoFault(const SafetyIoFault& from);

  inline SafetyIoFault& operator=(const SafetyIoFault& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SafetyIoFault& default_instance();

  void Swap(SafetyIoFault* other);

  // implements Message ----------------------------------------------

  inline SafetyIoFault* New() const { return New(NULL); }

  SafetyIoFault* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SafetyIoFault& from);
  void MergeFrom(const SafetyIoFault& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SafetyIoFault* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef SafetyIoFault_FAULT_ID FAULT_ID;
  static const FAULT_ID NOT_USED =
    SafetyIoFault_FAULT_ID_NOT_USED;
  static const FAULT_ID XRAY_FAULT_CLEAR_TIMEOUT =
    SafetyIoFault_FAULT_ID_XRAY_FAULT_CLEAR_TIMEOUT;
  static const FAULT_ID ESTOP =
    SafetyIoFault_FAULT_ID_ESTOP;
  static const FAULT_ID ACCESS_PANEL =
    SafetyIoFault_FAULT_ID_ACCESS_PANEL;
  static const FAULT_ID CONTACTOR =
    SafetyIoFault_FAULT_ID_CONTACTOR;
  static const FAULT_ID ENVELOPE_SENSOR =
    SafetyIoFault_FAULT_ID_ENVELOPE_SENSOR;
  static const FAULT_ID STANDSTILL_MONITOR =
    SafetyIoFault_FAULT_ID_STANDSTILL_MONITOR;
  static const FAULT_ID SPEED_FAULT =
    SafetyIoFault_FAULT_ID_SPEED_FAULT;
  static const FAULT_ID UNKNOWN =
    SafetyIoFault_FAULT_ID_UNKNOWN;
  static const FAULT_ID ENTRANCE_ESTOP_PRESSED =
    SafetyIoFault_FAULT_ID_ENTRANCE_ESTOP_PRESSED;
  static const FAULT_ID EXIT_ESTOP_PRESSED =
    SafetyIoFault_FAULT_ID_EXIT_ESTOP_PRESSED;
  static const FAULT_ID CONSOLE_ESTOP_PRESSED =
    SafetyIoFault_FAULT_ID_CONSOLE_ESTOP_PRESSED;
  static const FAULT_ID REMOTE_ESTOP_PRESSED =
    SafetyIoFault_FAULT_ID_REMOTE_ESTOP_PRESSED;
  static const FAULT_ID MOTION_CONTACTORS_STATUS_FAULT =
    SafetyIoFault_FAULT_ID_MOTION_CONTACTORS_STATUS_FAULT;
  static const FAULT_ID POWERLINK_CONTACTORS_STATUS_FAULT =
    SafetyIoFault_FAULT_ID_POWERLINK_CONTACTORS_STATUS_FAULT;
  static const FAULT_ID ROTATIONAL_ENVELOPE_VIOLATION_SENSOR_FAULT =
    SafetyIoFault_FAULT_ID_ROTATIONAL_ENVELOPE_VIOLATION_SENSOR_FAULT;
  static const FAULT_ID STANDSTILL_MONITOR_FAULT =
    SafetyIoFault_FAULT_ID_STANDSTILL_MONITOR_FAULT;
  static const FAULT_ID OVERSPEED_FAULT =
    SafetyIoFault_FAULT_ID_OVERSPEED_FAULT;
  static const FAULT_ID ACCESS_PANELS_LOCKING_FAULT =
    SafetyIoFault_FAULT_ID_ACCESS_PANELS_LOCKING_FAULT;
  static const FAULT_ID LEFT_ACCESS_PANEL_INTERLOCK_FAULT =
    SafetyIoFault_FAULT_ID_LEFT_ACCESS_PANEL_INTERLOCK_FAULT;
  static const FAULT_ID LEFT_ACCESS_PANEL_SOLENOID_STATUS_FAULT =
    SafetyIoFault_FAULT_ID_LEFT_ACCESS_PANEL_SOLENOID_STATUS_FAULT;
  static const FAULT_ID LEFT_ACCESS_PANEL_SOLENOID_LOCKED_STATUS_FAULT =
    SafetyIoFault_FAULT_ID_LEFT_ACCESS_PANEL_SOLENOID_LOCKED_STATUS_FAULT;
  static const FAULT_ID RIGHT_ACCESS_PANEL_INTERLOCK_FAULT =
    SafetyIoFault_FAULT_ID_RIGHT_ACCESS_PANEL_INTERLOCK_FAULT;
  static const FAULT_ID RIGHT_ACCESS_PANEL_SOLENOID_STATUS_FAULT =
    SafetyIoFault_FAULT_ID_RIGHT_ACCESS_PANEL_SOLENOID_STATUS_FAULT;
  static const FAULT_ID RIGHT_ACCESS_PANEL_SOLENOID_LOCKED_STATUS_FAULT =
    SafetyIoFault_FAULT_ID_RIGHT_ACCESS_PANEL_SOLENOID_LOCKED_STATUS_FAULT;
  static const FAULT_ID MANUAL_RESET_NEEDED =
    SafetyIoFault_FAULT_ID_MANUAL_RESET_NEEDED;
  static const FAULT_ID ENCODER_FAULT =
    SafetyIoFault_FAULT_ID_ENCODER_FAULT;
  static inline bool FAULT_ID_IsValid(int value) {
    return SafetyIoFault_FAULT_ID_IsValid(value);
  }
  static const FAULT_ID FAULT_ID_MIN =
    SafetyIoFault_FAULT_ID_FAULT_ID_MIN;
  static const FAULT_ID FAULT_ID_MAX =
    SafetyIoFault_FAULT_ID_FAULT_ID_MAX;
  static const int FAULT_ID_ARRAYSIZE =
    SafetyIoFault_FAULT_ID_FAULT_ID_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FAULT_ID_descriptor() {
    return SafetyIoFault_FAULT_ID_descriptor();
  }
  static inline const ::std::string& FAULT_ID_Name(FAULT_ID value) {
    return SafetyIoFault_FAULT_ID_Name(value);
  }
  static inline bool FAULT_ID_Parse(const ::std::string& name,
      FAULT_ID* value) {
    return SafetyIoFault_FAULT_ID_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:analogic.ancp00.SafetyIoFault)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_proto_2fFault_2eproto();
  friend void protobuf_AssignDesc_proto_2fFault_2eproto();
  friend void protobuf_ShutdownFile_proto_2fFault_2eproto();

  void InitAsDefaultInstance();
  static SafetyIoFault* default_instance_;
};
// -------------------------------------------------------------------

class ReconFault : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:analogic.ancp00.ReconFault) */ {
 public:
  ReconFault();
  virtual ~ReconFault();

  ReconFault(const ReconFault& from);

  inline ReconFault& operator=(const ReconFault& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReconFault& default_instance();

  void Swap(ReconFault* other);

  // implements Message ----------------------------------------------

  inline ReconFault* New() const { return New(NULL); }

  ReconFault* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReconFault& from);
  void MergeFrom(const ReconFault& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ReconFault* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ReconFault_FAULT_ID FAULT_ID;
  static const FAULT_ID NOT_USED =
    ReconFault_FAULT_ID_NOT_USED;
  static const FAULT_ID FILE_READ_ERROR =
    ReconFault_FAULT_ID_FILE_READ_ERROR;
  static const FAULT_ID GENERAL_INIT_ERROR =
    ReconFault_FAULT_ID_GENERAL_INIT_ERROR;
  static const FAULT_ID GPU_LIB_INIT_ERROR =
    ReconFault_FAULT_ID_GPU_LIB_INIT_ERROR;
  static const FAULT_ID OFFSET_CAL_FAULT =
    ReconFault_FAULT_ID_OFFSET_CAL_FAULT;
  static const FAULT_ID AIR_CAL_FAULT =
    ReconFault_FAULT_ID_AIR_CAL_FAULT;
  static const FAULT_ID NOT_READY_FOR_CMD_FAULT =
    ReconFault_FAULT_ID_NOT_READY_FOR_CMD_FAULT;
  static const FAULT_ID MANUAL_BAD_DETS_UPDATE_FAULT =
    ReconFault_FAULT_ID_MANUAL_BAD_DETS_UPDATE_FAULT;
  static const FAULT_ID BUFFER_POOL_FAULT =
    ReconFault_FAULT_ID_BUFFER_POOL_FAULT;
  static const FAULT_ID VIEW_SUBSCRIBE_TIMEOUT =
    ReconFault_FAULT_ID_VIEW_SUBSCRIBE_TIMEOUT;
  static const FAULT_ID RECON_VIEW_BLOCK_FAULT =
    ReconFault_FAULT_ID_RECON_VIEW_BLOCK_FAULT;
  static const FAULT_ID TOO_MANY_BAD_VIEWS =
    ReconFault_FAULT_ID_TOO_MANY_BAD_VIEWS;
  static const FAULT_ID DYNAMIC_CAL_FAULT =
    ReconFault_FAULT_ID_DYNAMIC_CAL_FAULT;
  static const FAULT_ID DEFAULT_CAL_FILE_FAULT =
    ReconFault_FAULT_ID_DEFAULT_CAL_FILE_FAULT;
  static inline bool FAULT_ID_IsValid(int value) {
    return ReconFault_FAULT_ID_IsValid(value);
  }
  static const FAULT_ID FAULT_ID_MIN =
    ReconFault_FAULT_ID_FAULT_ID_MIN;
  static const FAULT_ID FAULT_ID_MAX =
    ReconFault_FAULT_ID_FAULT_ID_MAX;
  static const int FAULT_ID_ARRAYSIZE =
    ReconFault_FAULT_ID_FAULT_ID_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FAULT_ID_descriptor() {
    return ReconFault_FAULT_ID_descriptor();
  }
  static inline const ::std::string& FAULT_ID_Name(FAULT_ID value) {
    return ReconFault_FAULT_ID_Name(value);
  }
  static inline bool FAULT_ID_Parse(const ::std::string& name,
      FAULT_ID* value) {
    return ReconFault_FAULT_ID_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:analogic.ancp00.ReconFault)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_proto_2fFault_2eproto();
  friend void protobuf_AssignDesc_proto_2fFault_2eproto();
  friend void protobuf_ShutdownFile_proto_2fFault_2eproto();

  void InitAsDefaultInstance();
  static ReconFault* default_instance_;
};
// -------------------------------------------------------------------

class DrbFault : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:analogic.ancp00.DrbFault) */ {
 public:
  DrbFault();
  virtual ~DrbFault();

  DrbFault(const DrbFault& from);

  inline DrbFault& operator=(const DrbFault& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DrbFault& default_instance();

  void Swap(DrbFault* other);

  // implements Message ----------------------------------------------

  inline DrbFault* New() const { return New(NULL); }

  DrbFault* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DrbFault& from);
  void MergeFrom(const DrbFault& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DrbFault* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef DrbFault_FAULT_ID FAULT_ID;
  static const FAULT_ID NOT_USED =
    DrbFault_FAULT_ID_NOT_USED;
  static const FAULT_ID DRB_NOTIFICATION =
    DrbFault_FAULT_ID_DRB_NOTIFICATION;
  static inline bool FAULT_ID_IsValid(int value) {
    return DrbFault_FAULT_ID_IsValid(value);
  }
  static const FAULT_ID FAULT_ID_MIN =
    DrbFault_FAULT_ID_FAULT_ID_MIN;
  static const FAULT_ID FAULT_ID_MAX =
    DrbFault_FAULT_ID_FAULT_ID_MAX;
  static const int FAULT_ID_ARRAYSIZE =
    DrbFault_FAULT_ID_FAULT_ID_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FAULT_ID_descriptor() {
    return DrbFault_FAULT_ID_descriptor();
  }
  static inline const ::std::string& FAULT_ID_Name(FAULT_ID value) {
    return DrbFault_FAULT_ID_Name(value);
  }
  static inline bool FAULT_ID_Parse(const ::std::string& name,
      FAULT_ID* value) {
    return DrbFault_FAULT_ID_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:analogic.ancp00.DrbFault)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_proto_2fFault_2eproto();
  friend void protobuf_AssignDesc_proto_2fFault_2eproto();
  friend void protobuf_ShutdownFile_proto_2fFault_2eproto();

  void InitAsDefaultInstance();
  static DrbFault* default_instance_;
};
// -------------------------------------------------------------------

class NimFault : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:analogic.ancp00.NimFault) */ {
 public:
  NimFault();
  virtual ~NimFault();

  NimFault(const NimFault& from);

  inline NimFault& operator=(const NimFault& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NimFault& default_instance();

  void Swap(NimFault* other);

  // implements Message ----------------------------------------------

  inline NimFault* New() const { return New(NULL); }

  NimFault* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NimFault& from);
  void MergeFrom(const NimFault& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NimFault* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef NimFault_FAULT_ID FAULT_ID;
  static const FAULT_ID NOT_USED =
    NimFault_FAULT_ID_NOT_USED;
  static const FAULT_ID OVER_MAX_BAG_QUEUE =
    NimFault_FAULT_ID_OVER_MAX_BAG_QUEUE;
  static const FAULT_ID INVALID_BAG_DATA =
    NimFault_FAULT_ID_INVALID_BAG_DATA;
  static const FAULT_ID NETWORK_DISCONNECT =
    NimFault_FAULT_ID_NETWORK_DISCONNECT;
  static inline bool FAULT_ID_IsValid(int value) {
    return NimFault_FAULT_ID_IsValid(value);
  }
  static const FAULT_ID FAULT_ID_MIN =
    NimFault_FAULT_ID_FAULT_ID_MIN;
  static const FAULT_ID FAULT_ID_MAX =
    NimFault_FAULT_ID_FAULT_ID_MAX;
  static const int FAULT_ID_ARRAYSIZE =
    NimFault_FAULT_ID_FAULT_ID_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FAULT_ID_descriptor() {
    return NimFault_FAULT_ID_descriptor();
  }
  static inline const ::std::string& FAULT_ID_Name(FAULT_ID value) {
    return NimFault_FAULT_ID_Name(value);
  }
  static inline bool FAULT_ID_Parse(const ::std::string& name,
      FAULT_ID* value) {
    return NimFault_FAULT_ID_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:analogic.ancp00.NimFault)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_proto_2fFault_2eproto();
  friend void protobuf_AssignDesc_proto_2fFault_2eproto();
  friend void protobuf_ShutdownFile_proto_2fFault_2eproto();

  void InitAsDefaultInstance();
  static NimFault* default_instance_;
};
// -------------------------------------------------------------------

class TempHumidityFault : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:analogic.ancp00.TempHumidityFault) */ {
 public:
  TempHumidityFault();
  virtual ~TempHumidityFault();

  TempHumidityFault(const TempHumidityFault& from);

  inline TempHumidityFault& operator=(const TempHumidityFault& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TempHumidityFault& default_instance();

  void Swap(TempHumidityFault* other);

  // implements Message ----------------------------------------------

  inline TempHumidityFault* New() const { return New(NULL); }

  TempHumidityFault* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TempHumidityFault& from);
  void MergeFrom(const TempHumidityFault& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TempHumidityFault* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef TempHumidityFault_FAULT_ID FAULT_ID;
  static const FAULT_ID NOT_USED =
    TempHumidityFault_FAULT_ID_NOT_USED;
  static const FAULT_ID HIGH_TEMPERATURE_WARNING =
    TempHumidityFault_FAULT_ID_HIGH_TEMPERATURE_WARNING;
  static const FAULT_ID HIGH_TEMPERATURE_FAULT =
    TempHumidityFault_FAULT_ID_HIGH_TEMPERATURE_FAULT;
  static inline bool FAULT_ID_IsValid(int value) {
    return TempHumidityFault_FAULT_ID_IsValid(value);
  }
  static const FAULT_ID FAULT_ID_MIN =
    TempHumidityFault_FAULT_ID_FAULT_ID_MIN;
  static const FAULT_ID FAULT_ID_MAX =
    TempHumidityFault_FAULT_ID_FAULT_ID_MAX;
  static const int FAULT_ID_ARRAYSIZE =
    TempHumidityFault_FAULT_ID_FAULT_ID_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FAULT_ID_descriptor() {
    return TempHumidityFault_FAULT_ID_descriptor();
  }
  static inline const ::std::string& FAULT_ID_Name(FAULT_ID value) {
    return TempHumidityFault_FAULT_ID_Name(value);
  }
  static inline bool FAULT_ID_Parse(const ::std::string& name,
      FAULT_ID* value) {
    return TempHumidityFault_FAULT_ID_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:analogic.ancp00.TempHumidityFault)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_proto_2fFault_2eproto();
  friend void protobuf_AssignDesc_proto_2fFault_2eproto();
  friend void protobuf_ShutdownFile_proto_2fFault_2eproto();

  void InitAsDefaultInstance();
  static TempHumidityFault* default_instance_;
};
// -------------------------------------------------------------------

class BLMFault : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:analogic.ancp00.BLMFault) */ {
 public:
  BLMFault();
  virtual ~BLMFault();

  BLMFault(const BLMFault& from);

  inline BLMFault& operator=(const BLMFault& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BLMFault& default_instance();

  void Swap(BLMFault* other);

  // implements Message ----------------------------------------------

  inline BLMFault* New() const { return New(NULL); }

  BLMFault* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BLMFault& from);
  void MergeFrom(const BLMFault& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BLMFault* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef BLMFault_FAULT_ID FAULT_ID;
  static const FAULT_ID NOT_USED =
    BLMFault_FAULT_ID_NOT_USED;
  static const FAULT_ID UNK_BLM_ERROR =
    BLMFault_FAULT_ID_UNK_BLM_ERROR;
  static const FAULT_ID UNK_BLM_WARNING =
    BLMFault_FAULT_ID_UNK_BLM_WARNING;
  static const FAULT_ID OUT_OF_BAGS =
    BLMFault_FAULT_ID_OUT_OF_BAGS;
  static const FAULT_ID LOW_ON_BAGS =
    BLMFault_FAULT_ID_LOW_ON_BAGS;
  static const FAULT_ID BAG_PROCESSING_ERROR =
    BLMFault_FAULT_ID_BAG_PROCESSING_ERROR;
  static inline bool FAULT_ID_IsValid(int value) {
    return BLMFault_FAULT_ID_IsValid(value);
  }
  static const FAULT_ID FAULT_ID_MIN =
    BLMFault_FAULT_ID_FAULT_ID_MIN;
  static const FAULT_ID FAULT_ID_MAX =
    BLMFault_FAULT_ID_FAULT_ID_MAX;
  static const int FAULT_ID_ARRAYSIZE =
    BLMFault_FAULT_ID_FAULT_ID_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FAULT_ID_descriptor() {
    return BLMFault_FAULT_ID_descriptor();
  }
  static inline const ::std::string& FAULT_ID_Name(FAULT_ID value) {
    return BLMFault_FAULT_ID_Name(value);
  }
  static inline bool FAULT_ID_Parse(const ::std::string& name,
      FAULT_ID* value) {
    return BLMFault_FAULT_ID_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:analogic.ancp00.BLMFault)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_proto_2fFault_2eproto();
  friend void protobuf_AssignDesc_proto_2fFault_2eproto();
  friend void protobuf_ShutdownFile_proto_2fFault_2eproto();

  void InitAsDefaultInstance();
  static BLMFault* default_instance_;
};
// -------------------------------------------------------------------

class BhsFault : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:analogic.ancp00.BhsFault) */ {
 public:
  BhsFault();
  virtual ~BhsFault();

  BhsFault(const BhsFault& from);

  inline BhsFault& operator=(const BhsFault& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BhsFault& default_instance();

  void Swap(BhsFault* other);

  // implements Message ----------------------------------------------

  inline BhsFault* New() const { return New(NULL); }

  BhsFault* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BhsFault& from);
  void MergeFrom(const BhsFault& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BhsFault* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef BhsFault_FAULT_ID FAULT_ID;
  static const FAULT_ID NOT_USED =
    BhsFault_FAULT_ID_NOT_USED;
  static const FAULT_ID MODBUS_PLC_CONNECTION_ERROR =
    BhsFault_FAULT_ID_MODBUS_PLC_CONNECTION_ERROR;
  static const FAULT_ID MODBUS_ENTRANCE_RFID_CONNECTION_ERROR =
    BhsFault_FAULT_ID_MODBUS_ENTRANCE_RFID_CONNECTION_ERROR;
  static const FAULT_ID MODBUS_EXIT_RFID_CONNECTION_ERROR =
    BhsFault_FAULT_ID_MODBUS_EXIT_RFID_CONNECTION_ERROR;
  static const FAULT_ID BAG_JAM_ERROR =
    BhsFault_FAULT_ID_BAG_JAM_ERROR;
  static const FAULT_ID GENERAL_BHS_ERROR =
    BhsFault_FAULT_ID_GENERAL_BHS_ERROR;
  static const FAULT_ID BHS_NOT_RTR =
    BhsFault_FAULT_ID_BHS_NOT_RTR;
  static const FAULT_ID ENTRANCE_BAG_JAM_ERROR =
    BhsFault_FAULT_ID_ENTRANCE_BAG_JAM_ERROR;
  static const FAULT_ID EXIT_BAG_JAM_ERROR =
    BhsFault_FAULT_ID_EXIT_BAG_JAM_ERROR;
  static const FAULT_ID TUNNEL_BAG_JAM_ERROR =
    BhsFault_FAULT_ID_TUNNEL_BAG_JAM_ERROR;
  static const FAULT_ID MOTOR_SLAVE_MISSING_ZONE2 =
    BhsFault_FAULT_ID_MOTOR_SLAVE_MISSING_ZONE2;
  static const FAULT_ID SENSOR_SLAVE_MISSING_ZONE2 =
    BhsFault_FAULT_ID_SENSOR_SLAVE_MISSING_ZONE2;
  static const FAULT_ID MOTOR_POWER_FAILURE_ZONE2 =
    BhsFault_FAULT_ID_MOTOR_POWER_FAILURE_ZONE2;
  static const FAULT_ID SENSOR_POWER_FAILURE_ZONE2 =
    BhsFault_FAULT_ID_SENSOR_POWER_FAILURE_ZONE2;
  static const FAULT_ID MOTOR_UNDER_VOLTAGE_ZONE2 =
    BhsFault_FAULT_ID_MOTOR_UNDER_VOLTAGE_ZONE2;
  static const FAULT_ID MOTOR_OVER_CURRENT_ZONE2 =
    BhsFault_FAULT_ID_MOTOR_OVER_CURRENT_ZONE2;
  static const FAULT_ID MOTOR_SLAVE_MISSING_ZONE3 =
    BhsFault_FAULT_ID_MOTOR_SLAVE_MISSING_ZONE3;
  static const FAULT_ID SENSOR_SLAVE_MISSING_ZONE3 =
    BhsFault_FAULT_ID_SENSOR_SLAVE_MISSING_ZONE3;
  static const FAULT_ID MOTOR_POWER_FAILURE_ZONE3 =
    BhsFault_FAULT_ID_MOTOR_POWER_FAILURE_ZONE3;
  static const FAULT_ID SENSOR_POWER_FAILURE_ZONE3 =
    BhsFault_FAULT_ID_SENSOR_POWER_FAILURE_ZONE3;
  static const FAULT_ID MOTOR_UNDER_VOLTAGE_ZONE3 =
    BhsFault_FAULT_ID_MOTOR_UNDER_VOLTAGE_ZONE3;
  static const FAULT_ID MOTOR_OVER_CURRENT_ZONE3 =
    BhsFault_FAULT_ID_MOTOR_OVER_CURRENT_ZONE3;
  static const FAULT_ID MOTOR_SLAVE_MISSING_ZONE3B =
    BhsFault_FAULT_ID_MOTOR_SLAVE_MISSING_ZONE3B;
  static const FAULT_ID SENSOR_SLAVE_MISSING_ZONE3B =
    BhsFault_FAULT_ID_SENSOR_SLAVE_MISSING_ZONE3B;
  static const FAULT_ID MOTOR_POWER_FAILURE_ZONE3B =
    BhsFault_FAULT_ID_MOTOR_POWER_FAILURE_ZONE3B;
  static const FAULT_ID SENSOR_POWER_FAILURE_ZONE3B =
    BhsFault_FAULT_ID_SENSOR_POWER_FAILURE_ZONE3B;
  static const FAULT_ID MOTOR_UNDER_VOLTAGE_ZONE3B =
    BhsFault_FAULT_ID_MOTOR_UNDER_VOLTAGE_ZONE3B;
  static const FAULT_ID MOTOR_OVER_CURRENT_ZONE3B =
    BhsFault_FAULT_ID_MOTOR_OVER_CURRENT_ZONE3B;
  static const FAULT_ID MOTOR_SLAVE_MISSING_ZONE4 =
    BhsFault_FAULT_ID_MOTOR_SLAVE_MISSING_ZONE4;
  static const FAULT_ID SENSOR_SLAVE_MISSING_ZONE4 =
    BhsFault_FAULT_ID_SENSOR_SLAVE_MISSING_ZONE4;
  static const FAULT_ID MOTOR_POWER_FAILURE_ZONE4 =
    BhsFault_FAULT_ID_MOTOR_POWER_FAILURE_ZONE4;
  static const FAULT_ID SENSOR_POWER_FAILURE_ZONE4 =
    BhsFault_FAULT_ID_SENSOR_POWER_FAILURE_ZONE4;
  static const FAULT_ID MOTOR_UNDER_VOLTAGE_ZONE4 =
    BhsFault_FAULT_ID_MOTOR_UNDER_VOLTAGE_ZONE4;
  static const FAULT_ID MOTOR_OVER_CURRENT_ZONE4 =
    BhsFault_FAULT_ID_MOTOR_OVER_CURRENT_ZONE4;
  static const FAULT_ID MOTOR_SLAVE_MISSING_ZONE7 =
    BhsFault_FAULT_ID_MOTOR_SLAVE_MISSING_ZONE7;
  static const FAULT_ID SENSOR_SLAVE_MISSING_ZONE7 =
    BhsFault_FAULT_ID_SENSOR_SLAVE_MISSING_ZONE7;
  static const FAULT_ID MOTOR_POWER_FAILURE_ZONE7 =
    BhsFault_FAULT_ID_MOTOR_POWER_FAILURE_ZONE7;
  static const FAULT_ID SENSOR_POWER_FAILURE_ZONE7 =
    BhsFault_FAULT_ID_SENSOR_POWER_FAILURE_ZONE7;
  static const FAULT_ID MOTOR_UNDER_VOLTAGE_ZONE7 =
    BhsFault_FAULT_ID_MOTOR_UNDER_VOLTAGE_ZONE7;
  static const FAULT_ID MOTOR_OVER_CURRENT_ZONE7 =
    BhsFault_FAULT_ID_MOTOR_OVER_CURRENT_ZONE7;
  static const FAULT_ID MOTOR_SLAVE_MISSING_ZONE8 =
    BhsFault_FAULT_ID_MOTOR_SLAVE_MISSING_ZONE8;
  static const FAULT_ID SENSOR_SLAVE_MISSING_ZONE8 =
    BhsFault_FAULT_ID_SENSOR_SLAVE_MISSING_ZONE8;
  static const FAULT_ID MOTOR_POWER_FAILURE_ZONE8 =
    BhsFault_FAULT_ID_MOTOR_POWER_FAILURE_ZONE8;
  static const FAULT_ID SENSOR_POWER_FAILURE_ZONE8 =
    BhsFault_FAULT_ID_SENSOR_POWER_FAILURE_ZONE8;
  static const FAULT_ID MOTOR_UNDER_VOLTAGE_ZONE8 =
    BhsFault_FAULT_ID_MOTOR_UNDER_VOLTAGE_ZONE8;
  static const FAULT_ID MOTOR_OVER_CURRENT_ZONE8 =
    BhsFault_FAULT_ID_MOTOR_OVER_CURRENT_ZONE8;
  static const FAULT_ID DIVERTER_SLAVE_MISSING_ZONE5 =
    BhsFault_FAULT_ID_DIVERTER_SLAVE_MISSING_ZONE5;
  static const FAULT_ID ROLLER_SLAVE_MISSING_ZONE5 =
    BhsFault_FAULT_ID_ROLLER_SLAVE_MISSING_ZONE5;
  static const FAULT_ID ROLLER_AT_FAULT_ZONE5 =
    BhsFault_FAULT_ID_ROLLER_AT_FAULT_ZONE5;
  static const FAULT_ID DIVERTER_AT_FAULT_ZONE5 =
    BhsFault_FAULT_ID_DIVERTER_AT_FAULT_ZONE5;
  static const FAULT_ID ROLLER_UNDER_VOLTAGE_ZONE5 =
    BhsFault_FAULT_ID_ROLLER_UNDER_VOLTAGE_ZONE5;
  static const FAULT_ID ROLLER_OVER_CURRENT_ZONE5 =
    BhsFault_FAULT_ID_ROLLER_OVER_CURRENT_ZONE5;
  static const FAULT_ID DIVERTER_UNDER_VOLTAGE_ZONE5 =
    BhsFault_FAULT_ID_DIVERTER_UNDER_VOLTAGE_ZONE5;
  static const FAULT_ID DIVERTER_OVER_CURRENT_ZONE5 =
    BhsFault_FAULT_ID_DIVERTER_OVER_CURRENT_ZONE5;
  static const FAULT_ID DIVERTER_SLAVE_MISSING_ZONE6 =
    BhsFault_FAULT_ID_DIVERTER_SLAVE_MISSING_ZONE6;
  static const FAULT_ID ROLLER_SLAVE_MISSING_ZONE6 =
    BhsFault_FAULT_ID_ROLLER_SLAVE_MISSING_ZONE6;
  static const FAULT_ID ROLLER_AT_FAULT_ZONE6 =
    BhsFault_FAULT_ID_ROLLER_AT_FAULT_ZONE6;
  static const FAULT_ID DIVERTER_AT_FAULT_ZONE6 =
    BhsFault_FAULT_ID_DIVERTER_AT_FAULT_ZONE6;
  static const FAULT_ID ROLLER_UNDER_VOLTAGE_ZONE6 =
    BhsFault_FAULT_ID_ROLLER_UNDER_VOLTAGE_ZONE6;
  static const FAULT_ID ROLLER_OVER_CURRENT_ZONE6 =
    BhsFault_FAULT_ID_ROLLER_OVER_CURRENT_ZONE6;
  static const FAULT_ID DIVERTER_UNDER_VOLTAGE_ZONE6 =
    BhsFault_FAULT_ID_DIVERTER_UNDER_VOLTAGE_ZONE6;
  static const FAULT_ID DIVERTER_OVER_CURRENT_ZONE6 =
    BhsFault_FAULT_ID_DIVERTER_OVER_CURRENT_ZONE6;
  static const FAULT_ID ASI_TERMINAL_MISSING =
    BhsFault_FAULT_ID_ASI_TERMINAL_MISSING;
  static const FAULT_ID ASI_MODULE_ERROR =
    BhsFault_FAULT_ID_ASI_MODULE_ERROR;
  static const FAULT_ID DIVERTER_DIRECTION_CONFIG_ERROR =
    BhsFault_FAULT_ID_DIVERTER_DIRECTION_CONFIG_ERROR;
  static inline bool FAULT_ID_IsValid(int value) {
    return BhsFault_FAULT_ID_IsValid(value);
  }
  static const FAULT_ID FAULT_ID_MIN =
    BhsFault_FAULT_ID_FAULT_ID_MIN;
  static const FAULT_ID FAULT_ID_MAX =
    BhsFault_FAULT_ID_FAULT_ID_MAX;
  static const int FAULT_ID_ARRAYSIZE =
    BhsFault_FAULT_ID_FAULT_ID_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FAULT_ID_descriptor() {
    return BhsFault_FAULT_ID_descriptor();
  }
  static inline const ::std::string& FAULT_ID_Name(FAULT_ID value) {
    return BhsFault_FAULT_ID_Name(value);
  }
  static inline bool FAULT_ID_Parse(const ::std::string& name,
      FAULT_ID* value) {
    return BhsFault_FAULT_ID_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:analogic.ancp00.BhsFault)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_proto_2fFault_2eproto();
  friend void protobuf_AssignDesc_proto_2fFault_2eproto();
  friend void protobuf_ShutdownFile_proto_2fFault_2eproto();

  void InitAsDefaultInstance();
  static BhsFault* default_instance_;
};
// -------------------------------------------------------------------

class CommFault : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:analogic.ancp00.CommFault) */ {
 public:
  CommFault();
  virtual ~CommFault();

  CommFault(const CommFault& from);

  inline CommFault& operator=(const CommFault& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommFault& default_instance();

  void Swap(CommFault* other);

  // implements Message ----------------------------------------------

  inline CommFault* New() const { return New(NULL); }

  CommFault* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommFault& from);
  void MergeFrom(const CommFault& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommFault* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CommFault_FAULT_ID FAULT_ID;
  static const FAULT_ID NOT_USED =
    CommFault_FAULT_ID_NOT_USED;
  static const FAULT_ID SYSTEM_COMM_ERROR =
    CommFault_FAULT_ID_SYSTEM_COMM_ERROR;
  static const FAULT_ID NETWORK_OFFLINE =
    CommFault_FAULT_ID_NETWORK_OFFLINE;
  static const FAULT_ID BHS_OFFLINE =
    CommFault_FAULT_ID_BHS_OFFLINE;
  static const FAULT_ID SCC_OFFLINE =
    CommFault_FAULT_ID_SCC_OFFLINE;
  static const FAULT_ID UPS_OFFLINE =
    CommFault_FAULT_ID_UPS_OFFLINE;
  static const FAULT_ID DRB_OFFLINE =
    CommFault_FAULT_ID_DRB_OFFLINE;
  static const FAULT_ID SAFETY_IO_OFFLINE =
    CommFault_FAULT_ID_SAFETY_IO_OFFLINE;
  static const FAULT_ID RCB_OFFLINE =
    CommFault_FAULT_ID_RCB_OFFLINE;
  static const FAULT_ID XRAY_OFFLINE =
    CommFault_FAULT_ID_XRAY_OFFLINE;
  static const FAULT_ID SERIAL_SERVER_1_OFFLINE =
    CommFault_FAULT_ID_SERIAL_SERVER_1_OFFLINE;
  static const FAULT_ID SERIAL_SERVER_2_OFFLINE =
    CommFault_FAULT_ID_SERIAL_SERVER_2_OFFLINE;
  static const FAULT_ID GANTRY_OFFLINE =
    CommFault_FAULT_ID_GANTRY_OFFLINE;
  static const FAULT_ID CONVEYOR_OFFLINE =
    CommFault_FAULT_ID_CONVEYOR_OFFLINE;
  static const FAULT_ID TEMP_HUMIDITY_SENSOR_OFFLINE =
    CommFault_FAULT_ID_TEMP_HUMIDITY_SENSOR_OFFLINE;
  static const FAULT_ID POWERLINK_OFFLINE =
    CommFault_FAULT_ID_POWERLINK_OFFLINE;
  static const FAULT_ID DCB_1_OFFLINE =
    CommFault_FAULT_ID_DCB_1_OFFLINE;
  static const FAULT_ID DCB_2_OFFLINE =
    CommFault_FAULT_ID_DCB_2_OFFLINE;
  static const FAULT_ID DCB_3_OFFLINE =
    CommFault_FAULT_ID_DCB_3_OFFLINE;
  static const FAULT_ID DCB_4_OFFLINE =
    CommFault_FAULT_ID_DCB_4_OFFLINE;
  static const FAULT_ID DCB_5_OFFLINE =
    CommFault_FAULT_ID_DCB_5_OFFLINE;
  static const FAULT_ID POWER_METER_OFFLINE =
    CommFault_FAULT_ID_POWER_METER_OFFLINE;
  static inline bool FAULT_ID_IsValid(int value) {
    return CommFault_FAULT_ID_IsValid(value);
  }
  static const FAULT_ID FAULT_ID_MIN =
    CommFault_FAULT_ID_FAULT_ID_MIN;
  static const FAULT_ID FAULT_ID_MAX =
    CommFault_FAULT_ID_FAULT_ID_MAX;
  static const int FAULT_ID_ARRAYSIZE =
    CommFault_FAULT_ID_FAULT_ID_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FAULT_ID_descriptor() {
    return CommFault_FAULT_ID_descriptor();
  }
  static inline const ::std::string& FAULT_ID_Name(FAULT_ID value) {
    return CommFault_FAULT_ID_Name(value);
  }
  static inline bool FAULT_ID_Parse(const ::std::string& name,
      FAULT_ID* value) {
    return CommFault_FAULT_ID_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:analogic.ancp00.CommFault)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_proto_2fFault_2eproto();
  friend void protobuf_AssignDesc_proto_2fFault_2eproto();
  friend void protobuf_ShutdownFile_proto_2fFault_2eproto();

  void InitAsDefaultInstance();
  static CommFault* default_instance_;
};
// -------------------------------------------------------------------

class UpsFault : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:analogic.ancp00.UpsFault) */ {
 public:
  UpsFault();
  virtual ~UpsFault();

  UpsFault(const UpsFault& from);

  inline UpsFault& operator=(const UpsFault& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpsFault& default_instance();

  void Swap(UpsFault* other);

  // implements Message ----------------------------------------------

  inline UpsFault* New() const { return New(NULL); }

  UpsFault* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpsFault& from);
  void MergeFrom(const UpsFault& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UpsFault* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef UpsFault_FAULT_ID FAULT_ID;
  static const FAULT_ID NOT_USED =
    UpsFault_FAULT_ID_NOT_USED;
  static const FAULT_ID UPS_BAD_COMM =
    UpsFault_FAULT_ID_UPS_BAD_COMM;
  static const FAULT_ID UPS_NO_COMM =
    UpsFault_FAULT_ID_UPS_NO_COMM;
  static const FAULT_ID UPS_ON_BATTERY_POWER =
    UpsFault_FAULT_ID_UPS_ON_BATTERY_POWER;
  static const FAULT_ID UPS_LOW_BATTERY =
    UpsFault_FAULT_ID_UPS_LOW_BATTERY;
  static const FAULT_ID UPSMON_NO_PARENT =
    UpsFault_FAULT_ID_UPSMON_NO_PARENT;
  static const FAULT_ID UPS_REPLACE_BATTERY =
    UpsFault_FAULT_ID_UPS_REPLACE_BATTERY;
  static inline bool FAULT_ID_IsValid(int value) {
    return UpsFault_FAULT_ID_IsValid(value);
  }
  static const FAULT_ID FAULT_ID_MIN =
    UpsFault_FAULT_ID_FAULT_ID_MIN;
  static const FAULT_ID FAULT_ID_MAX =
    UpsFault_FAULT_ID_FAULT_ID_MAX;
  static const int FAULT_ID_ARRAYSIZE =
    UpsFault_FAULT_ID_FAULT_ID_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FAULT_ID_descriptor() {
    return UpsFault_FAULT_ID_descriptor();
  }
  static inline const ::std::string& FAULT_ID_Name(FAULT_ID value) {
    return UpsFault_FAULT_ID_Name(value);
  }
  static inline bool FAULT_ID_Parse(const ::std::string& name,
      FAULT_ID* value) {
    return UpsFault_FAULT_ID_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:analogic.ancp00.UpsFault)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_proto_2fFault_2eproto();
  friend void protobuf_AssignDesc_proto_2fFault_2eproto();
  friend void protobuf_ShutdownFile_proto_2fFault_2eproto();

  void InitAsDefaultInstance();
  static UpsFault* default_instance_;
};
// -------------------------------------------------------------------

class ComputerFault : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:analogic.ancp00.ComputerFault) */ {
 public:
  ComputerFault();
  virtual ~ComputerFault();

  ComputerFault(const ComputerFault& from);

  inline ComputerFault& operator=(const ComputerFault& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ComputerFault& default_instance();

  void Swap(ComputerFault* other);

  // implements Message ----------------------------------------------

  inline ComputerFault* New() const { return New(NULL); }

  ComputerFault* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ComputerFault& from);
  void MergeFrom(const ComputerFault& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ComputerFault* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ComputerFault_FAULT_ID FAULT_ID;
  static const FAULT_ID NOT_USED =
    ComputerFault_FAULT_ID_NOT_USED;
  static const FAULT_ID COMPUTER_DRIVE_FULL =
    ComputerFault_FAULT_ID_COMPUTER_DRIVE_FULL;
  static const FAULT_ID COMPUTER_RAID_NOT_MOUNTED =
    ComputerFault_FAULT_ID_COMPUTER_RAID_NOT_MOUNTED;
  static const FAULT_ID COMPUTER_NETWORK_LOW_SPEED =
    ComputerFault_FAULT_ID_COMPUTER_NETWORK_LOW_SPEED;
  static inline bool FAULT_ID_IsValid(int value) {
    return ComputerFault_FAULT_ID_IsValid(value);
  }
  static const FAULT_ID FAULT_ID_MIN =
    ComputerFault_FAULT_ID_FAULT_ID_MIN;
  static const FAULT_ID FAULT_ID_MAX =
    ComputerFault_FAULT_ID_FAULT_ID_MAX;
  static const int FAULT_ID_ARRAYSIZE =
    ComputerFault_FAULT_ID_FAULT_ID_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FAULT_ID_descriptor() {
    return ComputerFault_FAULT_ID_descriptor();
  }
  static inline const ::std::string& FAULT_ID_Name(FAULT_ID value) {
    return ComputerFault_FAULT_ID_Name(value);
  }
  static inline bool FAULT_ID_Parse(const ::std::string& name,
      FAULT_ID* value) {
    return ComputerFault_FAULT_ID_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:analogic.ancp00.ComputerFault)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_proto_2fFault_2eproto();
  friend void protobuf_AssignDesc_proto_2fFault_2eproto();
  friend void protobuf_ShutdownFile_proto_2fFault_2eproto();

  void InitAsDefaultInstance();
  static ComputerFault* default_instance_;
};
// -------------------------------------------------------------------

class InterlockFault : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:analogic.ancp00.InterlockFault) */ {
 public:
  InterlockFault();
  virtual ~InterlockFault();

  InterlockFault(const InterlockFault& from);

  inline InterlockFault& operator=(const InterlockFault& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InterlockFault& default_instance();

  void Swap(InterlockFault* other);

  // implements Message ----------------------------------------------

  inline InterlockFault* New() const { return New(NULL); }

  InterlockFault* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InterlockFault& from);
  void MergeFrom(const InterlockFault& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InterlockFault* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef InterlockFault_FAULT_ID FAULT_ID;
  static const FAULT_ID NOT_USED =
    InterlockFault_FAULT_ID_NOT_USED;
  static const FAULT_ID CANNOT_REVERSE_CONVEYOR_IN_SCAN_MODE =
    InterlockFault_FAULT_ID_CANNOT_REVERSE_CONVEYOR_IN_SCAN_MODE;
  static const FAULT_ID XRAY_CONTROL_MOTION_KEYSWITCH_INTERLOCK_VIOLATION =
    InterlockFault_FAULT_ID_XRAY_CONTROL_MOTION_KEYSWITCH_INTERLOCK_VIOLATION;
  static const FAULT_ID ACCESS_PANEL_INTERLOCK_VIOLATION =
    InterlockFault_FAULT_ID_ACCESS_PANEL_INTERLOCK_VIOLATION;
  static const FAULT_ID GANTRY_NOT_AT_SPEED_NOR_AT_HOME_INTERLOCK_VIOLATION =
    InterlockFault_FAULT_ID_GANTRY_NOT_AT_SPEED_NOR_AT_HOME_INTERLOCK_VIOLATION;
  static const FAULT_ID CANNOT_MAXIMIXE_XRAYS_NOT_ON =
    InterlockFault_FAULT_ID_CANNOT_MAXIMIXE_XRAYS_NOT_ON;
  static const FAULT_ID OPERATOR_NOT_PRESENT =
    InterlockFault_FAULT_ID_OPERATOR_NOT_PRESENT;
  static inline bool FAULT_ID_IsValid(int value) {
    return InterlockFault_FAULT_ID_IsValid(value);
  }
  static const FAULT_ID FAULT_ID_MIN =
    InterlockFault_FAULT_ID_FAULT_ID_MIN;
  static const FAULT_ID FAULT_ID_MAX =
    InterlockFault_FAULT_ID_FAULT_ID_MAX;
  static const int FAULT_ID_ARRAYSIZE =
    InterlockFault_FAULT_ID_FAULT_ID_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FAULT_ID_descriptor() {
    return InterlockFault_FAULT_ID_descriptor();
  }
  static inline const ::std::string& FAULT_ID_Name(FAULT_ID value) {
    return InterlockFault_FAULT_ID_Name(value);
  }
  static inline bool FAULT_ID_Parse(const ::std::string& name,
      FAULT_ID* value) {
    return InterlockFault_FAULT_ID_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:analogic.ancp00.InterlockFault)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_proto_2fFault_2eproto();
  friend void protobuf_AssignDesc_proto_2fFault_2eproto();
  friend void protobuf_ShutdownFile_proto_2fFault_2eproto();

  void InitAsDefaultInstance();
  static InterlockFault* default_instance_;
};
// -------------------------------------------------------------------

class Fault : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:analogic.ancp00.Fault) */ {
 public:
  Fault();
  virtual ~Fault();

  Fault(const Fault& from);

  inline Fault& operator=(const Fault& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Fault& default_instance();

  void Swap(Fault* other);

  // implements Message ----------------------------------------------

  inline Fault* New() const { return New(NULL); }

  Fault* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Fault& from);
  void MergeFrom(const Fault& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Fault* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Fault_FAULT_ID FAULT_ID;
  static const FAULT_ID NOT_USED =
    Fault_FAULT_ID_NOT_USED;
  static inline bool FAULT_ID_IsValid(int value) {
    return Fault_FAULT_ID_IsValid(value);
  }
  static const FAULT_ID FAULT_ID_MIN =
    Fault_FAULT_ID_FAULT_ID_MIN;
  static const FAULT_ID FAULT_ID_MAX =
    Fault_FAULT_ID_FAULT_ID_MAX;
  static const int FAULT_ID_ARRAYSIZE =
    Fault_FAULT_ID_FAULT_ID_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FAULT_ID_descriptor() {
    return Fault_FAULT_ID_descriptor();
  }
  static inline const ::std::string& FAULT_ID_Name(FAULT_ID value) {
    return Fault_FAULT_ID_Name(value);
  }
  static inline bool FAULT_ID_Parse(const ::std::string& name,
      FAULT_ID* value) {
    return Fault_FAULT_ID_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:analogic.ancp00.Fault)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_proto_2fFault_2eproto();
  friend void protobuf_AssignDesc_proto_2fFault_2eproto();
  friend void protobuf_ShutdownFile_proto_2fFault_2eproto();

  void InitAsDefaultInstance();
  static Fault* default_instance_;
};
// -------------------------------------------------------------------

class FaultFilterCondition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:analogic.ancp00.FaultFilterCondition) */ {
 public:
  FaultFilterCondition();
  virtual ~FaultFilterCondition();

  FaultFilterCondition(const FaultFilterCondition& from);

  inline FaultFilterCondition& operator=(const FaultFilterCondition& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FaultFilterCondition& default_instance();

  void Swap(FaultFilterCondition* other);

  // implements Message ----------------------------------------------

  inline FaultFilterCondition* New() const { return New(NULL); }

  FaultFilterCondition* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FaultFilterCondition& from);
  void MergeFrom(const FaultFilterCondition& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FaultFilterCondition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef FaultFilterCondition_CONDITION_ID CONDITION_ID;
  static const CONDITION_ID NOT_USED =
    FaultFilterCondition_CONDITION_ID_NOT_USED;
  static const CONDITION_ID ESTOP =
    FaultFilterCondition_CONDITION_ID_ESTOP;
  static const CONDITION_ID POWERLINK_DISABLED =
    FaultFilterCondition_CONDITION_ID_POWERLINK_DISABLED;
  static const CONDITION_ID XRAY_MOTOR_POWER_KEY_SWITCH_DISABLED =
    FaultFilterCondition_CONDITION_ID_XRAY_MOTOR_POWER_KEY_SWITCH_DISABLED;
  static const CONDITION_ID DOOR_INTERLOCK_VIOLATION =
    FaultFilterCondition_CONDITION_ID_DOOR_INTERLOCK_VIOLATION;
  static const CONDITION_ID RAID_FAULT =
    FaultFilterCondition_CONDITION_ID_RAID_FAULT;
  static const CONDITION_ID ON_BATTERY_POWER =
    FaultFilterCondition_CONDITION_ID_ON_BATTERY_POWER;
  static inline bool CONDITION_ID_IsValid(int value) {
    return FaultFilterCondition_CONDITION_ID_IsValid(value);
  }
  static const CONDITION_ID CONDITION_ID_MIN =
    FaultFilterCondition_CONDITION_ID_CONDITION_ID_MIN;
  static const CONDITION_ID CONDITION_ID_MAX =
    FaultFilterCondition_CONDITION_ID_CONDITION_ID_MAX;
  static const int CONDITION_ID_ARRAYSIZE =
    FaultFilterCondition_CONDITION_ID_CONDITION_ID_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CONDITION_ID_descriptor() {
    return FaultFilterCondition_CONDITION_ID_descriptor();
  }
  static inline const ::std::string& CONDITION_ID_Name(CONDITION_ID value) {
    return FaultFilterCondition_CONDITION_ID_Name(value);
  }
  static inline bool CONDITION_ID_Parse(const ::std::string& name,
      CONDITION_ID* value) {
    return FaultFilterCondition_CONDITION_ID_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:analogic.ancp00.FaultFilterCondition)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_proto_2fFault_2eproto();
  friend void protobuf_AssignDesc_proto_2fFault_2eproto();
  friend void protobuf_ShutdownFile_proto_2fFault_2eproto();

  void InitAsDefaultInstance();
  static FaultFilterCondition* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// FaultData

// optional .analogic.ancp00.SUBSYSTEM_ID subsys_id = 1;
inline void FaultData::clear_subsys_id() {
  subsys_id_ = 0;
}
inline ::analogic::ancp00::SUBSYSTEM_ID FaultData::subsys_id() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.FaultData.subsys_id)
  return static_cast< ::analogic::ancp00::SUBSYSTEM_ID >(subsys_id_);
}
inline void FaultData::set_subsys_id(::analogic::ancp00::SUBSYSTEM_ID value) {
  
  subsys_id_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.FaultData.subsys_id)
}

// optional .analogic.ancp00.FaultData.FAULT_LEVEL level = 2;
inline void FaultData::clear_level() {
  level_ = 0;
}
inline ::analogic::ancp00::FaultData_FAULT_LEVEL FaultData::level() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.FaultData.level)
  return static_cast< ::analogic::ancp00::FaultData_FAULT_LEVEL >(level_);
}
inline void FaultData::set_level(::analogic::ancp00::FaultData_FAULT_LEVEL value) {
  
  level_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.FaultData.level)
}

// optional uint64 id = 3;
inline void FaultData::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 FaultData::id() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.FaultData.id)
  return id_;
}
inline void FaultData::set_id(::google::protobuf::uint64 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.FaultData.id)
}

// optional uint64 epoch_time_ms = 4;
inline void FaultData::clear_epoch_time_ms() {
  epoch_time_ms_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 FaultData::epoch_time_ms() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.FaultData.epoch_time_ms)
  return epoch_time_ms_;
}
inline void FaultData::set_epoch_time_ms(::google::protobuf::uint64 value) {
  
  epoch_time_ms_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.FaultData.epoch_time_ms)
}

// optional string local_time_str = 5;
inline void FaultData::clear_local_time_str() {
  local_time_str_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FaultData::local_time_str() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.FaultData.local_time_str)
  return local_time_str_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FaultData::set_local_time_str(const ::std::string& value) {
  
  local_time_str_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:analogic.ancp00.FaultData.local_time_str)
}
inline void FaultData::set_local_time_str(const char* value) {
  
  local_time_str_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:analogic.ancp00.FaultData.local_time_str)
}
inline void FaultData::set_local_time_str(const char* value, size_t size) {
  
  local_time_str_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:analogic.ancp00.FaultData.local_time_str)
}
inline ::std::string* FaultData::mutable_local_time_str() {
  
  // @@protoc_insertion_point(field_mutable:analogic.ancp00.FaultData.local_time_str)
  return local_time_str_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FaultData::release_local_time_str() {
  // @@protoc_insertion_point(field_release:analogic.ancp00.FaultData.local_time_str)
  
  return local_time_str_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FaultData::set_allocated_local_time_str(::std::string* local_time_str) {
  if (local_time_str != NULL) {
    
  } else {
    
  }
  local_time_str_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), local_time_str);
  // @@protoc_insertion_point(field_set_allocated:analogic.ancp00.FaultData.local_time_str)
}

// optional string text = 6;
inline void FaultData::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FaultData::text() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.FaultData.text)
  return text_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FaultData::set_text(const ::std::string& value) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:analogic.ancp00.FaultData.text)
}
inline void FaultData::set_text(const char* value) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:analogic.ancp00.FaultData.text)
}
inline void FaultData::set_text(const char* value, size_t size) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:analogic.ancp00.FaultData.text)
}
inline ::std::string* FaultData::mutable_text() {
  
  // @@protoc_insertion_point(field_mutable:analogic.ancp00.FaultData.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FaultData::release_text() {
  // @@protoc_insertion_point(field_release:analogic.ancp00.FaultData.text)
  
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FaultData::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    
  } else {
    
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:analogic.ancp00.FaultData.text)
}

// optional string key = 7;
inline void FaultData::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FaultData::key() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.FaultData.key)
  return key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FaultData::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:analogic.ancp00.FaultData.key)
}
inline void FaultData::set_key(const char* value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:analogic.ancp00.FaultData.key)
}
inline void FaultData::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:analogic.ancp00.FaultData.key)
}
inline ::std::string* FaultData::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:analogic.ancp00.FaultData.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FaultData::release_key() {
  // @@protoc_insertion_point(field_release:analogic.ancp00.FaultData.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FaultData::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:analogic.ancp00.FaultData.key)
}

// optional string obj_key = 50;
inline void FaultData::clear_obj_key() {
  obj_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FaultData::obj_key() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.FaultData.obj_key)
  return obj_key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FaultData::set_obj_key(const ::std::string& value) {
  
  obj_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:analogic.ancp00.FaultData.obj_key)
}
inline void FaultData::set_obj_key(const char* value) {
  
  obj_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:analogic.ancp00.FaultData.obj_key)
}
inline void FaultData::set_obj_key(const char* value, size_t size) {
  
  obj_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:analogic.ancp00.FaultData.obj_key)
}
inline ::std::string* FaultData::mutable_obj_key() {
  
  // @@protoc_insertion_point(field_mutable:analogic.ancp00.FaultData.obj_key)
  return obj_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FaultData::release_obj_key() {
  // @@protoc_insertion_point(field_release:analogic.ancp00.FaultData.obj_key)
  
  return obj_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FaultData::set_allocated_obj_key(::std::string* obj_key) {
  if (obj_key != NULL) {
    
  } else {
    
  }
  obj_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), obj_key);
  // @@protoc_insertion_point(field_set_allocated:analogic.ancp00.FaultData.obj_key)
}

// optional string obj_data = 51;
inline void FaultData::clear_obj_data() {
  obj_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FaultData::obj_data() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.FaultData.obj_data)
  return obj_data_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FaultData::set_obj_data(const ::std::string& value) {
  
  obj_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:analogic.ancp00.FaultData.obj_data)
}
inline void FaultData::set_obj_data(const char* value) {
  
  obj_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:analogic.ancp00.FaultData.obj_data)
}
inline void FaultData::set_obj_data(const char* value, size_t size) {
  
  obj_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:analogic.ancp00.FaultData.obj_data)
}
inline ::std::string* FaultData::mutable_obj_data() {
  
  // @@protoc_insertion_point(field_mutable:analogic.ancp00.FaultData.obj_data)
  return obj_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FaultData::release_obj_data() {
  // @@protoc_insertion_point(field_release:analogic.ancp00.FaultData.obj_data)
  
  return obj_data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FaultData::set_allocated_obj_data(::std::string* obj_data) {
  if (obj_data != NULL) {
    
  } else {
    
  }
  obj_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), obj_data);
  // @@protoc_insertion_point(field_set_allocated:analogic.ancp00.FaultData.obj_data)
}

// -------------------------------------------------------------------

// GenericFault

// -------------------------------------------------------------------

// XrayControlFault

// -------------------------------------------------------------------

// MotorControlFault

// -------------------------------------------------------------------

// PowerlinkFault

// -------------------------------------------------------------------

// SafetyIoFault

// -------------------------------------------------------------------

// ReconFault

// -------------------------------------------------------------------

// DrbFault

// -------------------------------------------------------------------

// NimFault

// -------------------------------------------------------------------

// TempHumidityFault

// -------------------------------------------------------------------

// BLMFault

// -------------------------------------------------------------------

// BhsFault

// -------------------------------------------------------------------

// CommFault

// -------------------------------------------------------------------

// UpsFault

// -------------------------------------------------------------------

// ComputerFault

// -------------------------------------------------------------------

// InterlockFault

// -------------------------------------------------------------------

// Fault

// -------------------------------------------------------------------

// FaultFilterCondition

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace ancp00
}  // namespace analogic

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::analogic::ancp00::FaultData_FAULT_LEVEL> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::analogic::ancp00::FaultData_FAULT_LEVEL>() {
  return ::analogic::ancp00::FaultData_FAULT_LEVEL_descriptor();
}
template <> struct is_proto_enum< ::analogic::ancp00::GenericFault_FAULT_ID> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::analogic::ancp00::GenericFault_FAULT_ID>() {
  return ::analogic::ancp00::GenericFault_FAULT_ID_descriptor();
}
template <> struct is_proto_enum< ::analogic::ancp00::XrayControlFault_FAULT_ID> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::analogic::ancp00::XrayControlFault_FAULT_ID>() {
  return ::analogic::ancp00::XrayControlFault_FAULT_ID_descriptor();
}
template <> struct is_proto_enum< ::analogic::ancp00::MotorControlFault_FAULT_ID> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::analogic::ancp00::MotorControlFault_FAULT_ID>() {
  return ::analogic::ancp00::MotorControlFault_FAULT_ID_descriptor();
}
template <> struct is_proto_enum< ::analogic::ancp00::PowerlinkFault_FAULT_ID> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::analogic::ancp00::PowerlinkFault_FAULT_ID>() {
  return ::analogic::ancp00::PowerlinkFault_FAULT_ID_descriptor();
}
template <> struct is_proto_enum< ::analogic::ancp00::SafetyIoFault_FAULT_ID> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::analogic::ancp00::SafetyIoFault_FAULT_ID>() {
  return ::analogic::ancp00::SafetyIoFault_FAULT_ID_descriptor();
}
template <> struct is_proto_enum< ::analogic::ancp00::ReconFault_FAULT_ID> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::analogic::ancp00::ReconFault_FAULT_ID>() {
  return ::analogic::ancp00::ReconFault_FAULT_ID_descriptor();
}
template <> struct is_proto_enum< ::analogic::ancp00::DrbFault_FAULT_ID> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::analogic::ancp00::DrbFault_FAULT_ID>() {
  return ::analogic::ancp00::DrbFault_FAULT_ID_descriptor();
}
template <> struct is_proto_enum< ::analogic::ancp00::NimFault_FAULT_ID> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::analogic::ancp00::NimFault_FAULT_ID>() {
  return ::analogic::ancp00::NimFault_FAULT_ID_descriptor();
}
template <> struct is_proto_enum< ::analogic::ancp00::TempHumidityFault_FAULT_ID> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::analogic::ancp00::TempHumidityFault_FAULT_ID>() {
  return ::analogic::ancp00::TempHumidityFault_FAULT_ID_descriptor();
}
template <> struct is_proto_enum< ::analogic::ancp00::BLMFault_FAULT_ID> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::analogic::ancp00::BLMFault_FAULT_ID>() {
  return ::analogic::ancp00::BLMFault_FAULT_ID_descriptor();
}
template <> struct is_proto_enum< ::analogic::ancp00::BhsFault_FAULT_ID> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::analogic::ancp00::BhsFault_FAULT_ID>() {
  return ::analogic::ancp00::BhsFault_FAULT_ID_descriptor();
}
template <> struct is_proto_enum< ::analogic::ancp00::CommFault_FAULT_ID> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::analogic::ancp00::CommFault_FAULT_ID>() {
  return ::analogic::ancp00::CommFault_FAULT_ID_descriptor();
}
template <> struct is_proto_enum< ::analogic::ancp00::UpsFault_FAULT_ID> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::analogic::ancp00::UpsFault_FAULT_ID>() {
  return ::analogic::ancp00::UpsFault_FAULT_ID_descriptor();
}
template <> struct is_proto_enum< ::analogic::ancp00::ComputerFault_FAULT_ID> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::analogic::ancp00::ComputerFault_FAULT_ID>() {
  return ::analogic::ancp00::ComputerFault_FAULT_ID_descriptor();
}
template <> struct is_proto_enum< ::analogic::ancp00::InterlockFault_FAULT_ID> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::analogic::ancp00::InterlockFault_FAULT_ID>() {
  return ::analogic::ancp00::InterlockFault_FAULT_ID_descriptor();
}
template <> struct is_proto_enum< ::analogic::ancp00::Fault_FAULT_ID> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::analogic::ancp00::Fault_FAULT_ID>() {
  return ::analogic::ancp00::Fault_FAULT_ID_descriptor();
}
template <> struct is_proto_enum< ::analogic::ancp00::FaultFilterCondition_CONDITION_ID> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::analogic::ancp00::FaultFilterCondition_CONDITION_ID>() {
  return ::analogic::ancp00::FaultFilterCondition_CONDITION_ID_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_proto_2fFault_2eproto__INCLUDED
