// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/AvanconStatus.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "proto/AvanconStatus.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace analogic {
namespace ancp00 {

namespace {

const ::google::protobuf::Descriptor* Motor_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Motor_reflection_ = NULL;
const ::google::protobuf::Descriptor* RfidReader_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RfidReader_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* RfidReader_RfidState_descriptor_ = NULL;
const ::google::protobuf::Descriptor* Sensor_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Sensor_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Sensor_SensorState_descriptor_ = NULL;
const ::google::protobuf::Descriptor* Conveyor_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Conveyor_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Conveyor_ConveyorState_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* Conveyor_DiverterPosition_descriptor_ = NULL;
const ::google::protobuf::Descriptor* AvanconStatusMsg_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AvanconStatusMsg_reflection_ = NULL;
const ::google::protobuf::Descriptor* ConveyorMotorCmd_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ConveyorMotorCmd_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* ConveyorMotorCmd_Command_descriptor_ = NULL;
const ::google::protobuf::Descriptor* ConveyorMotorCmdMsg_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ConveyorMotorCmdMsg_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* ConveyorConfig_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_proto_2fAvanconStatus_2eproto() GOOGLE_ATTRIBUTE_COLD;
void protobuf_AssignDesc_proto_2fAvanconStatus_2eproto() {
  protobuf_AddDesc_proto_2fAvanconStatus_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "proto/AvanconStatus.proto");
  GOOGLE_CHECK(file != NULL);
  Motor_descriptor_ = file->message_type(0);
  static const int Motor_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Motor, addr_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Motor, present_),
  };
  Motor_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Motor_descriptor_,
      Motor::default_instance_,
      Motor_offsets_,
      -1,
      -1,
      -1,
      sizeof(Motor),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Motor, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Motor, _is_default_instance_));
  RfidReader_descriptor_ = file->message_type(1);
  static const int RfidReader_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RfidReader, tag_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RfidReader, state_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RfidReader, ip_addr_),
  };
  RfidReader_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      RfidReader_descriptor_,
      RfidReader::default_instance_,
      RfidReader_offsets_,
      -1,
      -1,
      -1,
      sizeof(RfidReader),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RfidReader, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RfidReader, _is_default_instance_));
  RfidReader_RfidState_descriptor_ = RfidReader_descriptor_->enum_type(0);
  Sensor_descriptor_ = file->message_type(2);
  static const int Sensor_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sensor, sensor_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sensor, state_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sensor, address_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sensor, present_),
  };
  Sensor_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Sensor_descriptor_,
      Sensor::default_instance_,
      Sensor_offsets_,
      -1,
      -1,
      -1,
      sizeof(Sensor),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sensor, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sensor, _is_default_instance_));
  Sensor_SensorState_descriptor_ = Sensor_descriptor_->enum_type(0);
  Conveyor_descriptor_ = file->message_type(3);
  static const int Conveyor_offsets_[11] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Conveyor, zone_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Conveyor, state_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Conveyor, rtr_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Conveyor, rts_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Conveyor, sensor_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Conveyor, motor_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Conveyor, is_diverter_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Conveyor, diverter_pos_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Conveyor, bags_in_zone_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Conveyor, zone_id_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Conveyor, zone_jammed_),
  };
  Conveyor_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Conveyor_descriptor_,
      Conveyor::default_instance_,
      Conveyor_offsets_,
      -1,
      -1,
      -1,
      sizeof(Conveyor),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Conveyor, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Conveyor, _is_default_instance_));
  Conveyor_ConveyorState_descriptor_ = Conveyor_descriptor_->enum_type(0);
  Conveyor_DiverterPosition_descriptor_ = Conveyor_descriptor_->enum_type(1);
  AvanconStatusMsg_descriptor_ = file->message_type(4);
  static const int AvanconStatusMsg_offsets_[39] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AvanconStatusMsg, time_stamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AvanconStatusMsg, bhs_configuration_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AvanconStatusMsg, plc_configuration_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AvanconStatusMsg, plc_version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AvanconStatusMsg, bhs_version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AvanconStatusMsg, conv_config_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AvanconStatusMsg, scanner_state_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AvanconStatusMsg, scanner_substate_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AvanconStatusMsg, bin_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AvanconStatusMsg, last_bhs_fault_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AvanconStatusMsg, plc_state_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AvanconStatusMsg, last_plc_fault_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AvanconStatusMsg, attenuation_distance_mm_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AvanconStatusMsg, attenuation_window_mm_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AvanconStatusMsg, in_dieback_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AvanconStatusMsg, forced_divert_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AvanconStatusMsg, divert_warning_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AvanconStatusMsg, entrance_rfid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AvanconStatusMsg, exit_rfid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AvanconStatusMsg, conveyor_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AvanconStatusMsg, bhs_warning_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AvanconStatusMsg, sensor_warning_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AvanconStatusMsg, z5_exception_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AvanconStatusMsg, z4_longbag_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AvanconStatusMsg, external_warning_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AvanconStatusMsg, total_attenuation_events_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AvanconStatusMsg, total_entrance_events_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AvanconStatusMsg, total_exit_events_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AvanconStatusMsg, total_operator_cleared_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AvanconStatusMsg, total_operator_rejected_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AvanconStatusMsg, total_lost_tracking_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AvanconStatusMsg, total_unlinked_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AvanconStatusMsg, total_entrance_rfid_misreads_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AvanconStatusMsg, total_exit_rfid_misreads_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AvanconStatusMsg, total_oversize_bags_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AvanconStatusMsg, total_cut_bags_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AvanconStatusMsg, master_bag_jam_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AvanconStatusMsg, bag_jam_bits_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AvanconStatusMsg, attenuation_start_buffer_mm_),
  };
  AvanconStatusMsg_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      AvanconStatusMsg_descriptor_,
      AvanconStatusMsg::default_instance_,
      AvanconStatusMsg_offsets_,
      -1,
      -1,
      -1,
      sizeof(AvanconStatusMsg),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AvanconStatusMsg, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AvanconStatusMsg, _is_default_instance_));
  ConveyorMotorCmd_descriptor_ = file->message_type(5);
  static const int ConveyorMotorCmd_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConveyorMotorCmd, zone_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConveyorMotorCmd, is_diverter_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConveyorMotorCmd, divert_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConveyorMotorCmd, cmd_),
  };
  ConveyorMotorCmd_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ConveyorMotorCmd_descriptor_,
      ConveyorMotorCmd::default_instance_,
      ConveyorMotorCmd_offsets_,
      -1,
      -1,
      -1,
      sizeof(ConveyorMotorCmd),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConveyorMotorCmd, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConveyorMotorCmd, _is_default_instance_));
  ConveyorMotorCmd_Command_descriptor_ = ConveyorMotorCmd_descriptor_->enum_type(0);
  ConveyorMotorCmdMsg_descriptor_ = file->message_type(6);
  static const int ConveyorMotorCmdMsg_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConveyorMotorCmdMsg, cmds_),
  };
  ConveyorMotorCmdMsg_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ConveyorMotorCmdMsg_descriptor_,
      ConveyorMotorCmdMsg::default_instance_,
      ConveyorMotorCmdMsg_offsets_,
      -1,
      -1,
      -1,
      sizeof(ConveyorMotorCmdMsg),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConveyorMotorCmdMsg, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConveyorMotorCmdMsg, _is_default_instance_));
  ConveyorConfig_descriptor_ = file->enum_type(0);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_proto_2fAvanconStatus_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) GOOGLE_ATTRIBUTE_COLD;
void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Motor_descriptor_, &Motor::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      RfidReader_descriptor_, &RfidReader::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Sensor_descriptor_, &Sensor::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Conveyor_descriptor_, &Conveyor::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      AvanconStatusMsg_descriptor_, &AvanconStatusMsg::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ConveyorMotorCmd_descriptor_, &ConveyorMotorCmd::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ConveyorMotorCmdMsg_descriptor_, &ConveyorMotorCmdMsg::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_proto_2fAvanconStatus_2eproto() {
  delete Motor::default_instance_;
  delete Motor_reflection_;
  delete RfidReader::default_instance_;
  delete RfidReader_reflection_;
  delete Sensor::default_instance_;
  delete Sensor_reflection_;
  delete Conveyor::default_instance_;
  delete Conveyor_reflection_;
  delete AvanconStatusMsg::default_instance_;
  delete AvanconStatusMsg_reflection_;
  delete ConveyorMotorCmd::default_instance_;
  delete ConveyorMotorCmd_reflection_;
  delete ConveyorMotorCmdMsg::default_instance_;
  delete ConveyorMotorCmdMsg_reflection_;
}

void protobuf_AddDesc_proto_2fAvanconStatus_2eproto() GOOGLE_ATTRIBUTE_COLD;
void protobuf_AddDesc_proto_2fAvanconStatus_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::analogic::ancp00::protobuf_AddDesc_proto_2fSubsystemIds_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\031proto/AvanconStatus.proto\022\017analogic.an"
    "cp00\032\030proto/SubsystemIds.proto\"&\n\005Motor\022"
    "\014\n\004addr\030\001 \001(\t\022\017\n\007present\030\002 \001(\010\"\217\001\n\nRfidR"
    "eader\022\013\n\003tag\030\001 \001(\t\0224\n\005state\030\002 \001(\0162%.anal"
    "ogic.ancp00.RfidReader.RfidState\022\017\n\007ip_a"
    "ddr\030\003 \001(\t\"-\n\tRfidState\022\013\n\007UNKNOWN\020\000\022\t\n\005F"
    "AULT\020\001\022\010\n\004GOOD\020\002\"\251\001\n\006Sensor\022\021\n\tsensor_id"
    "\030\002 \001(\005\0222\n\005state\030\003 \001(\0162#.analogic.ancp00."
    "Sensor.SensorState\022\017\n\007address\030\004 \001(\t\022\017\n\007p"
    "resent\030\005 \001(\010\"6\n\013SensorState\022\013\n\007UNKNOWN\020\000"
    "\022\013\n\007BLOCKED\020\001\022\r\n\tUNBLOCKED\020\002\"\320\003\n\010Conveyo"
    "r\022\017\n\007zone_id\030\001 \001(\005\0226\n\005state\030\002 \001(\0162\'.anal"
    "ogic.ancp00.Conveyor.ConveyorState\022\013\n\003rt"
    "r\030\003 \001(\010\022\013\n\003rts\030\004 \001(\010\022\'\n\006sensor\030\005 \003(\0132\027.a"
    "nalogic.ancp00.Sensor\022%\n\005motor\030\006 \003(\0132\026.a"
    "nalogic.ancp00.Motor\022\023\n\013is_diverter\030\007 \001("
    "\010\022@\n\014diverter_pos\030\010 \001(\0162*.analogic.ancp0"
    "0.Conveyor.DiverterPosition\022\024\n\014bags_in_z"
    "one\030\t \001(\005\022\024\n\014zone_id_name\030\n \001(\t\022\023\n\013zone_"
    "jammed\030\013 \001(\010\"6\n\rConveyorState\022\013\n\007UNKNOWN"
    "\020\000\022\013\n\007STOPPED\020\001\022\013\n\007RUNNING\020\002\"A\n\020Diverter"
    "Position\022\t\n\005DEG_0\020\000\022\n\n\006DEG_30\020\001\022\n\n\006DEG_4"
    "5\020\002\022\n\n\006DEG_90\020\003\"\351\010\n\020AvanconStatusMsg\022\022\n\n"
    "time_stamp\030\001 \001(\t\022\031\n\021bhs_configuration\030\002 "
    "\001(\005\022\031\n\021plc_configuration\030\003 \001(\005\022\023\n\013plc_ve"
    "rsion\030\004 \001(\t\022\023\n\013bhs_version\030\005 \001(\t\0224\n\013conv"
    "_config\030\006 \001(\0162\037.analogic.ancp00.Conveyor"
    "Config\022\025\n\rscanner_state\030\007 \001(\t\022\030\n\020scanner"
    "_substate\030\010 \001(\t\022\020\n\010bin_type\030\t \001(\t\022\026\n\016las"
    "t_bhs_fault\030\n \001(\t\022\021\n\tplc_state\030\013 \001(\t\022\026\n\016"
    "last_plc_fault\030\014 \001(\t\022\037\n\027attenuation_dist"
    "ance_mm\030\r \001(\005\022\035\n\025attenuation_window_mm\030\016"
    " \001(\005\022\022\n\nin_dieback\030\017 \001(\010\022\025\n\rforced_diver"
    "t\030\020 \001(\010\022\026\n\016divert_warning\030\021 \001(\010\0222\n\rentra"
    "nce_rfid\030\022 \001(\0132\033.analogic.ancp00.RfidRea"
    "der\022.\n\texit_rfid\030\023 \001(\0132\033.analogic.ancp00"
    ".RfidReader\022+\n\010conveyor\030\024 \003(\0132\031.analogic"
    ".ancp00.Conveyor\022\023\n\013bhs_warning\030\025 \001(\010\022\026\n"
    "\016sensor_warning\030\026 \001(\010\022\024\n\014Z5_exception\030\027 "
    "\001(\010\022\022\n\nZ4_longbag\030\030 \001(\010\022\030\n\020external_warn"
    "ing\030\031 \001(\010\022 \n\030total_attenuation_events\030\032 "
    "\001(\005\022\035\n\025total_entrance_events\030\033 \001(\005\022\031\n\021to"
    "tal_exit_events\030\034 \001(\005\022\036\n\026total_operator_"
    "cleared\030\035 \001(\005\022\037\n\027total_operator_rejected"
    "\030\036 \001(\005\022\033\n\023total_lost_tracking\030\037 \001(\005\022\026\n\016t"
    "otal_unlinked\030  \001(\005\022$\n\034total_entrance_rf"
    "id_misreads\030! \001(\005\022 \n\030total_exit_rfid_mis"
    "reads\030\" \001(\005\022\033\n\023total_oversize_bags\030# \001(\005"
    "\022\026\n\016total_cut_bags\030$ \001(\005\022\026\n\016master_bag_j"
    "am\030% \001(\010\022\024\n\014bag_jam_bits\030& \001(\005\022#\n\033attenu"
    "ation_start_buffer_mm\030\' \001(\005\"\272\001\n\020Conveyor"
    "MotorCmd\022\017\n\007zone_id\030\001 \001(\005\022\023\n\013is_diverter"
    "\030\002 \001(\010\022\016\n\006divert\030\003 \001(\010\0226\n\003cmd\030\004 \001(\0162).an"
    "alogic.ancp00.ConveyorMotorCmd.Command\"8"
    "\n\007Command\022\007\n\003RUN\020\000\022\010\n\004STOP\020\001\022\t\n\005RESET\020\002\022"
    "\017\n\013RUN_REVERSE\020\003\"F\n\023ConveyorMotorCmdMsg\022"
    "/\n\004cmds\030\001 \003(\0132!.analogic.ancp00.Conveyor"
    "MotorCmd*/\n\016ConveyorConfig\022\r\n\tLEFT_HAND\020"
    "\000\022\016\n\nRIGHT_HAND\020\001b\006proto3", 2345);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "proto/AvanconStatus.proto", &protobuf_RegisterTypes);
  Motor::default_instance_ = new Motor();
  RfidReader::default_instance_ = new RfidReader();
  Sensor::default_instance_ = new Sensor();
  Conveyor::default_instance_ = new Conveyor();
  AvanconStatusMsg::default_instance_ = new AvanconStatusMsg();
  ConveyorMotorCmd::default_instance_ = new ConveyorMotorCmd();
  ConveyorMotorCmdMsg::default_instance_ = new ConveyorMotorCmdMsg();
  Motor::default_instance_->InitAsDefaultInstance();
  RfidReader::default_instance_->InitAsDefaultInstance();
  Sensor::default_instance_->InitAsDefaultInstance();
  Conveyor::default_instance_->InitAsDefaultInstance();
  AvanconStatusMsg::default_instance_->InitAsDefaultInstance();
  ConveyorMotorCmd::default_instance_->InitAsDefaultInstance();
  ConveyorMotorCmdMsg::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_proto_2fAvanconStatus_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_proto_2fAvanconStatus_2eproto {
  StaticDescriptorInitializer_proto_2fAvanconStatus_2eproto() {
    protobuf_AddDesc_proto_2fAvanconStatus_2eproto();
  }
} static_descriptor_initializer_proto_2fAvanconStatus_2eproto_;
const ::google::protobuf::EnumDescriptor* ConveyorConfig_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ConveyorConfig_descriptor_;
}
bool ConveyorConfig_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Motor::kAddrFieldNumber;
const int Motor::kPresentFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Motor::Motor()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:analogic.ancp00.Motor)
}

void Motor::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

Motor::Motor(const Motor& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:analogic.ancp00.Motor)
}

void Motor::SharedCtor() {
    _is_default_instance_ = false;
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  addr_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  present_ = false;
}

Motor::~Motor() {
  // @@protoc_insertion_point(destructor:analogic.ancp00.Motor)
  SharedDtor();
}

void Motor::SharedDtor() {
  addr_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void Motor::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Motor::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Motor_descriptor_;
}

const Motor& Motor::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_proto_2fAvanconStatus_2eproto();
  return *default_instance_;
}

Motor* Motor::default_instance_ = NULL;

Motor* Motor::New(::google::protobuf::Arena* arena) const {
  Motor* n = new Motor;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Motor::Clear() {
// @@protoc_insertion_point(message_clear_start:analogic.ancp00.Motor)
  addr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  present_ = false;
}

bool Motor::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:analogic.ancp00.Motor)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string addr = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_addr()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->addr().data(), this->addr().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "analogic.ancp00.Motor.addr"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_present;
        break;
      }

      // optional bool present = 2;
      case 2: {
        if (tag == 16) {
         parse_present:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &present_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:analogic.ancp00.Motor)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:analogic.ancp00.Motor)
  return false;
#undef DO_
}

void Motor::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:analogic.ancp00.Motor)
  // optional string addr = 1;
  if (this->addr().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->addr().data(), this->addr().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "analogic.ancp00.Motor.addr");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->addr(), output);
  }

  // optional bool present = 2;
  if (this->present() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->present(), output);
  }

  // @@protoc_insertion_point(serialize_end:analogic.ancp00.Motor)
}

::google::protobuf::uint8* Motor::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:analogic.ancp00.Motor)
  // optional string addr = 1;
  if (this->addr().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->addr().data(), this->addr().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "analogic.ancp00.Motor.addr");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->addr(), target);
  }

  // optional bool present = 2;
  if (this->present() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->present(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:analogic.ancp00.Motor)
  return target;
}

int Motor::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:analogic.ancp00.Motor)
  int total_size = 0;

  // optional string addr = 1;
  if (this->addr().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->addr());
  }

  // optional bool present = 2;
  if (this->present() != 0) {
    total_size += 1 + 1;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Motor::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:analogic.ancp00.Motor)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Motor* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Motor>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:analogic.ancp00.Motor)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:analogic.ancp00.Motor)
    MergeFrom(*source);
  }
}

void Motor::MergeFrom(const Motor& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:analogic.ancp00.Motor)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from.addr().size() > 0) {

    addr_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.addr_);
  }
  if (from.present() != 0) {
    set_present(from.present());
  }
}

void Motor::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:analogic.ancp00.Motor)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Motor::CopyFrom(const Motor& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:analogic.ancp00.Motor)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Motor::IsInitialized() const {

  return true;
}

void Motor::Swap(Motor* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Motor::InternalSwap(Motor* other) {
  addr_.Swap(&other->addr_);
  std::swap(present_, other->present_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Motor::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Motor_descriptor_;
  metadata.reflection = Motor_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Motor

// optional string addr = 1;
void Motor::clear_addr() {
  addr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& Motor::addr() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.Motor.addr)
  return addr_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Motor::set_addr(const ::std::string& value) {
  
  addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:analogic.ancp00.Motor.addr)
}
 void Motor::set_addr(const char* value) {
  
  addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:analogic.ancp00.Motor.addr)
}
 void Motor::set_addr(const char* value, size_t size) {
  
  addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:analogic.ancp00.Motor.addr)
}
 ::std::string* Motor::mutable_addr() {
  
  // @@protoc_insertion_point(field_mutable:analogic.ancp00.Motor.addr)
  return addr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Motor::release_addr() {
  // @@protoc_insertion_point(field_release:analogic.ancp00.Motor.addr)
  
  return addr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Motor::set_allocated_addr(::std::string* addr) {
  if (addr != NULL) {
    
  } else {
    
  }
  addr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), addr);
  // @@protoc_insertion_point(field_set_allocated:analogic.ancp00.Motor.addr)
}

// optional bool present = 2;
void Motor::clear_present() {
  present_ = false;
}
 bool Motor::present() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.Motor.present)
  return present_;
}
 void Motor::set_present(bool value) {
  
  present_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.Motor.present)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

const ::google::protobuf::EnumDescriptor* RfidReader_RfidState_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RfidReader_RfidState_descriptor_;
}
bool RfidReader_RfidState_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const RfidReader_RfidState RfidReader::UNKNOWN;
const RfidReader_RfidState RfidReader::FAULT;
const RfidReader_RfidState RfidReader::GOOD;
const RfidReader_RfidState RfidReader::RfidState_MIN;
const RfidReader_RfidState RfidReader::RfidState_MAX;
const int RfidReader::RfidState_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RfidReader::kTagFieldNumber;
const int RfidReader::kStateFieldNumber;
const int RfidReader::kIpAddrFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RfidReader::RfidReader()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:analogic.ancp00.RfidReader)
}

void RfidReader::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

RfidReader::RfidReader(const RfidReader& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:analogic.ancp00.RfidReader)
}

void RfidReader::SharedCtor() {
    _is_default_instance_ = false;
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  tag_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  state_ = 0;
  ip_addr_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

RfidReader::~RfidReader() {
  // @@protoc_insertion_point(destructor:analogic.ancp00.RfidReader)
  SharedDtor();
}

void RfidReader::SharedDtor() {
  tag_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ip_addr_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void RfidReader::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RfidReader::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RfidReader_descriptor_;
}

const RfidReader& RfidReader::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_proto_2fAvanconStatus_2eproto();
  return *default_instance_;
}

RfidReader* RfidReader::default_instance_ = NULL;

RfidReader* RfidReader::New(::google::protobuf::Arena* arena) const {
  RfidReader* n = new RfidReader;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RfidReader::Clear() {
// @@protoc_insertion_point(message_clear_start:analogic.ancp00.RfidReader)
  tag_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  state_ = 0;
  ip_addr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool RfidReader::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:analogic.ancp00.RfidReader)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string tag = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_tag()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->tag().data(), this->tag().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "analogic.ancp00.RfidReader.tag"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_state;
        break;
      }

      // optional .analogic.ancp00.RfidReader.RfidState state = 2;
      case 2: {
        if (tag == 16) {
         parse_state:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_state(static_cast< ::analogic::ancp00::RfidReader_RfidState >(value));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_ip_addr;
        break;
      }

      // optional string ip_addr = 3;
      case 3: {
        if (tag == 26) {
         parse_ip_addr:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_ip_addr()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->ip_addr().data(), this->ip_addr().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "analogic.ancp00.RfidReader.ip_addr"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:analogic.ancp00.RfidReader)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:analogic.ancp00.RfidReader)
  return false;
#undef DO_
}

void RfidReader::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:analogic.ancp00.RfidReader)
  // optional string tag = 1;
  if (this->tag().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->tag().data(), this->tag().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "analogic.ancp00.RfidReader.tag");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->tag(), output);
  }

  // optional .analogic.ancp00.RfidReader.RfidState state = 2;
  if (this->state() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->state(), output);
  }

  // optional string ip_addr = 3;
  if (this->ip_addr().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->ip_addr().data(), this->ip_addr().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "analogic.ancp00.RfidReader.ip_addr");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->ip_addr(), output);
  }

  // @@protoc_insertion_point(serialize_end:analogic.ancp00.RfidReader)
}

::google::protobuf::uint8* RfidReader::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:analogic.ancp00.RfidReader)
  // optional string tag = 1;
  if (this->tag().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->tag().data(), this->tag().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "analogic.ancp00.RfidReader.tag");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->tag(), target);
  }

  // optional .analogic.ancp00.RfidReader.RfidState state = 2;
  if (this->state() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->state(), target);
  }

  // optional string ip_addr = 3;
  if (this->ip_addr().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->ip_addr().data(), this->ip_addr().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "analogic.ancp00.RfidReader.ip_addr");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->ip_addr(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:analogic.ancp00.RfidReader)
  return target;
}

int RfidReader::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:analogic.ancp00.RfidReader)
  int total_size = 0;

  // optional string tag = 1;
  if (this->tag().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->tag());
  }

  // optional .analogic.ancp00.RfidReader.RfidState state = 2;
  if (this->state() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->state());
  }

  // optional string ip_addr = 3;
  if (this->ip_addr().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->ip_addr());
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RfidReader::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:analogic.ancp00.RfidReader)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const RfidReader* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const RfidReader>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:analogic.ancp00.RfidReader)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:analogic.ancp00.RfidReader)
    MergeFrom(*source);
  }
}

void RfidReader::MergeFrom(const RfidReader& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:analogic.ancp00.RfidReader)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from.tag().size() > 0) {

    tag_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.tag_);
  }
  if (from.state() != 0) {
    set_state(from.state());
  }
  if (from.ip_addr().size() > 0) {

    ip_addr_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.ip_addr_);
  }
}

void RfidReader::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:analogic.ancp00.RfidReader)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RfidReader::CopyFrom(const RfidReader& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:analogic.ancp00.RfidReader)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RfidReader::IsInitialized() const {

  return true;
}

void RfidReader::Swap(RfidReader* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RfidReader::InternalSwap(RfidReader* other) {
  tag_.Swap(&other->tag_);
  std::swap(state_, other->state_);
  ip_addr_.Swap(&other->ip_addr_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata RfidReader::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RfidReader_descriptor_;
  metadata.reflection = RfidReader_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RfidReader

// optional string tag = 1;
void RfidReader::clear_tag() {
  tag_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& RfidReader::tag() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.RfidReader.tag)
  return tag_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void RfidReader::set_tag(const ::std::string& value) {
  
  tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:analogic.ancp00.RfidReader.tag)
}
 void RfidReader::set_tag(const char* value) {
  
  tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:analogic.ancp00.RfidReader.tag)
}
 void RfidReader::set_tag(const char* value, size_t size) {
  
  tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:analogic.ancp00.RfidReader.tag)
}
 ::std::string* RfidReader::mutable_tag() {
  
  // @@protoc_insertion_point(field_mutable:analogic.ancp00.RfidReader.tag)
  return tag_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* RfidReader::release_tag() {
  // @@protoc_insertion_point(field_release:analogic.ancp00.RfidReader.tag)
  
  return tag_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void RfidReader::set_allocated_tag(::std::string* tag) {
  if (tag != NULL) {
    
  } else {
    
  }
  tag_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tag);
  // @@protoc_insertion_point(field_set_allocated:analogic.ancp00.RfidReader.tag)
}

// optional .analogic.ancp00.RfidReader.RfidState state = 2;
void RfidReader::clear_state() {
  state_ = 0;
}
 ::analogic::ancp00::RfidReader_RfidState RfidReader::state() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.RfidReader.state)
  return static_cast< ::analogic::ancp00::RfidReader_RfidState >(state_);
}
 void RfidReader::set_state(::analogic::ancp00::RfidReader_RfidState value) {
  
  state_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.RfidReader.state)
}

// optional string ip_addr = 3;
void RfidReader::clear_ip_addr() {
  ip_addr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& RfidReader::ip_addr() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.RfidReader.ip_addr)
  return ip_addr_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void RfidReader::set_ip_addr(const ::std::string& value) {
  
  ip_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:analogic.ancp00.RfidReader.ip_addr)
}
 void RfidReader::set_ip_addr(const char* value) {
  
  ip_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:analogic.ancp00.RfidReader.ip_addr)
}
 void RfidReader::set_ip_addr(const char* value, size_t size) {
  
  ip_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:analogic.ancp00.RfidReader.ip_addr)
}
 ::std::string* RfidReader::mutable_ip_addr() {
  
  // @@protoc_insertion_point(field_mutable:analogic.ancp00.RfidReader.ip_addr)
  return ip_addr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* RfidReader::release_ip_addr() {
  // @@protoc_insertion_point(field_release:analogic.ancp00.RfidReader.ip_addr)
  
  return ip_addr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void RfidReader::set_allocated_ip_addr(::std::string* ip_addr) {
  if (ip_addr != NULL) {
    
  } else {
    
  }
  ip_addr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip_addr);
  // @@protoc_insertion_point(field_set_allocated:analogic.ancp00.RfidReader.ip_addr)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

const ::google::protobuf::EnumDescriptor* Sensor_SensorState_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Sensor_SensorState_descriptor_;
}
bool Sensor_SensorState_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const Sensor_SensorState Sensor::UNKNOWN;
const Sensor_SensorState Sensor::BLOCKED;
const Sensor_SensorState Sensor::UNBLOCKED;
const Sensor_SensorState Sensor::SensorState_MIN;
const Sensor_SensorState Sensor::SensorState_MAX;
const int Sensor::SensorState_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Sensor::kSensorIdFieldNumber;
const int Sensor::kStateFieldNumber;
const int Sensor::kAddressFieldNumber;
const int Sensor::kPresentFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Sensor::Sensor()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:analogic.ancp00.Sensor)
}

void Sensor::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

Sensor::Sensor(const Sensor& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:analogic.ancp00.Sensor)
}

void Sensor::SharedCtor() {
    _is_default_instance_ = false;
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  sensor_id_ = 0;
  state_ = 0;
  address_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  present_ = false;
}

Sensor::~Sensor() {
  // @@protoc_insertion_point(destructor:analogic.ancp00.Sensor)
  SharedDtor();
}

void Sensor::SharedDtor() {
  address_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void Sensor::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Sensor::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Sensor_descriptor_;
}

const Sensor& Sensor::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_proto_2fAvanconStatus_2eproto();
  return *default_instance_;
}

Sensor* Sensor::default_instance_ = NULL;

Sensor* Sensor::New(::google::protobuf::Arena* arena) const {
  Sensor* n = new Sensor;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Sensor::Clear() {
// @@protoc_insertion_point(message_clear_start:analogic.ancp00.Sensor)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(Sensor, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Sensor*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(sensor_id_, state_);
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  present_ = false;

#undef ZR_HELPER_
#undef ZR_

}

bool Sensor::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:analogic.ancp00.Sensor)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 sensor_id = 2;
      case 2: {
        if (tag == 16) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &sensor_id_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_state;
        break;
      }

      // optional .analogic.ancp00.Sensor.SensorState state = 3;
      case 3: {
        if (tag == 24) {
         parse_state:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_state(static_cast< ::analogic::ancp00::Sensor_SensorState >(value));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_address;
        break;
      }

      // optional string address = 4;
      case 4: {
        if (tag == 34) {
         parse_address:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_address()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->address().data(), this->address().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "analogic.ancp00.Sensor.address"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_present;
        break;
      }

      // optional bool present = 5;
      case 5: {
        if (tag == 40) {
         parse_present:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &present_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:analogic.ancp00.Sensor)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:analogic.ancp00.Sensor)
  return false;
#undef DO_
}

void Sensor::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:analogic.ancp00.Sensor)
  // optional int32 sensor_id = 2;
  if (this->sensor_id() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->sensor_id(), output);
  }

  // optional .analogic.ancp00.Sensor.SensorState state = 3;
  if (this->state() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->state(), output);
  }

  // optional string address = 4;
  if (this->address().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->address().data(), this->address().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "analogic.ancp00.Sensor.address");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->address(), output);
  }

  // optional bool present = 5;
  if (this->present() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->present(), output);
  }

  // @@protoc_insertion_point(serialize_end:analogic.ancp00.Sensor)
}

::google::protobuf::uint8* Sensor::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:analogic.ancp00.Sensor)
  // optional int32 sensor_id = 2;
  if (this->sensor_id() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->sensor_id(), target);
  }

  // optional .analogic.ancp00.Sensor.SensorState state = 3;
  if (this->state() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->state(), target);
  }

  // optional string address = 4;
  if (this->address().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->address().data(), this->address().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "analogic.ancp00.Sensor.address");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->address(), target);
  }

  // optional bool present = 5;
  if (this->present() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(5, this->present(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:analogic.ancp00.Sensor)
  return target;
}

int Sensor::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:analogic.ancp00.Sensor)
  int total_size = 0;

  // optional int32 sensor_id = 2;
  if (this->sensor_id() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->sensor_id());
  }

  // optional .analogic.ancp00.Sensor.SensorState state = 3;
  if (this->state() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->state());
  }

  // optional string address = 4;
  if (this->address().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->address());
  }

  // optional bool present = 5;
  if (this->present() != 0) {
    total_size += 1 + 1;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Sensor::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:analogic.ancp00.Sensor)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Sensor* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Sensor>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:analogic.ancp00.Sensor)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:analogic.ancp00.Sensor)
    MergeFrom(*source);
  }
}

void Sensor::MergeFrom(const Sensor& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:analogic.ancp00.Sensor)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from.sensor_id() != 0) {
    set_sensor_id(from.sensor_id());
  }
  if (from.state() != 0) {
    set_state(from.state());
  }
  if (from.address().size() > 0) {

    address_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.address_);
  }
  if (from.present() != 0) {
    set_present(from.present());
  }
}

void Sensor::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:analogic.ancp00.Sensor)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Sensor::CopyFrom(const Sensor& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:analogic.ancp00.Sensor)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Sensor::IsInitialized() const {

  return true;
}

void Sensor::Swap(Sensor* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Sensor::InternalSwap(Sensor* other) {
  std::swap(sensor_id_, other->sensor_id_);
  std::swap(state_, other->state_);
  address_.Swap(&other->address_);
  std::swap(present_, other->present_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Sensor::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Sensor_descriptor_;
  metadata.reflection = Sensor_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Sensor

// optional int32 sensor_id = 2;
void Sensor::clear_sensor_id() {
  sensor_id_ = 0;
}
 ::google::protobuf::int32 Sensor::sensor_id() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.Sensor.sensor_id)
  return sensor_id_;
}
 void Sensor::set_sensor_id(::google::protobuf::int32 value) {
  
  sensor_id_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.Sensor.sensor_id)
}

// optional .analogic.ancp00.Sensor.SensorState state = 3;
void Sensor::clear_state() {
  state_ = 0;
}
 ::analogic::ancp00::Sensor_SensorState Sensor::state() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.Sensor.state)
  return static_cast< ::analogic::ancp00::Sensor_SensorState >(state_);
}
 void Sensor::set_state(::analogic::ancp00::Sensor_SensorState value) {
  
  state_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.Sensor.state)
}

// optional string address = 4;
void Sensor::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& Sensor::address() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.Sensor.address)
  return address_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Sensor::set_address(const ::std::string& value) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:analogic.ancp00.Sensor.address)
}
 void Sensor::set_address(const char* value) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:analogic.ancp00.Sensor.address)
}
 void Sensor::set_address(const char* value, size_t size) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:analogic.ancp00.Sensor.address)
}
 ::std::string* Sensor::mutable_address() {
  
  // @@protoc_insertion_point(field_mutable:analogic.ancp00.Sensor.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Sensor::release_address() {
  // @@protoc_insertion_point(field_release:analogic.ancp00.Sensor.address)
  
  return address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Sensor::set_allocated_address(::std::string* address) {
  if (address != NULL) {
    
  } else {
    
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:analogic.ancp00.Sensor.address)
}

// optional bool present = 5;
void Sensor::clear_present() {
  present_ = false;
}
 bool Sensor::present() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.Sensor.present)
  return present_;
}
 void Sensor::set_present(bool value) {
  
  present_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.Sensor.present)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

const ::google::protobuf::EnumDescriptor* Conveyor_ConveyorState_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Conveyor_ConveyorState_descriptor_;
}
bool Conveyor_ConveyorState_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const Conveyor_ConveyorState Conveyor::UNKNOWN;
const Conveyor_ConveyorState Conveyor::STOPPED;
const Conveyor_ConveyorState Conveyor::RUNNING;
const Conveyor_ConveyorState Conveyor::ConveyorState_MIN;
const Conveyor_ConveyorState Conveyor::ConveyorState_MAX;
const int Conveyor::ConveyorState_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
const ::google::protobuf::EnumDescriptor* Conveyor_DiverterPosition_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Conveyor_DiverterPosition_descriptor_;
}
bool Conveyor_DiverterPosition_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const Conveyor_DiverterPosition Conveyor::DEG_0;
const Conveyor_DiverterPosition Conveyor::DEG_30;
const Conveyor_DiverterPosition Conveyor::DEG_45;
const Conveyor_DiverterPosition Conveyor::DEG_90;
const Conveyor_DiverterPosition Conveyor::DiverterPosition_MIN;
const Conveyor_DiverterPosition Conveyor::DiverterPosition_MAX;
const int Conveyor::DiverterPosition_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Conveyor::kZoneIdFieldNumber;
const int Conveyor::kStateFieldNumber;
const int Conveyor::kRtrFieldNumber;
const int Conveyor::kRtsFieldNumber;
const int Conveyor::kSensorFieldNumber;
const int Conveyor::kMotorFieldNumber;
const int Conveyor::kIsDiverterFieldNumber;
const int Conveyor::kDiverterPosFieldNumber;
const int Conveyor::kBagsInZoneFieldNumber;
const int Conveyor::kZoneIdNameFieldNumber;
const int Conveyor::kZoneJammedFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Conveyor::Conveyor()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:analogic.ancp00.Conveyor)
}

void Conveyor::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

Conveyor::Conveyor(const Conveyor& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:analogic.ancp00.Conveyor)
}

void Conveyor::SharedCtor() {
    _is_default_instance_ = false;
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  zone_id_ = 0;
  state_ = 0;
  rtr_ = false;
  rts_ = false;
  is_diverter_ = false;
  diverter_pos_ = 0;
  bags_in_zone_ = 0;
  zone_id_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  zone_jammed_ = false;
}

Conveyor::~Conveyor() {
  // @@protoc_insertion_point(destructor:analogic.ancp00.Conveyor)
  SharedDtor();
}

void Conveyor::SharedDtor() {
  zone_id_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void Conveyor::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Conveyor::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Conveyor_descriptor_;
}

const Conveyor& Conveyor::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_proto_2fAvanconStatus_2eproto();
  return *default_instance_;
}

Conveyor* Conveyor::default_instance_ = NULL;

Conveyor* Conveyor::New(::google::protobuf::Arena* arena) const {
  Conveyor* n = new Conveyor;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Conveyor::Clear() {
// @@protoc_insertion_point(message_clear_start:analogic.ancp00.Conveyor)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(Conveyor, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Conveyor*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(zone_id_, state_);
  ZR_(rtr_, is_diverter_);
  diverter_pos_ = 0;
  bags_in_zone_ = 0;
  zone_id_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  zone_jammed_ = false;

#undef ZR_HELPER_
#undef ZR_

  sensor_.Clear();
  motor_.Clear();
}

bool Conveyor::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:analogic.ancp00.Conveyor)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 zone_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &zone_id_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_state;
        break;
      }

      // optional .analogic.ancp00.Conveyor.ConveyorState state = 2;
      case 2: {
        if (tag == 16) {
         parse_state:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_state(static_cast< ::analogic::ancp00::Conveyor_ConveyorState >(value));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_rtr;
        break;
      }

      // optional bool rtr = 3;
      case 3: {
        if (tag == 24) {
         parse_rtr:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &rtr_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_rts;
        break;
      }

      // optional bool rts = 4;
      case 4: {
        if (tag == 32) {
         parse_rts:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &rts_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_sensor;
        break;
      }

      // repeated .analogic.ancp00.Sensor sensor = 5;
      case 5: {
        if (tag == 42) {
         parse_sensor:
          DO_(input->IncrementRecursionDepth());
         parse_loop_sensor:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_sensor()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_loop_sensor;
        if (input->ExpectTag(50)) goto parse_loop_motor;
        input->UnsafeDecrementRecursionDepth();
        break;
      }

      // repeated .analogic.ancp00.Motor motor = 6;
      case 6: {
        if (tag == 50) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_motor:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_motor()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_loop_motor;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectTag(56)) goto parse_is_diverter;
        break;
      }

      // optional bool is_diverter = 7;
      case 7: {
        if (tag == 56) {
         parse_is_diverter:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_diverter_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_diverter_pos;
        break;
      }

      // optional .analogic.ancp00.Conveyor.DiverterPosition diverter_pos = 8;
      case 8: {
        if (tag == 64) {
         parse_diverter_pos:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_diverter_pos(static_cast< ::analogic::ancp00::Conveyor_DiverterPosition >(value));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_bags_in_zone;
        break;
      }

      // optional int32 bags_in_zone = 9;
      case 9: {
        if (tag == 72) {
         parse_bags_in_zone:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &bags_in_zone_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(82)) goto parse_zone_id_name;
        break;
      }

      // optional string zone_id_name = 10;
      case 10: {
        if (tag == 82) {
         parse_zone_id_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_zone_id_name()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->zone_id_name().data(), this->zone_id_name().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "analogic.ancp00.Conveyor.zone_id_name"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(88)) goto parse_zone_jammed;
        break;
      }

      // optional bool zone_jammed = 11;
      case 11: {
        if (tag == 88) {
         parse_zone_jammed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &zone_jammed_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:analogic.ancp00.Conveyor)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:analogic.ancp00.Conveyor)
  return false;
#undef DO_
}

void Conveyor::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:analogic.ancp00.Conveyor)
  // optional int32 zone_id = 1;
  if (this->zone_id() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->zone_id(), output);
  }

  // optional .analogic.ancp00.Conveyor.ConveyorState state = 2;
  if (this->state() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->state(), output);
  }

  // optional bool rtr = 3;
  if (this->rtr() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->rtr(), output);
  }

  // optional bool rts = 4;
  if (this->rts() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->rts(), output);
  }

  // repeated .analogic.ancp00.Sensor sensor = 5;
  for (unsigned int i = 0, n = this->sensor_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->sensor(i), output);
  }

  // repeated .analogic.ancp00.Motor motor = 6;
  for (unsigned int i = 0, n = this->motor_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->motor(i), output);
  }

  // optional bool is_diverter = 7;
  if (this->is_diverter() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(7, this->is_diverter(), output);
  }

  // optional .analogic.ancp00.Conveyor.DiverterPosition diverter_pos = 8;
  if (this->diverter_pos() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      8, this->diverter_pos(), output);
  }

  // optional int32 bags_in_zone = 9;
  if (this->bags_in_zone() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(9, this->bags_in_zone(), output);
  }

  // optional string zone_id_name = 10;
  if (this->zone_id_name().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->zone_id_name().data(), this->zone_id_name().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "analogic.ancp00.Conveyor.zone_id_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      10, this->zone_id_name(), output);
  }

  // optional bool zone_jammed = 11;
  if (this->zone_jammed() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(11, this->zone_jammed(), output);
  }

  // @@protoc_insertion_point(serialize_end:analogic.ancp00.Conveyor)
}

::google::protobuf::uint8* Conveyor::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:analogic.ancp00.Conveyor)
  // optional int32 zone_id = 1;
  if (this->zone_id() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->zone_id(), target);
  }

  // optional .analogic.ancp00.Conveyor.ConveyorState state = 2;
  if (this->state() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->state(), target);
  }

  // optional bool rtr = 3;
  if (this->rtr() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->rtr(), target);
  }

  // optional bool rts = 4;
  if (this->rts() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->rts(), target);
  }

  // repeated .analogic.ancp00.Sensor sensor = 5;
  for (unsigned int i = 0, n = this->sensor_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        5, this->sensor(i), false, target);
  }

  // repeated .analogic.ancp00.Motor motor = 6;
  for (unsigned int i = 0, n = this->motor_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        6, this->motor(i), false, target);
  }

  // optional bool is_diverter = 7;
  if (this->is_diverter() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(7, this->is_diverter(), target);
  }

  // optional .analogic.ancp00.Conveyor.DiverterPosition diverter_pos = 8;
  if (this->diverter_pos() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      8, this->diverter_pos(), target);
  }

  // optional int32 bags_in_zone = 9;
  if (this->bags_in_zone() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(9, this->bags_in_zone(), target);
  }

  // optional string zone_id_name = 10;
  if (this->zone_id_name().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->zone_id_name().data(), this->zone_id_name().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "analogic.ancp00.Conveyor.zone_id_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        10, this->zone_id_name(), target);
  }

  // optional bool zone_jammed = 11;
  if (this->zone_jammed() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(11, this->zone_jammed(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:analogic.ancp00.Conveyor)
  return target;
}

int Conveyor::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:analogic.ancp00.Conveyor)
  int total_size = 0;

  // optional int32 zone_id = 1;
  if (this->zone_id() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->zone_id());
  }

  // optional .analogic.ancp00.Conveyor.ConveyorState state = 2;
  if (this->state() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->state());
  }

  // optional bool rtr = 3;
  if (this->rtr() != 0) {
    total_size += 1 + 1;
  }

  // optional bool rts = 4;
  if (this->rts() != 0) {
    total_size += 1 + 1;
  }

  // optional bool is_diverter = 7;
  if (this->is_diverter() != 0) {
    total_size += 1 + 1;
  }

  // optional .analogic.ancp00.Conveyor.DiverterPosition diverter_pos = 8;
  if (this->diverter_pos() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->diverter_pos());
  }

  // optional int32 bags_in_zone = 9;
  if (this->bags_in_zone() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->bags_in_zone());
  }

  // optional string zone_id_name = 10;
  if (this->zone_id_name().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->zone_id_name());
  }

  // optional bool zone_jammed = 11;
  if (this->zone_jammed() != 0) {
    total_size += 1 + 1;
  }

  // repeated .analogic.ancp00.Sensor sensor = 5;
  total_size += 1 * this->sensor_size();
  for (int i = 0; i < this->sensor_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->sensor(i));
  }

  // repeated .analogic.ancp00.Motor motor = 6;
  total_size += 1 * this->motor_size();
  for (int i = 0; i < this->motor_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->motor(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Conveyor::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:analogic.ancp00.Conveyor)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Conveyor* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Conveyor>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:analogic.ancp00.Conveyor)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:analogic.ancp00.Conveyor)
    MergeFrom(*source);
  }
}

void Conveyor::MergeFrom(const Conveyor& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:analogic.ancp00.Conveyor)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  sensor_.MergeFrom(from.sensor_);
  motor_.MergeFrom(from.motor_);
  if (from.zone_id() != 0) {
    set_zone_id(from.zone_id());
  }
  if (from.state() != 0) {
    set_state(from.state());
  }
  if (from.rtr() != 0) {
    set_rtr(from.rtr());
  }
  if (from.rts() != 0) {
    set_rts(from.rts());
  }
  if (from.is_diverter() != 0) {
    set_is_diverter(from.is_diverter());
  }
  if (from.diverter_pos() != 0) {
    set_diverter_pos(from.diverter_pos());
  }
  if (from.bags_in_zone() != 0) {
    set_bags_in_zone(from.bags_in_zone());
  }
  if (from.zone_id_name().size() > 0) {

    zone_id_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.zone_id_name_);
  }
  if (from.zone_jammed() != 0) {
    set_zone_jammed(from.zone_jammed());
  }
}

void Conveyor::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:analogic.ancp00.Conveyor)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Conveyor::CopyFrom(const Conveyor& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:analogic.ancp00.Conveyor)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Conveyor::IsInitialized() const {

  return true;
}

void Conveyor::Swap(Conveyor* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Conveyor::InternalSwap(Conveyor* other) {
  std::swap(zone_id_, other->zone_id_);
  std::swap(state_, other->state_);
  std::swap(rtr_, other->rtr_);
  std::swap(rts_, other->rts_);
  sensor_.UnsafeArenaSwap(&other->sensor_);
  motor_.UnsafeArenaSwap(&other->motor_);
  std::swap(is_diverter_, other->is_diverter_);
  std::swap(diverter_pos_, other->diverter_pos_);
  std::swap(bags_in_zone_, other->bags_in_zone_);
  zone_id_name_.Swap(&other->zone_id_name_);
  std::swap(zone_jammed_, other->zone_jammed_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Conveyor::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Conveyor_descriptor_;
  metadata.reflection = Conveyor_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Conveyor

// optional int32 zone_id = 1;
void Conveyor::clear_zone_id() {
  zone_id_ = 0;
}
 ::google::protobuf::int32 Conveyor::zone_id() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.Conveyor.zone_id)
  return zone_id_;
}
 void Conveyor::set_zone_id(::google::protobuf::int32 value) {
  
  zone_id_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.Conveyor.zone_id)
}

// optional .analogic.ancp00.Conveyor.ConveyorState state = 2;
void Conveyor::clear_state() {
  state_ = 0;
}
 ::analogic::ancp00::Conveyor_ConveyorState Conveyor::state() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.Conveyor.state)
  return static_cast< ::analogic::ancp00::Conveyor_ConveyorState >(state_);
}
 void Conveyor::set_state(::analogic::ancp00::Conveyor_ConveyorState value) {
  
  state_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.Conveyor.state)
}

// optional bool rtr = 3;
void Conveyor::clear_rtr() {
  rtr_ = false;
}
 bool Conveyor::rtr() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.Conveyor.rtr)
  return rtr_;
}
 void Conveyor::set_rtr(bool value) {
  
  rtr_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.Conveyor.rtr)
}

// optional bool rts = 4;
void Conveyor::clear_rts() {
  rts_ = false;
}
 bool Conveyor::rts() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.Conveyor.rts)
  return rts_;
}
 void Conveyor::set_rts(bool value) {
  
  rts_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.Conveyor.rts)
}

// repeated .analogic.ancp00.Sensor sensor = 5;
int Conveyor::sensor_size() const {
  return sensor_.size();
}
void Conveyor::clear_sensor() {
  sensor_.Clear();
}
const ::analogic::ancp00::Sensor& Conveyor::sensor(int index) const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.Conveyor.sensor)
  return sensor_.Get(index);
}
::analogic::ancp00::Sensor* Conveyor::mutable_sensor(int index) {
  // @@protoc_insertion_point(field_mutable:analogic.ancp00.Conveyor.sensor)
  return sensor_.Mutable(index);
}
::analogic::ancp00::Sensor* Conveyor::add_sensor() {
  // @@protoc_insertion_point(field_add:analogic.ancp00.Conveyor.sensor)
  return sensor_.Add();
}
::google::protobuf::RepeatedPtrField< ::analogic::ancp00::Sensor >*
Conveyor::mutable_sensor() {
  // @@protoc_insertion_point(field_mutable_list:analogic.ancp00.Conveyor.sensor)
  return &sensor_;
}
const ::google::protobuf::RepeatedPtrField< ::analogic::ancp00::Sensor >&
Conveyor::sensor() const {
  // @@protoc_insertion_point(field_list:analogic.ancp00.Conveyor.sensor)
  return sensor_;
}

// repeated .analogic.ancp00.Motor motor = 6;
int Conveyor::motor_size() const {
  return motor_.size();
}
void Conveyor::clear_motor() {
  motor_.Clear();
}
const ::analogic::ancp00::Motor& Conveyor::motor(int index) const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.Conveyor.motor)
  return motor_.Get(index);
}
::analogic::ancp00::Motor* Conveyor::mutable_motor(int index) {
  // @@protoc_insertion_point(field_mutable:analogic.ancp00.Conveyor.motor)
  return motor_.Mutable(index);
}
::analogic::ancp00::Motor* Conveyor::add_motor() {
  // @@protoc_insertion_point(field_add:analogic.ancp00.Conveyor.motor)
  return motor_.Add();
}
::google::protobuf::RepeatedPtrField< ::analogic::ancp00::Motor >*
Conveyor::mutable_motor() {
  // @@protoc_insertion_point(field_mutable_list:analogic.ancp00.Conveyor.motor)
  return &motor_;
}
const ::google::protobuf::RepeatedPtrField< ::analogic::ancp00::Motor >&
Conveyor::motor() const {
  // @@protoc_insertion_point(field_list:analogic.ancp00.Conveyor.motor)
  return motor_;
}

// optional bool is_diverter = 7;
void Conveyor::clear_is_diverter() {
  is_diverter_ = false;
}
 bool Conveyor::is_diverter() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.Conveyor.is_diverter)
  return is_diverter_;
}
 void Conveyor::set_is_diverter(bool value) {
  
  is_diverter_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.Conveyor.is_diverter)
}

// optional .analogic.ancp00.Conveyor.DiverterPosition diverter_pos = 8;
void Conveyor::clear_diverter_pos() {
  diverter_pos_ = 0;
}
 ::analogic::ancp00::Conveyor_DiverterPosition Conveyor::diverter_pos() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.Conveyor.diverter_pos)
  return static_cast< ::analogic::ancp00::Conveyor_DiverterPosition >(diverter_pos_);
}
 void Conveyor::set_diverter_pos(::analogic::ancp00::Conveyor_DiverterPosition value) {
  
  diverter_pos_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.Conveyor.diverter_pos)
}

// optional int32 bags_in_zone = 9;
void Conveyor::clear_bags_in_zone() {
  bags_in_zone_ = 0;
}
 ::google::protobuf::int32 Conveyor::bags_in_zone() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.Conveyor.bags_in_zone)
  return bags_in_zone_;
}
 void Conveyor::set_bags_in_zone(::google::protobuf::int32 value) {
  
  bags_in_zone_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.Conveyor.bags_in_zone)
}

// optional string zone_id_name = 10;
void Conveyor::clear_zone_id_name() {
  zone_id_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& Conveyor::zone_id_name() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.Conveyor.zone_id_name)
  return zone_id_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Conveyor::set_zone_id_name(const ::std::string& value) {
  
  zone_id_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:analogic.ancp00.Conveyor.zone_id_name)
}
 void Conveyor::set_zone_id_name(const char* value) {
  
  zone_id_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:analogic.ancp00.Conveyor.zone_id_name)
}
 void Conveyor::set_zone_id_name(const char* value, size_t size) {
  
  zone_id_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:analogic.ancp00.Conveyor.zone_id_name)
}
 ::std::string* Conveyor::mutable_zone_id_name() {
  
  // @@protoc_insertion_point(field_mutable:analogic.ancp00.Conveyor.zone_id_name)
  return zone_id_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Conveyor::release_zone_id_name() {
  // @@protoc_insertion_point(field_release:analogic.ancp00.Conveyor.zone_id_name)
  
  return zone_id_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Conveyor::set_allocated_zone_id_name(::std::string* zone_id_name) {
  if (zone_id_name != NULL) {
    
  } else {
    
  }
  zone_id_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), zone_id_name);
  // @@protoc_insertion_point(field_set_allocated:analogic.ancp00.Conveyor.zone_id_name)
}

// optional bool zone_jammed = 11;
void Conveyor::clear_zone_jammed() {
  zone_jammed_ = false;
}
 bool Conveyor::zone_jammed() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.Conveyor.zone_jammed)
  return zone_jammed_;
}
 void Conveyor::set_zone_jammed(bool value) {
  
  zone_jammed_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.Conveyor.zone_jammed)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int AvanconStatusMsg::kTimeStampFieldNumber;
const int AvanconStatusMsg::kBhsConfigurationFieldNumber;
const int AvanconStatusMsg::kPlcConfigurationFieldNumber;
const int AvanconStatusMsg::kPlcVersionFieldNumber;
const int AvanconStatusMsg::kBhsVersionFieldNumber;
const int AvanconStatusMsg::kConvConfigFieldNumber;
const int AvanconStatusMsg::kScannerStateFieldNumber;
const int AvanconStatusMsg::kScannerSubstateFieldNumber;
const int AvanconStatusMsg::kBinTypeFieldNumber;
const int AvanconStatusMsg::kLastBhsFaultFieldNumber;
const int AvanconStatusMsg::kPlcStateFieldNumber;
const int AvanconStatusMsg::kLastPlcFaultFieldNumber;
const int AvanconStatusMsg::kAttenuationDistanceMmFieldNumber;
const int AvanconStatusMsg::kAttenuationWindowMmFieldNumber;
const int AvanconStatusMsg::kInDiebackFieldNumber;
const int AvanconStatusMsg::kForcedDivertFieldNumber;
const int AvanconStatusMsg::kDivertWarningFieldNumber;
const int AvanconStatusMsg::kEntranceRfidFieldNumber;
const int AvanconStatusMsg::kExitRfidFieldNumber;
const int AvanconStatusMsg::kConveyorFieldNumber;
const int AvanconStatusMsg::kBhsWarningFieldNumber;
const int AvanconStatusMsg::kSensorWarningFieldNumber;
const int AvanconStatusMsg::kZ5ExceptionFieldNumber;
const int AvanconStatusMsg::kZ4LongbagFieldNumber;
const int AvanconStatusMsg::kExternalWarningFieldNumber;
const int AvanconStatusMsg::kTotalAttenuationEventsFieldNumber;
const int AvanconStatusMsg::kTotalEntranceEventsFieldNumber;
const int AvanconStatusMsg::kTotalExitEventsFieldNumber;
const int AvanconStatusMsg::kTotalOperatorClearedFieldNumber;
const int AvanconStatusMsg::kTotalOperatorRejectedFieldNumber;
const int AvanconStatusMsg::kTotalLostTrackingFieldNumber;
const int AvanconStatusMsg::kTotalUnlinkedFieldNumber;
const int AvanconStatusMsg::kTotalEntranceRfidMisreadsFieldNumber;
const int AvanconStatusMsg::kTotalExitRfidMisreadsFieldNumber;
const int AvanconStatusMsg::kTotalOversizeBagsFieldNumber;
const int AvanconStatusMsg::kTotalCutBagsFieldNumber;
const int AvanconStatusMsg::kMasterBagJamFieldNumber;
const int AvanconStatusMsg::kBagJamBitsFieldNumber;
const int AvanconStatusMsg::kAttenuationStartBufferMmFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

AvanconStatusMsg::AvanconStatusMsg()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:analogic.ancp00.AvanconStatusMsg)
}

void AvanconStatusMsg::InitAsDefaultInstance() {
  _is_default_instance_ = true;
  entrance_rfid_ = const_cast< ::analogic::ancp00::RfidReader*>(&::analogic::ancp00::RfidReader::default_instance());
  exit_rfid_ = const_cast< ::analogic::ancp00::RfidReader*>(&::analogic::ancp00::RfidReader::default_instance());
}

AvanconStatusMsg::AvanconStatusMsg(const AvanconStatusMsg& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:analogic.ancp00.AvanconStatusMsg)
}

void AvanconStatusMsg::SharedCtor() {
    _is_default_instance_ = false;
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  time_stamp_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  bhs_configuration_ = 0;
  plc_configuration_ = 0;
  plc_version_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  bhs_version_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  conv_config_ = 0;
  scanner_state_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  scanner_substate_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  bin_type_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  last_bhs_fault_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  plc_state_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  last_plc_fault_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  attenuation_distance_mm_ = 0;
  attenuation_window_mm_ = 0;
  in_dieback_ = false;
  forced_divert_ = false;
  divert_warning_ = false;
  entrance_rfid_ = NULL;
  exit_rfid_ = NULL;
  bhs_warning_ = false;
  sensor_warning_ = false;
  z5_exception_ = false;
  z4_longbag_ = false;
  external_warning_ = false;
  total_attenuation_events_ = 0;
  total_entrance_events_ = 0;
  total_exit_events_ = 0;
  total_operator_cleared_ = 0;
  total_operator_rejected_ = 0;
  total_lost_tracking_ = 0;
  total_unlinked_ = 0;
  total_entrance_rfid_misreads_ = 0;
  total_exit_rfid_misreads_ = 0;
  total_oversize_bags_ = 0;
  total_cut_bags_ = 0;
  master_bag_jam_ = false;
  bag_jam_bits_ = 0;
  attenuation_start_buffer_mm_ = 0;
}

AvanconStatusMsg::~AvanconStatusMsg() {
  // @@protoc_insertion_point(destructor:analogic.ancp00.AvanconStatusMsg)
  SharedDtor();
}

void AvanconStatusMsg::SharedDtor() {
  time_stamp_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  plc_version_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  bhs_version_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  scanner_state_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  scanner_substate_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  bin_type_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  last_bhs_fault_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  plc_state_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  last_plc_fault_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete entrance_rfid_;
    delete exit_rfid_;
  }
}

void AvanconStatusMsg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AvanconStatusMsg::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AvanconStatusMsg_descriptor_;
}

const AvanconStatusMsg& AvanconStatusMsg::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_proto_2fAvanconStatus_2eproto();
  return *default_instance_;
}

AvanconStatusMsg* AvanconStatusMsg::default_instance_ = NULL;

AvanconStatusMsg* AvanconStatusMsg::New(::google::protobuf::Arena* arena) const {
  AvanconStatusMsg* n = new AvanconStatusMsg;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void AvanconStatusMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:analogic.ancp00.AvanconStatusMsg)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(AvanconStatusMsg, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<AvanconStatusMsg*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(bhs_configuration_, plc_configuration_);
  time_stamp_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  plc_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  bhs_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  conv_config_ = 0;
  scanner_state_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  scanner_substate_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ZR_(attenuation_window_mm_, forced_divert_);
  bin_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  last_bhs_fault_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  plc_state_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  last_plc_fault_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  attenuation_distance_mm_ = 0;
  ZR_(divert_warning_, bhs_warning_);
  ZR_(sensor_warning_, z4_longbag_);
  if (GetArenaNoVirtual() == NULL && entrance_rfid_ != NULL) delete entrance_rfid_;
  entrance_rfid_ = NULL;
  if (GetArenaNoVirtual() == NULL && exit_rfid_ != NULL) delete exit_rfid_;
  exit_rfid_ = NULL;
  ZR_(external_warning_, total_unlinked_);
  ZR_(total_entrance_rfid_misreads_, attenuation_start_buffer_mm_);

#undef ZR_HELPER_
#undef ZR_

  conveyor_.Clear();
}

bool AvanconStatusMsg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:analogic.ancp00.AvanconStatusMsg)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string time_stamp = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_time_stamp()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->time_stamp().data(), this->time_stamp().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "analogic.ancp00.AvanconStatusMsg.time_stamp"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_bhs_configuration;
        break;
      }

      // optional int32 bhs_configuration = 2;
      case 2: {
        if (tag == 16) {
         parse_bhs_configuration:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &bhs_configuration_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_plc_configuration;
        break;
      }

      // optional int32 plc_configuration = 3;
      case 3: {
        if (tag == 24) {
         parse_plc_configuration:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &plc_configuration_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_plc_version;
        break;
      }

      // optional string plc_version = 4;
      case 4: {
        if (tag == 34) {
         parse_plc_version:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_plc_version()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->plc_version().data(), this->plc_version().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "analogic.ancp00.AvanconStatusMsg.plc_version"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_bhs_version;
        break;
      }

      // optional string bhs_version = 5;
      case 5: {
        if (tag == 42) {
         parse_bhs_version:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_bhs_version()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->bhs_version().data(), this->bhs_version().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "analogic.ancp00.AvanconStatusMsg.bhs_version"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_conv_config;
        break;
      }

      // optional .analogic.ancp00.ConveyorConfig conv_config = 6;
      case 6: {
        if (tag == 48) {
         parse_conv_config:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_conv_config(static_cast< ::analogic::ancp00::ConveyorConfig >(value));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_scanner_state;
        break;
      }

      // optional string scanner_state = 7;
      case 7: {
        if (tag == 58) {
         parse_scanner_state:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_scanner_state()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->scanner_state().data(), this->scanner_state().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "analogic.ancp00.AvanconStatusMsg.scanner_state"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_scanner_substate;
        break;
      }

      // optional string scanner_substate = 8;
      case 8: {
        if (tag == 66) {
         parse_scanner_substate:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_scanner_substate()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->scanner_substate().data(), this->scanner_substate().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "analogic.ancp00.AvanconStatusMsg.scanner_substate"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(74)) goto parse_bin_type;
        break;
      }

      // optional string bin_type = 9;
      case 9: {
        if (tag == 74) {
         parse_bin_type:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_bin_type()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->bin_type().data(), this->bin_type().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "analogic.ancp00.AvanconStatusMsg.bin_type"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(82)) goto parse_last_bhs_fault;
        break;
      }

      // optional string last_bhs_fault = 10;
      case 10: {
        if (tag == 82) {
         parse_last_bhs_fault:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_last_bhs_fault()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->last_bhs_fault().data(), this->last_bhs_fault().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "analogic.ancp00.AvanconStatusMsg.last_bhs_fault"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(90)) goto parse_plc_state;
        break;
      }

      // optional string plc_state = 11;
      case 11: {
        if (tag == 90) {
         parse_plc_state:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_plc_state()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->plc_state().data(), this->plc_state().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "analogic.ancp00.AvanconStatusMsg.plc_state"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(98)) goto parse_last_plc_fault;
        break;
      }

      // optional string last_plc_fault = 12;
      case 12: {
        if (tag == 98) {
         parse_last_plc_fault:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_last_plc_fault()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->last_plc_fault().data(), this->last_plc_fault().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "analogic.ancp00.AvanconStatusMsg.last_plc_fault"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(104)) goto parse_attenuation_distance_mm;
        break;
      }

      // optional int32 attenuation_distance_mm = 13;
      case 13: {
        if (tag == 104) {
         parse_attenuation_distance_mm:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &attenuation_distance_mm_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(112)) goto parse_attenuation_window_mm;
        break;
      }

      // optional int32 attenuation_window_mm = 14;
      case 14: {
        if (tag == 112) {
         parse_attenuation_window_mm:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &attenuation_window_mm_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(120)) goto parse_in_dieback;
        break;
      }

      // optional bool in_dieback = 15;
      case 15: {
        if (tag == 120) {
         parse_in_dieback:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &in_dieback_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(128)) goto parse_forced_divert;
        break;
      }

      // optional bool forced_divert = 16;
      case 16: {
        if (tag == 128) {
         parse_forced_divert:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &forced_divert_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(136)) goto parse_divert_warning;
        break;
      }

      // optional bool divert_warning = 17;
      case 17: {
        if (tag == 136) {
         parse_divert_warning:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &divert_warning_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(146)) goto parse_entrance_rfid;
        break;
      }

      // optional .analogic.ancp00.RfidReader entrance_rfid = 18;
      case 18: {
        if (tag == 146) {
         parse_entrance_rfid:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_entrance_rfid()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(154)) goto parse_exit_rfid;
        break;
      }

      // optional .analogic.ancp00.RfidReader exit_rfid = 19;
      case 19: {
        if (tag == 154) {
         parse_exit_rfid:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_exit_rfid()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(162)) goto parse_conveyor;
        break;
      }

      // repeated .analogic.ancp00.Conveyor conveyor = 20;
      case 20: {
        if (tag == 162) {
         parse_conveyor:
          DO_(input->IncrementRecursionDepth());
         parse_loop_conveyor:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_conveyor()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(162)) goto parse_loop_conveyor;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectTag(168)) goto parse_bhs_warning;
        break;
      }

      // optional bool bhs_warning = 21;
      case 21: {
        if (tag == 168) {
         parse_bhs_warning:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &bhs_warning_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(176)) goto parse_sensor_warning;
        break;
      }

      // optional bool sensor_warning = 22;
      case 22: {
        if (tag == 176) {
         parse_sensor_warning:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &sensor_warning_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(184)) goto parse_Z5_exception;
        break;
      }

      // optional bool Z5_exception = 23;
      case 23: {
        if (tag == 184) {
         parse_Z5_exception:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &z5_exception_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(192)) goto parse_Z4_longbag;
        break;
      }

      // optional bool Z4_longbag = 24;
      case 24: {
        if (tag == 192) {
         parse_Z4_longbag:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &z4_longbag_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(200)) goto parse_external_warning;
        break;
      }

      // optional bool external_warning = 25;
      case 25: {
        if (tag == 200) {
         parse_external_warning:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &external_warning_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(208)) goto parse_total_attenuation_events;
        break;
      }

      // optional int32 total_attenuation_events = 26;
      case 26: {
        if (tag == 208) {
         parse_total_attenuation_events:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &total_attenuation_events_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(216)) goto parse_total_entrance_events;
        break;
      }

      // optional int32 total_entrance_events = 27;
      case 27: {
        if (tag == 216) {
         parse_total_entrance_events:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &total_entrance_events_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(224)) goto parse_total_exit_events;
        break;
      }

      // optional int32 total_exit_events = 28;
      case 28: {
        if (tag == 224) {
         parse_total_exit_events:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &total_exit_events_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(232)) goto parse_total_operator_cleared;
        break;
      }

      // optional int32 total_operator_cleared = 29;
      case 29: {
        if (tag == 232) {
         parse_total_operator_cleared:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &total_operator_cleared_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(240)) goto parse_total_operator_rejected;
        break;
      }

      // optional int32 total_operator_rejected = 30;
      case 30: {
        if (tag == 240) {
         parse_total_operator_rejected:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &total_operator_rejected_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(248)) goto parse_total_lost_tracking;
        break;
      }

      // optional int32 total_lost_tracking = 31;
      case 31: {
        if (tag == 248) {
         parse_total_lost_tracking:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &total_lost_tracking_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(256)) goto parse_total_unlinked;
        break;
      }

      // optional int32 total_unlinked = 32;
      case 32: {
        if (tag == 256) {
         parse_total_unlinked:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &total_unlinked_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(264)) goto parse_total_entrance_rfid_misreads;
        break;
      }

      // optional int32 total_entrance_rfid_misreads = 33;
      case 33: {
        if (tag == 264) {
         parse_total_entrance_rfid_misreads:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &total_entrance_rfid_misreads_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(272)) goto parse_total_exit_rfid_misreads;
        break;
      }

      // optional int32 total_exit_rfid_misreads = 34;
      case 34: {
        if (tag == 272) {
         parse_total_exit_rfid_misreads:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &total_exit_rfid_misreads_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(280)) goto parse_total_oversize_bags;
        break;
      }

      // optional int32 total_oversize_bags = 35;
      case 35: {
        if (tag == 280) {
         parse_total_oversize_bags:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &total_oversize_bags_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(288)) goto parse_total_cut_bags;
        break;
      }

      // optional int32 total_cut_bags = 36;
      case 36: {
        if (tag == 288) {
         parse_total_cut_bags:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &total_cut_bags_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(296)) goto parse_master_bag_jam;
        break;
      }

      // optional bool master_bag_jam = 37;
      case 37: {
        if (tag == 296) {
         parse_master_bag_jam:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &master_bag_jam_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(304)) goto parse_bag_jam_bits;
        break;
      }

      // optional int32 bag_jam_bits = 38;
      case 38: {
        if (tag == 304) {
         parse_bag_jam_bits:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &bag_jam_bits_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(312)) goto parse_attenuation_start_buffer_mm;
        break;
      }

      // optional int32 attenuation_start_buffer_mm = 39;
      case 39: {
        if (tag == 312) {
         parse_attenuation_start_buffer_mm:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &attenuation_start_buffer_mm_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:analogic.ancp00.AvanconStatusMsg)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:analogic.ancp00.AvanconStatusMsg)
  return false;
#undef DO_
}

void AvanconStatusMsg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:analogic.ancp00.AvanconStatusMsg)
  // optional string time_stamp = 1;
  if (this->time_stamp().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->time_stamp().data(), this->time_stamp().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "analogic.ancp00.AvanconStatusMsg.time_stamp");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->time_stamp(), output);
  }

  // optional int32 bhs_configuration = 2;
  if (this->bhs_configuration() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->bhs_configuration(), output);
  }

  // optional int32 plc_configuration = 3;
  if (this->plc_configuration() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->plc_configuration(), output);
  }

  // optional string plc_version = 4;
  if (this->plc_version().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->plc_version().data(), this->plc_version().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "analogic.ancp00.AvanconStatusMsg.plc_version");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->plc_version(), output);
  }

  // optional string bhs_version = 5;
  if (this->bhs_version().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->bhs_version().data(), this->bhs_version().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "analogic.ancp00.AvanconStatusMsg.bhs_version");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->bhs_version(), output);
  }

  // optional .analogic.ancp00.ConveyorConfig conv_config = 6;
  if (this->conv_config() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      6, this->conv_config(), output);
  }

  // optional string scanner_state = 7;
  if (this->scanner_state().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->scanner_state().data(), this->scanner_state().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "analogic.ancp00.AvanconStatusMsg.scanner_state");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      7, this->scanner_state(), output);
  }

  // optional string scanner_substate = 8;
  if (this->scanner_substate().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->scanner_substate().data(), this->scanner_substate().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "analogic.ancp00.AvanconStatusMsg.scanner_substate");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      8, this->scanner_substate(), output);
  }

  // optional string bin_type = 9;
  if (this->bin_type().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->bin_type().data(), this->bin_type().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "analogic.ancp00.AvanconStatusMsg.bin_type");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      9, this->bin_type(), output);
  }

  // optional string last_bhs_fault = 10;
  if (this->last_bhs_fault().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->last_bhs_fault().data(), this->last_bhs_fault().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "analogic.ancp00.AvanconStatusMsg.last_bhs_fault");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      10, this->last_bhs_fault(), output);
  }

  // optional string plc_state = 11;
  if (this->plc_state().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->plc_state().data(), this->plc_state().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "analogic.ancp00.AvanconStatusMsg.plc_state");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      11, this->plc_state(), output);
  }

  // optional string last_plc_fault = 12;
  if (this->last_plc_fault().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->last_plc_fault().data(), this->last_plc_fault().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "analogic.ancp00.AvanconStatusMsg.last_plc_fault");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      12, this->last_plc_fault(), output);
  }

  // optional int32 attenuation_distance_mm = 13;
  if (this->attenuation_distance_mm() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(13, this->attenuation_distance_mm(), output);
  }

  // optional int32 attenuation_window_mm = 14;
  if (this->attenuation_window_mm() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(14, this->attenuation_window_mm(), output);
  }

  // optional bool in_dieback = 15;
  if (this->in_dieback() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(15, this->in_dieback(), output);
  }

  // optional bool forced_divert = 16;
  if (this->forced_divert() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(16, this->forced_divert(), output);
  }

  // optional bool divert_warning = 17;
  if (this->divert_warning() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(17, this->divert_warning(), output);
  }

  // optional .analogic.ancp00.RfidReader entrance_rfid = 18;
  if (this->has_entrance_rfid()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      18, *this->entrance_rfid_, output);
  }

  // optional .analogic.ancp00.RfidReader exit_rfid = 19;
  if (this->has_exit_rfid()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      19, *this->exit_rfid_, output);
  }

  // repeated .analogic.ancp00.Conveyor conveyor = 20;
  for (unsigned int i = 0, n = this->conveyor_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      20, this->conveyor(i), output);
  }

  // optional bool bhs_warning = 21;
  if (this->bhs_warning() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(21, this->bhs_warning(), output);
  }

  // optional bool sensor_warning = 22;
  if (this->sensor_warning() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(22, this->sensor_warning(), output);
  }

  // optional bool Z5_exception = 23;
  if (this->z5_exception() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(23, this->z5_exception(), output);
  }

  // optional bool Z4_longbag = 24;
  if (this->z4_longbag() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(24, this->z4_longbag(), output);
  }

  // optional bool external_warning = 25;
  if (this->external_warning() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(25, this->external_warning(), output);
  }

  // optional int32 total_attenuation_events = 26;
  if (this->total_attenuation_events() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(26, this->total_attenuation_events(), output);
  }

  // optional int32 total_entrance_events = 27;
  if (this->total_entrance_events() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(27, this->total_entrance_events(), output);
  }

  // optional int32 total_exit_events = 28;
  if (this->total_exit_events() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(28, this->total_exit_events(), output);
  }

  // optional int32 total_operator_cleared = 29;
  if (this->total_operator_cleared() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(29, this->total_operator_cleared(), output);
  }

  // optional int32 total_operator_rejected = 30;
  if (this->total_operator_rejected() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(30, this->total_operator_rejected(), output);
  }

  // optional int32 total_lost_tracking = 31;
  if (this->total_lost_tracking() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(31, this->total_lost_tracking(), output);
  }

  // optional int32 total_unlinked = 32;
  if (this->total_unlinked() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(32, this->total_unlinked(), output);
  }

  // optional int32 total_entrance_rfid_misreads = 33;
  if (this->total_entrance_rfid_misreads() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(33, this->total_entrance_rfid_misreads(), output);
  }

  // optional int32 total_exit_rfid_misreads = 34;
  if (this->total_exit_rfid_misreads() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(34, this->total_exit_rfid_misreads(), output);
  }

  // optional int32 total_oversize_bags = 35;
  if (this->total_oversize_bags() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(35, this->total_oversize_bags(), output);
  }

  // optional int32 total_cut_bags = 36;
  if (this->total_cut_bags() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(36, this->total_cut_bags(), output);
  }

  // optional bool master_bag_jam = 37;
  if (this->master_bag_jam() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(37, this->master_bag_jam(), output);
  }

  // optional int32 bag_jam_bits = 38;
  if (this->bag_jam_bits() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(38, this->bag_jam_bits(), output);
  }

  // optional int32 attenuation_start_buffer_mm = 39;
  if (this->attenuation_start_buffer_mm() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(39, this->attenuation_start_buffer_mm(), output);
  }

  // @@protoc_insertion_point(serialize_end:analogic.ancp00.AvanconStatusMsg)
}

::google::protobuf::uint8* AvanconStatusMsg::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:analogic.ancp00.AvanconStatusMsg)
  // optional string time_stamp = 1;
  if (this->time_stamp().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->time_stamp().data(), this->time_stamp().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "analogic.ancp00.AvanconStatusMsg.time_stamp");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->time_stamp(), target);
  }

  // optional int32 bhs_configuration = 2;
  if (this->bhs_configuration() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->bhs_configuration(), target);
  }

  // optional int32 plc_configuration = 3;
  if (this->plc_configuration() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->plc_configuration(), target);
  }

  // optional string plc_version = 4;
  if (this->plc_version().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->plc_version().data(), this->plc_version().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "analogic.ancp00.AvanconStatusMsg.plc_version");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->plc_version(), target);
  }

  // optional string bhs_version = 5;
  if (this->bhs_version().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->bhs_version().data(), this->bhs_version().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "analogic.ancp00.AvanconStatusMsg.bhs_version");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->bhs_version(), target);
  }

  // optional .analogic.ancp00.ConveyorConfig conv_config = 6;
  if (this->conv_config() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      6, this->conv_config(), target);
  }

  // optional string scanner_state = 7;
  if (this->scanner_state().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->scanner_state().data(), this->scanner_state().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "analogic.ancp00.AvanconStatusMsg.scanner_state");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        7, this->scanner_state(), target);
  }

  // optional string scanner_substate = 8;
  if (this->scanner_substate().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->scanner_substate().data(), this->scanner_substate().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "analogic.ancp00.AvanconStatusMsg.scanner_substate");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        8, this->scanner_substate(), target);
  }

  // optional string bin_type = 9;
  if (this->bin_type().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->bin_type().data(), this->bin_type().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "analogic.ancp00.AvanconStatusMsg.bin_type");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        9, this->bin_type(), target);
  }

  // optional string last_bhs_fault = 10;
  if (this->last_bhs_fault().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->last_bhs_fault().data(), this->last_bhs_fault().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "analogic.ancp00.AvanconStatusMsg.last_bhs_fault");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        10, this->last_bhs_fault(), target);
  }

  // optional string plc_state = 11;
  if (this->plc_state().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->plc_state().data(), this->plc_state().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "analogic.ancp00.AvanconStatusMsg.plc_state");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        11, this->plc_state(), target);
  }

  // optional string last_plc_fault = 12;
  if (this->last_plc_fault().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->last_plc_fault().data(), this->last_plc_fault().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "analogic.ancp00.AvanconStatusMsg.last_plc_fault");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        12, this->last_plc_fault(), target);
  }

  // optional int32 attenuation_distance_mm = 13;
  if (this->attenuation_distance_mm() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(13, this->attenuation_distance_mm(), target);
  }

  // optional int32 attenuation_window_mm = 14;
  if (this->attenuation_window_mm() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(14, this->attenuation_window_mm(), target);
  }

  // optional bool in_dieback = 15;
  if (this->in_dieback() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(15, this->in_dieback(), target);
  }

  // optional bool forced_divert = 16;
  if (this->forced_divert() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(16, this->forced_divert(), target);
  }

  // optional bool divert_warning = 17;
  if (this->divert_warning() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(17, this->divert_warning(), target);
  }

  // optional .analogic.ancp00.RfidReader entrance_rfid = 18;
  if (this->has_entrance_rfid()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        18, *this->entrance_rfid_, false, target);
  }

  // optional .analogic.ancp00.RfidReader exit_rfid = 19;
  if (this->has_exit_rfid()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        19, *this->exit_rfid_, false, target);
  }

  // repeated .analogic.ancp00.Conveyor conveyor = 20;
  for (unsigned int i = 0, n = this->conveyor_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        20, this->conveyor(i), false, target);
  }

  // optional bool bhs_warning = 21;
  if (this->bhs_warning() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(21, this->bhs_warning(), target);
  }

  // optional bool sensor_warning = 22;
  if (this->sensor_warning() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(22, this->sensor_warning(), target);
  }

  // optional bool Z5_exception = 23;
  if (this->z5_exception() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(23, this->z5_exception(), target);
  }

  // optional bool Z4_longbag = 24;
  if (this->z4_longbag() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(24, this->z4_longbag(), target);
  }

  // optional bool external_warning = 25;
  if (this->external_warning() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(25, this->external_warning(), target);
  }

  // optional int32 total_attenuation_events = 26;
  if (this->total_attenuation_events() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(26, this->total_attenuation_events(), target);
  }

  // optional int32 total_entrance_events = 27;
  if (this->total_entrance_events() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(27, this->total_entrance_events(), target);
  }

  // optional int32 total_exit_events = 28;
  if (this->total_exit_events() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(28, this->total_exit_events(), target);
  }

  // optional int32 total_operator_cleared = 29;
  if (this->total_operator_cleared() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(29, this->total_operator_cleared(), target);
  }

  // optional int32 total_operator_rejected = 30;
  if (this->total_operator_rejected() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(30, this->total_operator_rejected(), target);
  }

  // optional int32 total_lost_tracking = 31;
  if (this->total_lost_tracking() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(31, this->total_lost_tracking(), target);
  }

  // optional int32 total_unlinked = 32;
  if (this->total_unlinked() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(32, this->total_unlinked(), target);
  }

  // optional int32 total_entrance_rfid_misreads = 33;
  if (this->total_entrance_rfid_misreads() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(33, this->total_entrance_rfid_misreads(), target);
  }

  // optional int32 total_exit_rfid_misreads = 34;
  if (this->total_exit_rfid_misreads() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(34, this->total_exit_rfid_misreads(), target);
  }

  // optional int32 total_oversize_bags = 35;
  if (this->total_oversize_bags() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(35, this->total_oversize_bags(), target);
  }

  // optional int32 total_cut_bags = 36;
  if (this->total_cut_bags() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(36, this->total_cut_bags(), target);
  }

  // optional bool master_bag_jam = 37;
  if (this->master_bag_jam() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(37, this->master_bag_jam(), target);
  }

  // optional int32 bag_jam_bits = 38;
  if (this->bag_jam_bits() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(38, this->bag_jam_bits(), target);
  }

  // optional int32 attenuation_start_buffer_mm = 39;
  if (this->attenuation_start_buffer_mm() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(39, this->attenuation_start_buffer_mm(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:analogic.ancp00.AvanconStatusMsg)
  return target;
}

int AvanconStatusMsg::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:analogic.ancp00.AvanconStatusMsg)
  int total_size = 0;

  // optional string time_stamp = 1;
  if (this->time_stamp().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->time_stamp());
  }

  // optional int32 bhs_configuration = 2;
  if (this->bhs_configuration() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->bhs_configuration());
  }

  // optional int32 plc_configuration = 3;
  if (this->plc_configuration() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->plc_configuration());
  }

  // optional string plc_version = 4;
  if (this->plc_version().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->plc_version());
  }

  // optional string bhs_version = 5;
  if (this->bhs_version().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->bhs_version());
  }

  // optional .analogic.ancp00.ConveyorConfig conv_config = 6;
  if (this->conv_config() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->conv_config());
  }

  // optional string scanner_state = 7;
  if (this->scanner_state().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->scanner_state());
  }

  // optional string scanner_substate = 8;
  if (this->scanner_substate().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->scanner_substate());
  }

  // optional string bin_type = 9;
  if (this->bin_type().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->bin_type());
  }

  // optional string last_bhs_fault = 10;
  if (this->last_bhs_fault().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->last_bhs_fault());
  }

  // optional string plc_state = 11;
  if (this->plc_state().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->plc_state());
  }

  // optional string last_plc_fault = 12;
  if (this->last_plc_fault().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->last_plc_fault());
  }

  // optional int32 attenuation_distance_mm = 13;
  if (this->attenuation_distance_mm() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->attenuation_distance_mm());
  }

  // optional int32 attenuation_window_mm = 14;
  if (this->attenuation_window_mm() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->attenuation_window_mm());
  }

  // optional bool in_dieback = 15;
  if (this->in_dieback() != 0) {
    total_size += 1 + 1;
  }

  // optional bool forced_divert = 16;
  if (this->forced_divert() != 0) {
    total_size += 2 + 1;
  }

  // optional bool divert_warning = 17;
  if (this->divert_warning() != 0) {
    total_size += 2 + 1;
  }

  // optional .analogic.ancp00.RfidReader entrance_rfid = 18;
  if (this->has_entrance_rfid()) {
    total_size += 2 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->entrance_rfid_);
  }

  // optional .analogic.ancp00.RfidReader exit_rfid = 19;
  if (this->has_exit_rfid()) {
    total_size += 2 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->exit_rfid_);
  }

  // optional bool bhs_warning = 21;
  if (this->bhs_warning() != 0) {
    total_size += 2 + 1;
  }

  // optional bool sensor_warning = 22;
  if (this->sensor_warning() != 0) {
    total_size += 2 + 1;
  }

  // optional bool Z5_exception = 23;
  if (this->z5_exception() != 0) {
    total_size += 2 + 1;
  }

  // optional bool Z4_longbag = 24;
  if (this->z4_longbag() != 0) {
    total_size += 2 + 1;
  }

  // optional bool external_warning = 25;
  if (this->external_warning() != 0) {
    total_size += 2 + 1;
  }

  // optional int32 total_attenuation_events = 26;
  if (this->total_attenuation_events() != 0) {
    total_size += 2 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->total_attenuation_events());
  }

  // optional int32 total_entrance_events = 27;
  if (this->total_entrance_events() != 0) {
    total_size += 2 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->total_entrance_events());
  }

  // optional int32 total_exit_events = 28;
  if (this->total_exit_events() != 0) {
    total_size += 2 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->total_exit_events());
  }

  // optional int32 total_operator_cleared = 29;
  if (this->total_operator_cleared() != 0) {
    total_size += 2 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->total_operator_cleared());
  }

  // optional int32 total_operator_rejected = 30;
  if (this->total_operator_rejected() != 0) {
    total_size += 2 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->total_operator_rejected());
  }

  // optional int32 total_lost_tracking = 31;
  if (this->total_lost_tracking() != 0) {
    total_size += 2 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->total_lost_tracking());
  }

  // optional int32 total_unlinked = 32;
  if (this->total_unlinked() != 0) {
    total_size += 2 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->total_unlinked());
  }

  // optional int32 total_entrance_rfid_misreads = 33;
  if (this->total_entrance_rfid_misreads() != 0) {
    total_size += 2 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->total_entrance_rfid_misreads());
  }

  // optional int32 total_exit_rfid_misreads = 34;
  if (this->total_exit_rfid_misreads() != 0) {
    total_size += 2 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->total_exit_rfid_misreads());
  }

  // optional int32 total_oversize_bags = 35;
  if (this->total_oversize_bags() != 0) {
    total_size += 2 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->total_oversize_bags());
  }

  // optional int32 total_cut_bags = 36;
  if (this->total_cut_bags() != 0) {
    total_size += 2 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->total_cut_bags());
  }

  // optional bool master_bag_jam = 37;
  if (this->master_bag_jam() != 0) {
    total_size += 2 + 1;
  }

  // optional int32 bag_jam_bits = 38;
  if (this->bag_jam_bits() != 0) {
    total_size += 2 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->bag_jam_bits());
  }

  // optional int32 attenuation_start_buffer_mm = 39;
  if (this->attenuation_start_buffer_mm() != 0) {
    total_size += 2 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->attenuation_start_buffer_mm());
  }

  // repeated .analogic.ancp00.Conveyor conveyor = 20;
  total_size += 2 * this->conveyor_size();
  for (int i = 0; i < this->conveyor_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->conveyor(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AvanconStatusMsg::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:analogic.ancp00.AvanconStatusMsg)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const AvanconStatusMsg* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const AvanconStatusMsg>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:analogic.ancp00.AvanconStatusMsg)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:analogic.ancp00.AvanconStatusMsg)
    MergeFrom(*source);
  }
}

void AvanconStatusMsg::MergeFrom(const AvanconStatusMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:analogic.ancp00.AvanconStatusMsg)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  conveyor_.MergeFrom(from.conveyor_);
  if (from.time_stamp().size() > 0) {

    time_stamp_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.time_stamp_);
  }
  if (from.bhs_configuration() != 0) {
    set_bhs_configuration(from.bhs_configuration());
  }
  if (from.plc_configuration() != 0) {
    set_plc_configuration(from.plc_configuration());
  }
  if (from.plc_version().size() > 0) {

    plc_version_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.plc_version_);
  }
  if (from.bhs_version().size() > 0) {

    bhs_version_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.bhs_version_);
  }
  if (from.conv_config() != 0) {
    set_conv_config(from.conv_config());
  }
  if (from.scanner_state().size() > 0) {

    scanner_state_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.scanner_state_);
  }
  if (from.scanner_substate().size() > 0) {

    scanner_substate_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.scanner_substate_);
  }
  if (from.bin_type().size() > 0) {

    bin_type_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.bin_type_);
  }
  if (from.last_bhs_fault().size() > 0) {

    last_bhs_fault_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.last_bhs_fault_);
  }
  if (from.plc_state().size() > 0) {

    plc_state_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.plc_state_);
  }
  if (from.last_plc_fault().size() > 0) {

    last_plc_fault_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.last_plc_fault_);
  }
  if (from.attenuation_distance_mm() != 0) {
    set_attenuation_distance_mm(from.attenuation_distance_mm());
  }
  if (from.attenuation_window_mm() != 0) {
    set_attenuation_window_mm(from.attenuation_window_mm());
  }
  if (from.in_dieback() != 0) {
    set_in_dieback(from.in_dieback());
  }
  if (from.forced_divert() != 0) {
    set_forced_divert(from.forced_divert());
  }
  if (from.divert_warning() != 0) {
    set_divert_warning(from.divert_warning());
  }
  if (from.has_entrance_rfid()) {
    mutable_entrance_rfid()->::analogic::ancp00::RfidReader::MergeFrom(from.entrance_rfid());
  }
  if (from.has_exit_rfid()) {
    mutable_exit_rfid()->::analogic::ancp00::RfidReader::MergeFrom(from.exit_rfid());
  }
  if (from.bhs_warning() != 0) {
    set_bhs_warning(from.bhs_warning());
  }
  if (from.sensor_warning() != 0) {
    set_sensor_warning(from.sensor_warning());
  }
  if (from.z5_exception() != 0) {
    set_z5_exception(from.z5_exception());
  }
  if (from.z4_longbag() != 0) {
    set_z4_longbag(from.z4_longbag());
  }
  if (from.external_warning() != 0) {
    set_external_warning(from.external_warning());
  }
  if (from.total_attenuation_events() != 0) {
    set_total_attenuation_events(from.total_attenuation_events());
  }
  if (from.total_entrance_events() != 0) {
    set_total_entrance_events(from.total_entrance_events());
  }
  if (from.total_exit_events() != 0) {
    set_total_exit_events(from.total_exit_events());
  }
  if (from.total_operator_cleared() != 0) {
    set_total_operator_cleared(from.total_operator_cleared());
  }
  if (from.total_operator_rejected() != 0) {
    set_total_operator_rejected(from.total_operator_rejected());
  }
  if (from.total_lost_tracking() != 0) {
    set_total_lost_tracking(from.total_lost_tracking());
  }
  if (from.total_unlinked() != 0) {
    set_total_unlinked(from.total_unlinked());
  }
  if (from.total_entrance_rfid_misreads() != 0) {
    set_total_entrance_rfid_misreads(from.total_entrance_rfid_misreads());
  }
  if (from.total_exit_rfid_misreads() != 0) {
    set_total_exit_rfid_misreads(from.total_exit_rfid_misreads());
  }
  if (from.total_oversize_bags() != 0) {
    set_total_oversize_bags(from.total_oversize_bags());
  }
  if (from.total_cut_bags() != 0) {
    set_total_cut_bags(from.total_cut_bags());
  }
  if (from.master_bag_jam() != 0) {
    set_master_bag_jam(from.master_bag_jam());
  }
  if (from.bag_jam_bits() != 0) {
    set_bag_jam_bits(from.bag_jam_bits());
  }
  if (from.attenuation_start_buffer_mm() != 0) {
    set_attenuation_start_buffer_mm(from.attenuation_start_buffer_mm());
  }
}

void AvanconStatusMsg::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:analogic.ancp00.AvanconStatusMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AvanconStatusMsg::CopyFrom(const AvanconStatusMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:analogic.ancp00.AvanconStatusMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AvanconStatusMsg::IsInitialized() const {

  return true;
}

void AvanconStatusMsg::Swap(AvanconStatusMsg* other) {
  if (other == this) return;
  InternalSwap(other);
}
void AvanconStatusMsg::InternalSwap(AvanconStatusMsg* other) {
  time_stamp_.Swap(&other->time_stamp_);
  std::swap(bhs_configuration_, other->bhs_configuration_);
  std::swap(plc_configuration_, other->plc_configuration_);
  plc_version_.Swap(&other->plc_version_);
  bhs_version_.Swap(&other->bhs_version_);
  std::swap(conv_config_, other->conv_config_);
  scanner_state_.Swap(&other->scanner_state_);
  scanner_substate_.Swap(&other->scanner_substate_);
  bin_type_.Swap(&other->bin_type_);
  last_bhs_fault_.Swap(&other->last_bhs_fault_);
  plc_state_.Swap(&other->plc_state_);
  last_plc_fault_.Swap(&other->last_plc_fault_);
  std::swap(attenuation_distance_mm_, other->attenuation_distance_mm_);
  std::swap(attenuation_window_mm_, other->attenuation_window_mm_);
  std::swap(in_dieback_, other->in_dieback_);
  std::swap(forced_divert_, other->forced_divert_);
  std::swap(divert_warning_, other->divert_warning_);
  std::swap(entrance_rfid_, other->entrance_rfid_);
  std::swap(exit_rfid_, other->exit_rfid_);
  conveyor_.UnsafeArenaSwap(&other->conveyor_);
  std::swap(bhs_warning_, other->bhs_warning_);
  std::swap(sensor_warning_, other->sensor_warning_);
  std::swap(z5_exception_, other->z5_exception_);
  std::swap(z4_longbag_, other->z4_longbag_);
  std::swap(external_warning_, other->external_warning_);
  std::swap(total_attenuation_events_, other->total_attenuation_events_);
  std::swap(total_entrance_events_, other->total_entrance_events_);
  std::swap(total_exit_events_, other->total_exit_events_);
  std::swap(total_operator_cleared_, other->total_operator_cleared_);
  std::swap(total_operator_rejected_, other->total_operator_rejected_);
  std::swap(total_lost_tracking_, other->total_lost_tracking_);
  std::swap(total_unlinked_, other->total_unlinked_);
  std::swap(total_entrance_rfid_misreads_, other->total_entrance_rfid_misreads_);
  std::swap(total_exit_rfid_misreads_, other->total_exit_rfid_misreads_);
  std::swap(total_oversize_bags_, other->total_oversize_bags_);
  std::swap(total_cut_bags_, other->total_cut_bags_);
  std::swap(master_bag_jam_, other->master_bag_jam_);
  std::swap(bag_jam_bits_, other->bag_jam_bits_);
  std::swap(attenuation_start_buffer_mm_, other->attenuation_start_buffer_mm_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata AvanconStatusMsg::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AvanconStatusMsg_descriptor_;
  metadata.reflection = AvanconStatusMsg_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// AvanconStatusMsg

// optional string time_stamp = 1;
void AvanconStatusMsg::clear_time_stamp() {
  time_stamp_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& AvanconStatusMsg::time_stamp() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.AvanconStatusMsg.time_stamp)
  return time_stamp_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void AvanconStatusMsg::set_time_stamp(const ::std::string& value) {
  
  time_stamp_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:analogic.ancp00.AvanconStatusMsg.time_stamp)
}
 void AvanconStatusMsg::set_time_stamp(const char* value) {
  
  time_stamp_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:analogic.ancp00.AvanconStatusMsg.time_stamp)
}
 void AvanconStatusMsg::set_time_stamp(const char* value, size_t size) {
  
  time_stamp_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:analogic.ancp00.AvanconStatusMsg.time_stamp)
}
 ::std::string* AvanconStatusMsg::mutable_time_stamp() {
  
  // @@protoc_insertion_point(field_mutable:analogic.ancp00.AvanconStatusMsg.time_stamp)
  return time_stamp_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* AvanconStatusMsg::release_time_stamp() {
  // @@protoc_insertion_point(field_release:analogic.ancp00.AvanconStatusMsg.time_stamp)
  
  return time_stamp_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void AvanconStatusMsg::set_allocated_time_stamp(::std::string* time_stamp) {
  if (time_stamp != NULL) {
    
  } else {
    
  }
  time_stamp_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), time_stamp);
  // @@protoc_insertion_point(field_set_allocated:analogic.ancp00.AvanconStatusMsg.time_stamp)
}

// optional int32 bhs_configuration = 2;
void AvanconStatusMsg::clear_bhs_configuration() {
  bhs_configuration_ = 0;
}
 ::google::protobuf::int32 AvanconStatusMsg::bhs_configuration() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.AvanconStatusMsg.bhs_configuration)
  return bhs_configuration_;
}
 void AvanconStatusMsg::set_bhs_configuration(::google::protobuf::int32 value) {
  
  bhs_configuration_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.AvanconStatusMsg.bhs_configuration)
}

// optional int32 plc_configuration = 3;
void AvanconStatusMsg::clear_plc_configuration() {
  plc_configuration_ = 0;
}
 ::google::protobuf::int32 AvanconStatusMsg::plc_configuration() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.AvanconStatusMsg.plc_configuration)
  return plc_configuration_;
}
 void AvanconStatusMsg::set_plc_configuration(::google::protobuf::int32 value) {
  
  plc_configuration_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.AvanconStatusMsg.plc_configuration)
}

// optional string plc_version = 4;
void AvanconStatusMsg::clear_plc_version() {
  plc_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& AvanconStatusMsg::plc_version() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.AvanconStatusMsg.plc_version)
  return plc_version_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void AvanconStatusMsg::set_plc_version(const ::std::string& value) {
  
  plc_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:analogic.ancp00.AvanconStatusMsg.plc_version)
}
 void AvanconStatusMsg::set_plc_version(const char* value) {
  
  plc_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:analogic.ancp00.AvanconStatusMsg.plc_version)
}
 void AvanconStatusMsg::set_plc_version(const char* value, size_t size) {
  
  plc_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:analogic.ancp00.AvanconStatusMsg.plc_version)
}
 ::std::string* AvanconStatusMsg::mutable_plc_version() {
  
  // @@protoc_insertion_point(field_mutable:analogic.ancp00.AvanconStatusMsg.plc_version)
  return plc_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* AvanconStatusMsg::release_plc_version() {
  // @@protoc_insertion_point(field_release:analogic.ancp00.AvanconStatusMsg.plc_version)
  
  return plc_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void AvanconStatusMsg::set_allocated_plc_version(::std::string* plc_version) {
  if (plc_version != NULL) {
    
  } else {
    
  }
  plc_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), plc_version);
  // @@protoc_insertion_point(field_set_allocated:analogic.ancp00.AvanconStatusMsg.plc_version)
}

// optional string bhs_version = 5;
void AvanconStatusMsg::clear_bhs_version() {
  bhs_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& AvanconStatusMsg::bhs_version() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.AvanconStatusMsg.bhs_version)
  return bhs_version_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void AvanconStatusMsg::set_bhs_version(const ::std::string& value) {
  
  bhs_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:analogic.ancp00.AvanconStatusMsg.bhs_version)
}
 void AvanconStatusMsg::set_bhs_version(const char* value) {
  
  bhs_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:analogic.ancp00.AvanconStatusMsg.bhs_version)
}
 void AvanconStatusMsg::set_bhs_version(const char* value, size_t size) {
  
  bhs_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:analogic.ancp00.AvanconStatusMsg.bhs_version)
}
 ::std::string* AvanconStatusMsg::mutable_bhs_version() {
  
  // @@protoc_insertion_point(field_mutable:analogic.ancp00.AvanconStatusMsg.bhs_version)
  return bhs_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* AvanconStatusMsg::release_bhs_version() {
  // @@protoc_insertion_point(field_release:analogic.ancp00.AvanconStatusMsg.bhs_version)
  
  return bhs_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void AvanconStatusMsg::set_allocated_bhs_version(::std::string* bhs_version) {
  if (bhs_version != NULL) {
    
  } else {
    
  }
  bhs_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bhs_version);
  // @@protoc_insertion_point(field_set_allocated:analogic.ancp00.AvanconStatusMsg.bhs_version)
}

// optional .analogic.ancp00.ConveyorConfig conv_config = 6;
void AvanconStatusMsg::clear_conv_config() {
  conv_config_ = 0;
}
 ::analogic::ancp00::ConveyorConfig AvanconStatusMsg::conv_config() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.AvanconStatusMsg.conv_config)
  return static_cast< ::analogic::ancp00::ConveyorConfig >(conv_config_);
}
 void AvanconStatusMsg::set_conv_config(::analogic::ancp00::ConveyorConfig value) {
  
  conv_config_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.AvanconStatusMsg.conv_config)
}

// optional string scanner_state = 7;
void AvanconStatusMsg::clear_scanner_state() {
  scanner_state_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& AvanconStatusMsg::scanner_state() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.AvanconStatusMsg.scanner_state)
  return scanner_state_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void AvanconStatusMsg::set_scanner_state(const ::std::string& value) {
  
  scanner_state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:analogic.ancp00.AvanconStatusMsg.scanner_state)
}
 void AvanconStatusMsg::set_scanner_state(const char* value) {
  
  scanner_state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:analogic.ancp00.AvanconStatusMsg.scanner_state)
}
 void AvanconStatusMsg::set_scanner_state(const char* value, size_t size) {
  
  scanner_state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:analogic.ancp00.AvanconStatusMsg.scanner_state)
}
 ::std::string* AvanconStatusMsg::mutable_scanner_state() {
  
  // @@protoc_insertion_point(field_mutable:analogic.ancp00.AvanconStatusMsg.scanner_state)
  return scanner_state_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* AvanconStatusMsg::release_scanner_state() {
  // @@protoc_insertion_point(field_release:analogic.ancp00.AvanconStatusMsg.scanner_state)
  
  return scanner_state_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void AvanconStatusMsg::set_allocated_scanner_state(::std::string* scanner_state) {
  if (scanner_state != NULL) {
    
  } else {
    
  }
  scanner_state_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), scanner_state);
  // @@protoc_insertion_point(field_set_allocated:analogic.ancp00.AvanconStatusMsg.scanner_state)
}

// optional string scanner_substate = 8;
void AvanconStatusMsg::clear_scanner_substate() {
  scanner_substate_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& AvanconStatusMsg::scanner_substate() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.AvanconStatusMsg.scanner_substate)
  return scanner_substate_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void AvanconStatusMsg::set_scanner_substate(const ::std::string& value) {
  
  scanner_substate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:analogic.ancp00.AvanconStatusMsg.scanner_substate)
}
 void AvanconStatusMsg::set_scanner_substate(const char* value) {
  
  scanner_substate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:analogic.ancp00.AvanconStatusMsg.scanner_substate)
}
 void AvanconStatusMsg::set_scanner_substate(const char* value, size_t size) {
  
  scanner_substate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:analogic.ancp00.AvanconStatusMsg.scanner_substate)
}
 ::std::string* AvanconStatusMsg::mutable_scanner_substate() {
  
  // @@protoc_insertion_point(field_mutable:analogic.ancp00.AvanconStatusMsg.scanner_substate)
  return scanner_substate_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* AvanconStatusMsg::release_scanner_substate() {
  // @@protoc_insertion_point(field_release:analogic.ancp00.AvanconStatusMsg.scanner_substate)
  
  return scanner_substate_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void AvanconStatusMsg::set_allocated_scanner_substate(::std::string* scanner_substate) {
  if (scanner_substate != NULL) {
    
  } else {
    
  }
  scanner_substate_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), scanner_substate);
  // @@protoc_insertion_point(field_set_allocated:analogic.ancp00.AvanconStatusMsg.scanner_substate)
}

// optional string bin_type = 9;
void AvanconStatusMsg::clear_bin_type() {
  bin_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& AvanconStatusMsg::bin_type() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.AvanconStatusMsg.bin_type)
  return bin_type_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void AvanconStatusMsg::set_bin_type(const ::std::string& value) {
  
  bin_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:analogic.ancp00.AvanconStatusMsg.bin_type)
}
 void AvanconStatusMsg::set_bin_type(const char* value) {
  
  bin_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:analogic.ancp00.AvanconStatusMsg.bin_type)
}
 void AvanconStatusMsg::set_bin_type(const char* value, size_t size) {
  
  bin_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:analogic.ancp00.AvanconStatusMsg.bin_type)
}
 ::std::string* AvanconStatusMsg::mutable_bin_type() {
  
  // @@protoc_insertion_point(field_mutable:analogic.ancp00.AvanconStatusMsg.bin_type)
  return bin_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* AvanconStatusMsg::release_bin_type() {
  // @@protoc_insertion_point(field_release:analogic.ancp00.AvanconStatusMsg.bin_type)
  
  return bin_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void AvanconStatusMsg::set_allocated_bin_type(::std::string* bin_type) {
  if (bin_type != NULL) {
    
  } else {
    
  }
  bin_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bin_type);
  // @@protoc_insertion_point(field_set_allocated:analogic.ancp00.AvanconStatusMsg.bin_type)
}

// optional string last_bhs_fault = 10;
void AvanconStatusMsg::clear_last_bhs_fault() {
  last_bhs_fault_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& AvanconStatusMsg::last_bhs_fault() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.AvanconStatusMsg.last_bhs_fault)
  return last_bhs_fault_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void AvanconStatusMsg::set_last_bhs_fault(const ::std::string& value) {
  
  last_bhs_fault_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:analogic.ancp00.AvanconStatusMsg.last_bhs_fault)
}
 void AvanconStatusMsg::set_last_bhs_fault(const char* value) {
  
  last_bhs_fault_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:analogic.ancp00.AvanconStatusMsg.last_bhs_fault)
}
 void AvanconStatusMsg::set_last_bhs_fault(const char* value, size_t size) {
  
  last_bhs_fault_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:analogic.ancp00.AvanconStatusMsg.last_bhs_fault)
}
 ::std::string* AvanconStatusMsg::mutable_last_bhs_fault() {
  
  // @@protoc_insertion_point(field_mutable:analogic.ancp00.AvanconStatusMsg.last_bhs_fault)
  return last_bhs_fault_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* AvanconStatusMsg::release_last_bhs_fault() {
  // @@protoc_insertion_point(field_release:analogic.ancp00.AvanconStatusMsg.last_bhs_fault)
  
  return last_bhs_fault_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void AvanconStatusMsg::set_allocated_last_bhs_fault(::std::string* last_bhs_fault) {
  if (last_bhs_fault != NULL) {
    
  } else {
    
  }
  last_bhs_fault_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), last_bhs_fault);
  // @@protoc_insertion_point(field_set_allocated:analogic.ancp00.AvanconStatusMsg.last_bhs_fault)
}

// optional string plc_state = 11;
void AvanconStatusMsg::clear_plc_state() {
  plc_state_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& AvanconStatusMsg::plc_state() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.AvanconStatusMsg.plc_state)
  return plc_state_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void AvanconStatusMsg::set_plc_state(const ::std::string& value) {
  
  plc_state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:analogic.ancp00.AvanconStatusMsg.plc_state)
}
 void AvanconStatusMsg::set_plc_state(const char* value) {
  
  plc_state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:analogic.ancp00.AvanconStatusMsg.plc_state)
}
 void AvanconStatusMsg::set_plc_state(const char* value, size_t size) {
  
  plc_state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:analogic.ancp00.AvanconStatusMsg.plc_state)
}
 ::std::string* AvanconStatusMsg::mutable_plc_state() {
  
  // @@protoc_insertion_point(field_mutable:analogic.ancp00.AvanconStatusMsg.plc_state)
  return plc_state_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* AvanconStatusMsg::release_plc_state() {
  // @@protoc_insertion_point(field_release:analogic.ancp00.AvanconStatusMsg.plc_state)
  
  return plc_state_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void AvanconStatusMsg::set_allocated_plc_state(::std::string* plc_state) {
  if (plc_state != NULL) {
    
  } else {
    
  }
  plc_state_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), plc_state);
  // @@protoc_insertion_point(field_set_allocated:analogic.ancp00.AvanconStatusMsg.plc_state)
}

// optional string last_plc_fault = 12;
void AvanconStatusMsg::clear_last_plc_fault() {
  last_plc_fault_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& AvanconStatusMsg::last_plc_fault() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.AvanconStatusMsg.last_plc_fault)
  return last_plc_fault_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void AvanconStatusMsg::set_last_plc_fault(const ::std::string& value) {
  
  last_plc_fault_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:analogic.ancp00.AvanconStatusMsg.last_plc_fault)
}
 void AvanconStatusMsg::set_last_plc_fault(const char* value) {
  
  last_plc_fault_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:analogic.ancp00.AvanconStatusMsg.last_plc_fault)
}
 void AvanconStatusMsg::set_last_plc_fault(const char* value, size_t size) {
  
  last_plc_fault_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:analogic.ancp00.AvanconStatusMsg.last_plc_fault)
}
 ::std::string* AvanconStatusMsg::mutable_last_plc_fault() {
  
  // @@protoc_insertion_point(field_mutable:analogic.ancp00.AvanconStatusMsg.last_plc_fault)
  return last_plc_fault_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* AvanconStatusMsg::release_last_plc_fault() {
  // @@protoc_insertion_point(field_release:analogic.ancp00.AvanconStatusMsg.last_plc_fault)
  
  return last_plc_fault_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void AvanconStatusMsg::set_allocated_last_plc_fault(::std::string* last_plc_fault) {
  if (last_plc_fault != NULL) {
    
  } else {
    
  }
  last_plc_fault_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), last_plc_fault);
  // @@protoc_insertion_point(field_set_allocated:analogic.ancp00.AvanconStatusMsg.last_plc_fault)
}

// optional int32 attenuation_distance_mm = 13;
void AvanconStatusMsg::clear_attenuation_distance_mm() {
  attenuation_distance_mm_ = 0;
}
 ::google::protobuf::int32 AvanconStatusMsg::attenuation_distance_mm() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.AvanconStatusMsg.attenuation_distance_mm)
  return attenuation_distance_mm_;
}
 void AvanconStatusMsg::set_attenuation_distance_mm(::google::protobuf::int32 value) {
  
  attenuation_distance_mm_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.AvanconStatusMsg.attenuation_distance_mm)
}

// optional int32 attenuation_window_mm = 14;
void AvanconStatusMsg::clear_attenuation_window_mm() {
  attenuation_window_mm_ = 0;
}
 ::google::protobuf::int32 AvanconStatusMsg::attenuation_window_mm() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.AvanconStatusMsg.attenuation_window_mm)
  return attenuation_window_mm_;
}
 void AvanconStatusMsg::set_attenuation_window_mm(::google::protobuf::int32 value) {
  
  attenuation_window_mm_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.AvanconStatusMsg.attenuation_window_mm)
}

// optional bool in_dieback = 15;
void AvanconStatusMsg::clear_in_dieback() {
  in_dieback_ = false;
}
 bool AvanconStatusMsg::in_dieback() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.AvanconStatusMsg.in_dieback)
  return in_dieback_;
}
 void AvanconStatusMsg::set_in_dieback(bool value) {
  
  in_dieback_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.AvanconStatusMsg.in_dieback)
}

// optional bool forced_divert = 16;
void AvanconStatusMsg::clear_forced_divert() {
  forced_divert_ = false;
}
 bool AvanconStatusMsg::forced_divert() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.AvanconStatusMsg.forced_divert)
  return forced_divert_;
}
 void AvanconStatusMsg::set_forced_divert(bool value) {
  
  forced_divert_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.AvanconStatusMsg.forced_divert)
}

// optional bool divert_warning = 17;
void AvanconStatusMsg::clear_divert_warning() {
  divert_warning_ = false;
}
 bool AvanconStatusMsg::divert_warning() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.AvanconStatusMsg.divert_warning)
  return divert_warning_;
}
 void AvanconStatusMsg::set_divert_warning(bool value) {
  
  divert_warning_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.AvanconStatusMsg.divert_warning)
}

// optional .analogic.ancp00.RfidReader entrance_rfid = 18;
bool AvanconStatusMsg::has_entrance_rfid() const {
  return !_is_default_instance_ && entrance_rfid_ != NULL;
}
void AvanconStatusMsg::clear_entrance_rfid() {
  if (GetArenaNoVirtual() == NULL && entrance_rfid_ != NULL) delete entrance_rfid_;
  entrance_rfid_ = NULL;
}
const ::analogic::ancp00::RfidReader& AvanconStatusMsg::entrance_rfid() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.AvanconStatusMsg.entrance_rfid)
  return entrance_rfid_ != NULL ? *entrance_rfid_ : *default_instance_->entrance_rfid_;
}
::analogic::ancp00::RfidReader* AvanconStatusMsg::mutable_entrance_rfid() {
  
  if (entrance_rfid_ == NULL) {
    entrance_rfid_ = new ::analogic::ancp00::RfidReader;
  }
  // @@protoc_insertion_point(field_mutable:analogic.ancp00.AvanconStatusMsg.entrance_rfid)
  return entrance_rfid_;
}
::analogic::ancp00::RfidReader* AvanconStatusMsg::release_entrance_rfid() {
  // @@protoc_insertion_point(field_release:analogic.ancp00.AvanconStatusMsg.entrance_rfid)
  
  ::analogic::ancp00::RfidReader* temp = entrance_rfid_;
  entrance_rfid_ = NULL;
  return temp;
}
void AvanconStatusMsg::set_allocated_entrance_rfid(::analogic::ancp00::RfidReader* entrance_rfid) {
  delete entrance_rfid_;
  entrance_rfid_ = entrance_rfid;
  if (entrance_rfid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:analogic.ancp00.AvanconStatusMsg.entrance_rfid)
}

// optional .analogic.ancp00.RfidReader exit_rfid = 19;
bool AvanconStatusMsg::has_exit_rfid() const {
  return !_is_default_instance_ && exit_rfid_ != NULL;
}
void AvanconStatusMsg::clear_exit_rfid() {
  if (GetArenaNoVirtual() == NULL && exit_rfid_ != NULL) delete exit_rfid_;
  exit_rfid_ = NULL;
}
const ::analogic::ancp00::RfidReader& AvanconStatusMsg::exit_rfid() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.AvanconStatusMsg.exit_rfid)
  return exit_rfid_ != NULL ? *exit_rfid_ : *default_instance_->exit_rfid_;
}
::analogic::ancp00::RfidReader* AvanconStatusMsg::mutable_exit_rfid() {
  
  if (exit_rfid_ == NULL) {
    exit_rfid_ = new ::analogic::ancp00::RfidReader;
  }
  // @@protoc_insertion_point(field_mutable:analogic.ancp00.AvanconStatusMsg.exit_rfid)
  return exit_rfid_;
}
::analogic::ancp00::RfidReader* AvanconStatusMsg::release_exit_rfid() {
  // @@protoc_insertion_point(field_release:analogic.ancp00.AvanconStatusMsg.exit_rfid)
  
  ::analogic::ancp00::RfidReader* temp = exit_rfid_;
  exit_rfid_ = NULL;
  return temp;
}
void AvanconStatusMsg::set_allocated_exit_rfid(::analogic::ancp00::RfidReader* exit_rfid) {
  delete exit_rfid_;
  exit_rfid_ = exit_rfid;
  if (exit_rfid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:analogic.ancp00.AvanconStatusMsg.exit_rfid)
}

// repeated .analogic.ancp00.Conveyor conveyor = 20;
int AvanconStatusMsg::conveyor_size() const {
  return conveyor_.size();
}
void AvanconStatusMsg::clear_conveyor() {
  conveyor_.Clear();
}
const ::analogic::ancp00::Conveyor& AvanconStatusMsg::conveyor(int index) const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.AvanconStatusMsg.conveyor)
  return conveyor_.Get(index);
}
::analogic::ancp00::Conveyor* AvanconStatusMsg::mutable_conveyor(int index) {
  // @@protoc_insertion_point(field_mutable:analogic.ancp00.AvanconStatusMsg.conveyor)
  return conveyor_.Mutable(index);
}
::analogic::ancp00::Conveyor* AvanconStatusMsg::add_conveyor() {
  // @@protoc_insertion_point(field_add:analogic.ancp00.AvanconStatusMsg.conveyor)
  return conveyor_.Add();
}
::google::protobuf::RepeatedPtrField< ::analogic::ancp00::Conveyor >*
AvanconStatusMsg::mutable_conveyor() {
  // @@protoc_insertion_point(field_mutable_list:analogic.ancp00.AvanconStatusMsg.conveyor)
  return &conveyor_;
}
const ::google::protobuf::RepeatedPtrField< ::analogic::ancp00::Conveyor >&
AvanconStatusMsg::conveyor() const {
  // @@protoc_insertion_point(field_list:analogic.ancp00.AvanconStatusMsg.conveyor)
  return conveyor_;
}

// optional bool bhs_warning = 21;
void AvanconStatusMsg::clear_bhs_warning() {
  bhs_warning_ = false;
}
 bool AvanconStatusMsg::bhs_warning() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.AvanconStatusMsg.bhs_warning)
  return bhs_warning_;
}
 void AvanconStatusMsg::set_bhs_warning(bool value) {
  
  bhs_warning_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.AvanconStatusMsg.bhs_warning)
}

// optional bool sensor_warning = 22;
void AvanconStatusMsg::clear_sensor_warning() {
  sensor_warning_ = false;
}
 bool AvanconStatusMsg::sensor_warning() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.AvanconStatusMsg.sensor_warning)
  return sensor_warning_;
}
 void AvanconStatusMsg::set_sensor_warning(bool value) {
  
  sensor_warning_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.AvanconStatusMsg.sensor_warning)
}

// optional bool Z5_exception = 23;
void AvanconStatusMsg::clear_z5_exception() {
  z5_exception_ = false;
}
 bool AvanconStatusMsg::z5_exception() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.AvanconStatusMsg.Z5_exception)
  return z5_exception_;
}
 void AvanconStatusMsg::set_z5_exception(bool value) {
  
  z5_exception_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.AvanconStatusMsg.Z5_exception)
}

// optional bool Z4_longbag = 24;
void AvanconStatusMsg::clear_z4_longbag() {
  z4_longbag_ = false;
}
 bool AvanconStatusMsg::z4_longbag() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.AvanconStatusMsg.Z4_longbag)
  return z4_longbag_;
}
 void AvanconStatusMsg::set_z4_longbag(bool value) {
  
  z4_longbag_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.AvanconStatusMsg.Z4_longbag)
}

// optional bool external_warning = 25;
void AvanconStatusMsg::clear_external_warning() {
  external_warning_ = false;
}
 bool AvanconStatusMsg::external_warning() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.AvanconStatusMsg.external_warning)
  return external_warning_;
}
 void AvanconStatusMsg::set_external_warning(bool value) {
  
  external_warning_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.AvanconStatusMsg.external_warning)
}

// optional int32 total_attenuation_events = 26;
void AvanconStatusMsg::clear_total_attenuation_events() {
  total_attenuation_events_ = 0;
}
 ::google::protobuf::int32 AvanconStatusMsg::total_attenuation_events() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.AvanconStatusMsg.total_attenuation_events)
  return total_attenuation_events_;
}
 void AvanconStatusMsg::set_total_attenuation_events(::google::protobuf::int32 value) {
  
  total_attenuation_events_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.AvanconStatusMsg.total_attenuation_events)
}

// optional int32 total_entrance_events = 27;
void AvanconStatusMsg::clear_total_entrance_events() {
  total_entrance_events_ = 0;
}
 ::google::protobuf::int32 AvanconStatusMsg::total_entrance_events() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.AvanconStatusMsg.total_entrance_events)
  return total_entrance_events_;
}
 void AvanconStatusMsg::set_total_entrance_events(::google::protobuf::int32 value) {
  
  total_entrance_events_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.AvanconStatusMsg.total_entrance_events)
}

// optional int32 total_exit_events = 28;
void AvanconStatusMsg::clear_total_exit_events() {
  total_exit_events_ = 0;
}
 ::google::protobuf::int32 AvanconStatusMsg::total_exit_events() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.AvanconStatusMsg.total_exit_events)
  return total_exit_events_;
}
 void AvanconStatusMsg::set_total_exit_events(::google::protobuf::int32 value) {
  
  total_exit_events_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.AvanconStatusMsg.total_exit_events)
}

// optional int32 total_operator_cleared = 29;
void AvanconStatusMsg::clear_total_operator_cleared() {
  total_operator_cleared_ = 0;
}
 ::google::protobuf::int32 AvanconStatusMsg::total_operator_cleared() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.AvanconStatusMsg.total_operator_cleared)
  return total_operator_cleared_;
}
 void AvanconStatusMsg::set_total_operator_cleared(::google::protobuf::int32 value) {
  
  total_operator_cleared_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.AvanconStatusMsg.total_operator_cleared)
}

// optional int32 total_operator_rejected = 30;
void AvanconStatusMsg::clear_total_operator_rejected() {
  total_operator_rejected_ = 0;
}
 ::google::protobuf::int32 AvanconStatusMsg::total_operator_rejected() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.AvanconStatusMsg.total_operator_rejected)
  return total_operator_rejected_;
}
 void AvanconStatusMsg::set_total_operator_rejected(::google::protobuf::int32 value) {
  
  total_operator_rejected_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.AvanconStatusMsg.total_operator_rejected)
}

// optional int32 total_lost_tracking = 31;
void AvanconStatusMsg::clear_total_lost_tracking() {
  total_lost_tracking_ = 0;
}
 ::google::protobuf::int32 AvanconStatusMsg::total_lost_tracking() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.AvanconStatusMsg.total_lost_tracking)
  return total_lost_tracking_;
}
 void AvanconStatusMsg::set_total_lost_tracking(::google::protobuf::int32 value) {
  
  total_lost_tracking_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.AvanconStatusMsg.total_lost_tracking)
}

// optional int32 total_unlinked = 32;
void AvanconStatusMsg::clear_total_unlinked() {
  total_unlinked_ = 0;
}
 ::google::protobuf::int32 AvanconStatusMsg::total_unlinked() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.AvanconStatusMsg.total_unlinked)
  return total_unlinked_;
}
 void AvanconStatusMsg::set_total_unlinked(::google::protobuf::int32 value) {
  
  total_unlinked_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.AvanconStatusMsg.total_unlinked)
}

// optional int32 total_entrance_rfid_misreads = 33;
void AvanconStatusMsg::clear_total_entrance_rfid_misreads() {
  total_entrance_rfid_misreads_ = 0;
}
 ::google::protobuf::int32 AvanconStatusMsg::total_entrance_rfid_misreads() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.AvanconStatusMsg.total_entrance_rfid_misreads)
  return total_entrance_rfid_misreads_;
}
 void AvanconStatusMsg::set_total_entrance_rfid_misreads(::google::protobuf::int32 value) {
  
  total_entrance_rfid_misreads_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.AvanconStatusMsg.total_entrance_rfid_misreads)
}

// optional int32 total_exit_rfid_misreads = 34;
void AvanconStatusMsg::clear_total_exit_rfid_misreads() {
  total_exit_rfid_misreads_ = 0;
}
 ::google::protobuf::int32 AvanconStatusMsg::total_exit_rfid_misreads() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.AvanconStatusMsg.total_exit_rfid_misreads)
  return total_exit_rfid_misreads_;
}
 void AvanconStatusMsg::set_total_exit_rfid_misreads(::google::protobuf::int32 value) {
  
  total_exit_rfid_misreads_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.AvanconStatusMsg.total_exit_rfid_misreads)
}

// optional int32 total_oversize_bags = 35;
void AvanconStatusMsg::clear_total_oversize_bags() {
  total_oversize_bags_ = 0;
}
 ::google::protobuf::int32 AvanconStatusMsg::total_oversize_bags() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.AvanconStatusMsg.total_oversize_bags)
  return total_oversize_bags_;
}
 void AvanconStatusMsg::set_total_oversize_bags(::google::protobuf::int32 value) {
  
  total_oversize_bags_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.AvanconStatusMsg.total_oversize_bags)
}

// optional int32 total_cut_bags = 36;
void AvanconStatusMsg::clear_total_cut_bags() {
  total_cut_bags_ = 0;
}
 ::google::protobuf::int32 AvanconStatusMsg::total_cut_bags() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.AvanconStatusMsg.total_cut_bags)
  return total_cut_bags_;
}
 void AvanconStatusMsg::set_total_cut_bags(::google::protobuf::int32 value) {
  
  total_cut_bags_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.AvanconStatusMsg.total_cut_bags)
}

// optional bool master_bag_jam = 37;
void AvanconStatusMsg::clear_master_bag_jam() {
  master_bag_jam_ = false;
}
 bool AvanconStatusMsg::master_bag_jam() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.AvanconStatusMsg.master_bag_jam)
  return master_bag_jam_;
}
 void AvanconStatusMsg::set_master_bag_jam(bool value) {
  
  master_bag_jam_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.AvanconStatusMsg.master_bag_jam)
}

// optional int32 bag_jam_bits = 38;
void AvanconStatusMsg::clear_bag_jam_bits() {
  bag_jam_bits_ = 0;
}
 ::google::protobuf::int32 AvanconStatusMsg::bag_jam_bits() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.AvanconStatusMsg.bag_jam_bits)
  return bag_jam_bits_;
}
 void AvanconStatusMsg::set_bag_jam_bits(::google::protobuf::int32 value) {
  
  bag_jam_bits_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.AvanconStatusMsg.bag_jam_bits)
}

// optional int32 attenuation_start_buffer_mm = 39;
void AvanconStatusMsg::clear_attenuation_start_buffer_mm() {
  attenuation_start_buffer_mm_ = 0;
}
 ::google::protobuf::int32 AvanconStatusMsg::attenuation_start_buffer_mm() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.AvanconStatusMsg.attenuation_start_buffer_mm)
  return attenuation_start_buffer_mm_;
}
 void AvanconStatusMsg::set_attenuation_start_buffer_mm(::google::protobuf::int32 value) {
  
  attenuation_start_buffer_mm_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.AvanconStatusMsg.attenuation_start_buffer_mm)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

const ::google::protobuf::EnumDescriptor* ConveyorMotorCmd_Command_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ConveyorMotorCmd_Command_descriptor_;
}
bool ConveyorMotorCmd_Command_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const ConveyorMotorCmd_Command ConveyorMotorCmd::RUN;
const ConveyorMotorCmd_Command ConveyorMotorCmd::STOP;
const ConveyorMotorCmd_Command ConveyorMotorCmd::RESET;
const ConveyorMotorCmd_Command ConveyorMotorCmd::RUN_REVERSE;
const ConveyorMotorCmd_Command ConveyorMotorCmd::Command_MIN;
const ConveyorMotorCmd_Command ConveyorMotorCmd::Command_MAX;
const int ConveyorMotorCmd::Command_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ConveyorMotorCmd::kZoneIdFieldNumber;
const int ConveyorMotorCmd::kIsDiverterFieldNumber;
const int ConveyorMotorCmd::kDivertFieldNumber;
const int ConveyorMotorCmd::kCmdFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ConveyorMotorCmd::ConveyorMotorCmd()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:analogic.ancp00.ConveyorMotorCmd)
}

void ConveyorMotorCmd::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

ConveyorMotorCmd::ConveyorMotorCmd(const ConveyorMotorCmd& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:analogic.ancp00.ConveyorMotorCmd)
}

void ConveyorMotorCmd::SharedCtor() {
    _is_default_instance_ = false;
  _cached_size_ = 0;
  zone_id_ = 0;
  is_diverter_ = false;
  divert_ = false;
  cmd_ = 0;
}

ConveyorMotorCmd::~ConveyorMotorCmd() {
  // @@protoc_insertion_point(destructor:analogic.ancp00.ConveyorMotorCmd)
  SharedDtor();
}

void ConveyorMotorCmd::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ConveyorMotorCmd::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ConveyorMotorCmd::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ConveyorMotorCmd_descriptor_;
}

const ConveyorMotorCmd& ConveyorMotorCmd::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_proto_2fAvanconStatus_2eproto();
  return *default_instance_;
}

ConveyorMotorCmd* ConveyorMotorCmd::default_instance_ = NULL;

ConveyorMotorCmd* ConveyorMotorCmd::New(::google::protobuf::Arena* arena) const {
  ConveyorMotorCmd* n = new ConveyorMotorCmd;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ConveyorMotorCmd::Clear() {
// @@protoc_insertion_point(message_clear_start:analogic.ancp00.ConveyorMotorCmd)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(ConveyorMotorCmd, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<ConveyorMotorCmd*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(zone_id_, cmd_);

#undef ZR_HELPER_
#undef ZR_

}

bool ConveyorMotorCmd::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:analogic.ancp00.ConveyorMotorCmd)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 zone_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &zone_id_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_is_diverter;
        break;
      }

      // optional bool is_diverter = 2;
      case 2: {
        if (tag == 16) {
         parse_is_diverter:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_diverter_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_divert;
        break;
      }

      // optional bool divert = 3;
      case 3: {
        if (tag == 24) {
         parse_divert:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &divert_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_cmd;
        break;
      }

      // optional .analogic.ancp00.ConveyorMotorCmd.Command cmd = 4;
      case 4: {
        if (tag == 32) {
         parse_cmd:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_cmd(static_cast< ::analogic::ancp00::ConveyorMotorCmd_Command >(value));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:analogic.ancp00.ConveyorMotorCmd)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:analogic.ancp00.ConveyorMotorCmd)
  return false;
#undef DO_
}

void ConveyorMotorCmd::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:analogic.ancp00.ConveyorMotorCmd)
  // optional int32 zone_id = 1;
  if (this->zone_id() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->zone_id(), output);
  }

  // optional bool is_diverter = 2;
  if (this->is_diverter() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->is_diverter(), output);
  }

  // optional bool divert = 3;
  if (this->divert() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->divert(), output);
  }

  // optional .analogic.ancp00.ConveyorMotorCmd.Command cmd = 4;
  if (this->cmd() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->cmd(), output);
  }

  // @@protoc_insertion_point(serialize_end:analogic.ancp00.ConveyorMotorCmd)
}

::google::protobuf::uint8* ConveyorMotorCmd::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:analogic.ancp00.ConveyorMotorCmd)
  // optional int32 zone_id = 1;
  if (this->zone_id() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->zone_id(), target);
  }

  // optional bool is_diverter = 2;
  if (this->is_diverter() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->is_diverter(), target);
  }

  // optional bool divert = 3;
  if (this->divert() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->divert(), target);
  }

  // optional .analogic.ancp00.ConveyorMotorCmd.Command cmd = 4;
  if (this->cmd() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      4, this->cmd(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:analogic.ancp00.ConveyorMotorCmd)
  return target;
}

int ConveyorMotorCmd::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:analogic.ancp00.ConveyorMotorCmd)
  int total_size = 0;

  // optional int32 zone_id = 1;
  if (this->zone_id() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->zone_id());
  }

  // optional bool is_diverter = 2;
  if (this->is_diverter() != 0) {
    total_size += 1 + 1;
  }

  // optional bool divert = 3;
  if (this->divert() != 0) {
    total_size += 1 + 1;
  }

  // optional .analogic.ancp00.ConveyorMotorCmd.Command cmd = 4;
  if (this->cmd() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->cmd());
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ConveyorMotorCmd::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:analogic.ancp00.ConveyorMotorCmd)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const ConveyorMotorCmd* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ConveyorMotorCmd>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:analogic.ancp00.ConveyorMotorCmd)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:analogic.ancp00.ConveyorMotorCmd)
    MergeFrom(*source);
  }
}

void ConveyorMotorCmd::MergeFrom(const ConveyorMotorCmd& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:analogic.ancp00.ConveyorMotorCmd)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from.zone_id() != 0) {
    set_zone_id(from.zone_id());
  }
  if (from.is_diverter() != 0) {
    set_is_diverter(from.is_diverter());
  }
  if (from.divert() != 0) {
    set_divert(from.divert());
  }
  if (from.cmd() != 0) {
    set_cmd(from.cmd());
  }
}

void ConveyorMotorCmd::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:analogic.ancp00.ConveyorMotorCmd)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ConveyorMotorCmd::CopyFrom(const ConveyorMotorCmd& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:analogic.ancp00.ConveyorMotorCmd)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConveyorMotorCmd::IsInitialized() const {

  return true;
}

void ConveyorMotorCmd::Swap(ConveyorMotorCmd* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ConveyorMotorCmd::InternalSwap(ConveyorMotorCmd* other) {
  std::swap(zone_id_, other->zone_id_);
  std::swap(is_diverter_, other->is_diverter_);
  std::swap(divert_, other->divert_);
  std::swap(cmd_, other->cmd_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ConveyorMotorCmd::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ConveyorMotorCmd_descriptor_;
  metadata.reflection = ConveyorMotorCmd_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ConveyorMotorCmd

// optional int32 zone_id = 1;
void ConveyorMotorCmd::clear_zone_id() {
  zone_id_ = 0;
}
 ::google::protobuf::int32 ConveyorMotorCmd::zone_id() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.ConveyorMotorCmd.zone_id)
  return zone_id_;
}
 void ConveyorMotorCmd::set_zone_id(::google::protobuf::int32 value) {
  
  zone_id_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.ConveyorMotorCmd.zone_id)
}

// optional bool is_diverter = 2;
void ConveyorMotorCmd::clear_is_diverter() {
  is_diverter_ = false;
}
 bool ConveyorMotorCmd::is_diverter() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.ConveyorMotorCmd.is_diverter)
  return is_diverter_;
}
 void ConveyorMotorCmd::set_is_diverter(bool value) {
  
  is_diverter_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.ConveyorMotorCmd.is_diverter)
}

// optional bool divert = 3;
void ConveyorMotorCmd::clear_divert() {
  divert_ = false;
}
 bool ConveyorMotorCmd::divert() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.ConveyorMotorCmd.divert)
  return divert_;
}
 void ConveyorMotorCmd::set_divert(bool value) {
  
  divert_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.ConveyorMotorCmd.divert)
}

// optional .analogic.ancp00.ConveyorMotorCmd.Command cmd = 4;
void ConveyorMotorCmd::clear_cmd() {
  cmd_ = 0;
}
 ::analogic::ancp00::ConveyorMotorCmd_Command ConveyorMotorCmd::cmd() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.ConveyorMotorCmd.cmd)
  return static_cast< ::analogic::ancp00::ConveyorMotorCmd_Command >(cmd_);
}
 void ConveyorMotorCmd::set_cmd(::analogic::ancp00::ConveyorMotorCmd_Command value) {
  
  cmd_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.ConveyorMotorCmd.cmd)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ConveyorMotorCmdMsg::kCmdsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ConveyorMotorCmdMsg::ConveyorMotorCmdMsg()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:analogic.ancp00.ConveyorMotorCmdMsg)
}

void ConveyorMotorCmdMsg::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

ConveyorMotorCmdMsg::ConveyorMotorCmdMsg(const ConveyorMotorCmdMsg& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:analogic.ancp00.ConveyorMotorCmdMsg)
}

void ConveyorMotorCmdMsg::SharedCtor() {
    _is_default_instance_ = false;
  _cached_size_ = 0;
}

ConveyorMotorCmdMsg::~ConveyorMotorCmdMsg() {
  // @@protoc_insertion_point(destructor:analogic.ancp00.ConveyorMotorCmdMsg)
  SharedDtor();
}

void ConveyorMotorCmdMsg::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ConveyorMotorCmdMsg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ConveyorMotorCmdMsg::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ConveyorMotorCmdMsg_descriptor_;
}

const ConveyorMotorCmdMsg& ConveyorMotorCmdMsg::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_proto_2fAvanconStatus_2eproto();
  return *default_instance_;
}

ConveyorMotorCmdMsg* ConveyorMotorCmdMsg::default_instance_ = NULL;

ConveyorMotorCmdMsg* ConveyorMotorCmdMsg::New(::google::protobuf::Arena* arena) const {
  ConveyorMotorCmdMsg* n = new ConveyorMotorCmdMsg;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ConveyorMotorCmdMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:analogic.ancp00.ConveyorMotorCmdMsg)
  cmds_.Clear();
}

bool ConveyorMotorCmdMsg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:analogic.ancp00.ConveyorMotorCmdMsg)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .analogic.ancp00.ConveyorMotorCmd cmds = 1;
      case 1: {
        if (tag == 10) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_cmds:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_cmds()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_loop_cmds;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:analogic.ancp00.ConveyorMotorCmdMsg)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:analogic.ancp00.ConveyorMotorCmdMsg)
  return false;
#undef DO_
}

void ConveyorMotorCmdMsg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:analogic.ancp00.ConveyorMotorCmdMsg)
  // repeated .analogic.ancp00.ConveyorMotorCmd cmds = 1;
  for (unsigned int i = 0, n = this->cmds_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->cmds(i), output);
  }

  // @@protoc_insertion_point(serialize_end:analogic.ancp00.ConveyorMotorCmdMsg)
}

::google::protobuf::uint8* ConveyorMotorCmdMsg::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:analogic.ancp00.ConveyorMotorCmdMsg)
  // repeated .analogic.ancp00.ConveyorMotorCmd cmds = 1;
  for (unsigned int i = 0, n = this->cmds_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, this->cmds(i), false, target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:analogic.ancp00.ConveyorMotorCmdMsg)
  return target;
}

int ConveyorMotorCmdMsg::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:analogic.ancp00.ConveyorMotorCmdMsg)
  int total_size = 0;

  // repeated .analogic.ancp00.ConveyorMotorCmd cmds = 1;
  total_size += 1 * this->cmds_size();
  for (int i = 0; i < this->cmds_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->cmds(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ConveyorMotorCmdMsg::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:analogic.ancp00.ConveyorMotorCmdMsg)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const ConveyorMotorCmdMsg* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ConveyorMotorCmdMsg>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:analogic.ancp00.ConveyorMotorCmdMsg)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:analogic.ancp00.ConveyorMotorCmdMsg)
    MergeFrom(*source);
  }
}

void ConveyorMotorCmdMsg::MergeFrom(const ConveyorMotorCmdMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:analogic.ancp00.ConveyorMotorCmdMsg)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  cmds_.MergeFrom(from.cmds_);
}

void ConveyorMotorCmdMsg::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:analogic.ancp00.ConveyorMotorCmdMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ConveyorMotorCmdMsg::CopyFrom(const ConveyorMotorCmdMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:analogic.ancp00.ConveyorMotorCmdMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConveyorMotorCmdMsg::IsInitialized() const {

  return true;
}

void ConveyorMotorCmdMsg::Swap(ConveyorMotorCmdMsg* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ConveyorMotorCmdMsg::InternalSwap(ConveyorMotorCmdMsg* other) {
  cmds_.UnsafeArenaSwap(&other->cmds_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ConveyorMotorCmdMsg::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ConveyorMotorCmdMsg_descriptor_;
  metadata.reflection = ConveyorMotorCmdMsg_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ConveyorMotorCmdMsg

// repeated .analogic.ancp00.ConveyorMotorCmd cmds = 1;
int ConveyorMotorCmdMsg::cmds_size() const {
  return cmds_.size();
}
void ConveyorMotorCmdMsg::clear_cmds() {
  cmds_.Clear();
}
const ::analogic::ancp00::ConveyorMotorCmd& ConveyorMotorCmdMsg::cmds(int index) const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.ConveyorMotorCmdMsg.cmds)
  return cmds_.Get(index);
}
::analogic::ancp00::ConveyorMotorCmd* ConveyorMotorCmdMsg::mutable_cmds(int index) {
  // @@protoc_insertion_point(field_mutable:analogic.ancp00.ConveyorMotorCmdMsg.cmds)
  return cmds_.Mutable(index);
}
::analogic::ancp00::ConveyorMotorCmd* ConveyorMotorCmdMsg::add_cmds() {
  // @@protoc_insertion_point(field_add:analogic.ancp00.ConveyorMotorCmdMsg.cmds)
  return cmds_.Add();
}
::google::protobuf::RepeatedPtrField< ::analogic::ancp00::ConveyorMotorCmd >*
ConveyorMotorCmdMsg::mutable_cmds() {
  // @@protoc_insertion_point(field_mutable_list:analogic.ancp00.ConveyorMotorCmdMsg.cmds)
  return &cmds_;
}
const ::google::protobuf::RepeatedPtrField< ::analogic::ancp00::ConveyorMotorCmd >&
ConveyorMotorCmdMsg::cmds() const {
  // @@protoc_insertion_point(field_list:analogic.ancp00.ConveyorMotorCmdMsg.cmds)
  return cmds_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace ancp00
}  // namespace analogic

// @@protoc_insertion_point(global_scope)
