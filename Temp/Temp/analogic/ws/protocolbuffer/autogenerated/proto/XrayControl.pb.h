// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/XrayControl.proto

#ifndef PROTOBUF_proto_2fXrayControl_2eproto__INCLUDED
#define PROTOBUF_proto_2fXrayControl_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace analogic {
namespace ancp00 {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_proto_2fXrayControl_2eproto();
void protobuf_AssignDesc_proto_2fXrayControl_2eproto();
void protobuf_ShutdownFile_proto_2fXrayControl_2eproto();

class XrayControlEvent;
class XrayControlMsg;
class XrayControlStatusMsg;

enum XrayControlMsg_XrayControlCmd {
  XrayControlMsg_XrayControlCmd_XRAY_ON = 0,
  XrayControlMsg_XrayControlCmd_XRAY_OFF = 1,
  XrayControlMsg_XrayControlCmd_SEASON = 2,
  XrayControlMsg_XrayControlCmd_RESET = 3,
  XrayControlMsg_XrayControlCmd_MAXIMIZE = 4,
  XrayControlMsg_XrayControlCmd_MINIMIZE = 5,
  XrayControlMsg_XrayControlCmd_LAMP_TEST_ON = 6,
  XrayControlMsg_XrayControlCmd_LAMP_TEST_OFF = 7,
  XrayControlMsg_XrayControlCmd_NEW_TUBE_RESET = 8,
  XrayControlMsg_XrayControlCmd_POWERLINK_ENABLE = 9,
  XrayControlMsg_XrayControlCmd_POWERLINK_DISABLE = 10,
  XrayControlMsg_XrayControlCmd_XrayControlMsg_XrayControlCmd_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  XrayControlMsg_XrayControlCmd_XrayControlMsg_XrayControlCmd_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool XrayControlMsg_XrayControlCmd_IsValid(int value);
const XrayControlMsg_XrayControlCmd XrayControlMsg_XrayControlCmd_XrayControlCmd_MIN = XrayControlMsg_XrayControlCmd_XRAY_ON;
const XrayControlMsg_XrayControlCmd XrayControlMsg_XrayControlCmd_XrayControlCmd_MAX = XrayControlMsg_XrayControlCmd_POWERLINK_DISABLE;
const int XrayControlMsg_XrayControlCmd_XrayControlCmd_ARRAYSIZE = XrayControlMsg_XrayControlCmd_XrayControlCmd_MAX + 1;

const ::google::protobuf::EnumDescriptor* XrayControlMsg_XrayControlCmd_descriptor();
inline const ::std::string& XrayControlMsg_XrayControlCmd_Name(XrayControlMsg_XrayControlCmd value) {
  return ::google::protobuf::internal::NameOfEnum(
    XrayControlMsg_XrayControlCmd_descriptor(), value);
}
inline bool XrayControlMsg_XrayControlCmd_Parse(
    const ::std::string& name, XrayControlMsg_XrayControlCmd* value) {
  return ::google::protobuf::internal::ParseNamedEnum<XrayControlMsg_XrayControlCmd>(
    XrayControlMsg_XrayControlCmd_descriptor(), name, value);
}
enum XrayControlMsg_SeasoningMode {
  XrayControlMsg_SeasoningMode_NONE = 0,
  XrayControlMsg_SeasoningMode_SHORT = 1,
  XrayControlMsg_SeasoningMode_MEDIUM = 2,
  XrayControlMsg_SeasoningMode_LONG = 3,
  XrayControlMsg_SeasoningMode_XrayControlMsg_SeasoningMode_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  XrayControlMsg_SeasoningMode_XrayControlMsg_SeasoningMode_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool XrayControlMsg_SeasoningMode_IsValid(int value);
const XrayControlMsg_SeasoningMode XrayControlMsg_SeasoningMode_SeasoningMode_MIN = XrayControlMsg_SeasoningMode_NONE;
const XrayControlMsg_SeasoningMode XrayControlMsg_SeasoningMode_SeasoningMode_MAX = XrayControlMsg_SeasoningMode_LONG;
const int XrayControlMsg_SeasoningMode_SeasoningMode_ARRAYSIZE = XrayControlMsg_SeasoningMode_SeasoningMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* XrayControlMsg_SeasoningMode_descriptor();
inline const ::std::string& XrayControlMsg_SeasoningMode_Name(XrayControlMsg_SeasoningMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    XrayControlMsg_SeasoningMode_descriptor(), value);
}
inline bool XrayControlMsg_SeasoningMode_Parse(
    const ::std::string& name, XrayControlMsg_SeasoningMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<XrayControlMsg_SeasoningMode>(
    XrayControlMsg_SeasoningMode_descriptor(), name, value);
}
enum XrayControlStatusMsg_XrayControlState {
  XrayControlStatusMsg_XrayControlState_UNINIT = 0,
  XrayControlStatusMsg_XrayControlState_XRAY_OFF = 1,
  XrayControlStatusMsg_XrayControlState_XRAY_SEASONING = 2,
  XrayControlStatusMsg_XrayControlState_XRAY_ON = 3,
  XrayControlStatusMsg_XrayControlState_XRAY_FAULT = 4,
  XrayControlStatusMsg_XrayControlState_XrayControlStatusMsg_XrayControlState_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  XrayControlStatusMsg_XrayControlState_XrayControlStatusMsg_XrayControlState_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool XrayControlStatusMsg_XrayControlState_IsValid(int value);
const XrayControlStatusMsg_XrayControlState XrayControlStatusMsg_XrayControlState_XrayControlState_MIN = XrayControlStatusMsg_XrayControlState_UNINIT;
const XrayControlStatusMsg_XrayControlState XrayControlStatusMsg_XrayControlState_XrayControlState_MAX = XrayControlStatusMsg_XrayControlState_XRAY_FAULT;
const int XrayControlStatusMsg_XrayControlState_XrayControlState_ARRAYSIZE = XrayControlStatusMsg_XrayControlState_XrayControlState_MAX + 1;

const ::google::protobuf::EnumDescriptor* XrayControlStatusMsg_XrayControlState_descriptor();
inline const ::std::string& XrayControlStatusMsg_XrayControlState_Name(XrayControlStatusMsg_XrayControlState value) {
  return ::google::protobuf::internal::NameOfEnum(
    XrayControlStatusMsg_XrayControlState_descriptor(), value);
}
inline bool XrayControlStatusMsg_XrayControlState_Parse(
    const ::std::string& name, XrayControlStatusMsg_XrayControlState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<XrayControlStatusMsg_XrayControlState>(
    XrayControlStatusMsg_XrayControlState_descriptor(), name, value);
}
enum XrayControlStatusMsg_XrayControlSubstate {
  XrayControlStatusMsg_XrayControlSubstate_MAXIMIZED = 0,
  XrayControlStatusMsg_XrayControlSubstate_MINIMIZED = 1,
  XrayControlStatusMsg_XrayControlSubstate_XrayControlStatusMsg_XrayControlSubstate_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  XrayControlStatusMsg_XrayControlSubstate_XrayControlStatusMsg_XrayControlSubstate_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool XrayControlStatusMsg_XrayControlSubstate_IsValid(int value);
const XrayControlStatusMsg_XrayControlSubstate XrayControlStatusMsg_XrayControlSubstate_XrayControlSubstate_MIN = XrayControlStatusMsg_XrayControlSubstate_MAXIMIZED;
const XrayControlStatusMsg_XrayControlSubstate XrayControlStatusMsg_XrayControlSubstate_XrayControlSubstate_MAX = XrayControlStatusMsg_XrayControlSubstate_MINIMIZED;
const int XrayControlStatusMsg_XrayControlSubstate_XrayControlSubstate_ARRAYSIZE = XrayControlStatusMsg_XrayControlSubstate_XrayControlSubstate_MAX + 1;

const ::google::protobuf::EnumDescriptor* XrayControlStatusMsg_XrayControlSubstate_descriptor();
inline const ::std::string& XrayControlStatusMsg_XrayControlSubstate_Name(XrayControlStatusMsg_XrayControlSubstate value) {
  return ::google::protobuf::internal::NameOfEnum(
    XrayControlStatusMsg_XrayControlSubstate_descriptor(), value);
}
inline bool XrayControlStatusMsg_XrayControlSubstate_Parse(
    const ::std::string& name, XrayControlStatusMsg_XrayControlSubstate* value) {
  return ::google::protobuf::internal::ParseNamedEnum<XrayControlStatusMsg_XrayControlSubstate>(
    XrayControlStatusMsg_XrayControlSubstate_descriptor(), name, value);
}
enum XrayControlEvent_EVENT_ID {
  XrayControlEvent_EVENT_ID_NOT_USED = 0,
  XrayControlEvent_EVENT_ID_INIT_COMPLETE_EVENT = 1,
  XrayControlEvent_EVENT_ID_ON_COMMAND_EVENT = 2,
  XrayControlEvent_EVENT_ID_OFF_COMMAND_EVENT = 3,
  XrayControlEvent_EVENT_ID_SEASON_COMMAND_EVENT = 4,
  XrayControlEvent_EVENT_ID_SEASONING_COMPLETE_EVENT = 5,
  XrayControlEvent_EVENT_ID_MINIMIZE_COMMAND_EVENT = 6,
  XrayControlEvent_EVENT_ID_MAXIMIZE_COMMAND_EVENT = 7,
  XrayControlEvent_EVENT_ID_FAULT_EVENT = 8,
  XrayControlEvent_EVENT_ID_RESET_FAULT_EVENT = 9,
  XrayControlEvent_EVENT_ID_XrayControlEvent_EVENT_ID_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  XrayControlEvent_EVENT_ID_XrayControlEvent_EVENT_ID_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool XrayControlEvent_EVENT_ID_IsValid(int value);
const XrayControlEvent_EVENT_ID XrayControlEvent_EVENT_ID_EVENT_ID_MIN = XrayControlEvent_EVENT_ID_NOT_USED;
const XrayControlEvent_EVENT_ID XrayControlEvent_EVENT_ID_EVENT_ID_MAX = XrayControlEvent_EVENT_ID_RESET_FAULT_EVENT;
const int XrayControlEvent_EVENT_ID_EVENT_ID_ARRAYSIZE = XrayControlEvent_EVENT_ID_EVENT_ID_MAX + 1;

const ::google::protobuf::EnumDescriptor* XrayControlEvent_EVENT_ID_descriptor();
inline const ::std::string& XrayControlEvent_EVENT_ID_Name(XrayControlEvent_EVENT_ID value) {
  return ::google::protobuf::internal::NameOfEnum(
    XrayControlEvent_EVENT_ID_descriptor(), value);
}
inline bool XrayControlEvent_EVENT_ID_Parse(
    const ::std::string& name, XrayControlEvent_EVENT_ID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<XrayControlEvent_EVENT_ID>(
    XrayControlEvent_EVENT_ID_descriptor(), name, value);
}
// ===================================================================

class XrayControlMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:analogic.ancp00.XrayControlMsg) */ {
 public:
  XrayControlMsg();
  virtual ~XrayControlMsg();

  XrayControlMsg(const XrayControlMsg& from);

  inline XrayControlMsg& operator=(const XrayControlMsg& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const XrayControlMsg& default_instance();

  void Swap(XrayControlMsg* other);

  // implements Message ----------------------------------------------

  inline XrayControlMsg* New() const { return New(NULL); }

  XrayControlMsg* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const XrayControlMsg& from);
  void MergeFrom(const XrayControlMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(XrayControlMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef XrayControlMsg_XrayControlCmd XrayControlCmd;
  static const XrayControlCmd XRAY_ON =
    XrayControlMsg_XrayControlCmd_XRAY_ON;
  static const XrayControlCmd XRAY_OFF =
    XrayControlMsg_XrayControlCmd_XRAY_OFF;
  static const XrayControlCmd SEASON =
    XrayControlMsg_XrayControlCmd_SEASON;
  static const XrayControlCmd RESET =
    XrayControlMsg_XrayControlCmd_RESET;
  static const XrayControlCmd MAXIMIZE =
    XrayControlMsg_XrayControlCmd_MAXIMIZE;
  static const XrayControlCmd MINIMIZE =
    XrayControlMsg_XrayControlCmd_MINIMIZE;
  static const XrayControlCmd LAMP_TEST_ON =
    XrayControlMsg_XrayControlCmd_LAMP_TEST_ON;
  static const XrayControlCmd LAMP_TEST_OFF =
    XrayControlMsg_XrayControlCmd_LAMP_TEST_OFF;
  static const XrayControlCmd NEW_TUBE_RESET =
    XrayControlMsg_XrayControlCmd_NEW_TUBE_RESET;
  static const XrayControlCmd POWERLINK_ENABLE =
    XrayControlMsg_XrayControlCmd_POWERLINK_ENABLE;
  static const XrayControlCmd POWERLINK_DISABLE =
    XrayControlMsg_XrayControlCmd_POWERLINK_DISABLE;
  static inline bool XrayControlCmd_IsValid(int value) {
    return XrayControlMsg_XrayControlCmd_IsValid(value);
  }
  static const XrayControlCmd XrayControlCmd_MIN =
    XrayControlMsg_XrayControlCmd_XrayControlCmd_MIN;
  static const XrayControlCmd XrayControlCmd_MAX =
    XrayControlMsg_XrayControlCmd_XrayControlCmd_MAX;
  static const int XrayControlCmd_ARRAYSIZE =
    XrayControlMsg_XrayControlCmd_XrayControlCmd_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  XrayControlCmd_descriptor() {
    return XrayControlMsg_XrayControlCmd_descriptor();
  }
  static inline const ::std::string& XrayControlCmd_Name(XrayControlCmd value) {
    return XrayControlMsg_XrayControlCmd_Name(value);
  }
  static inline bool XrayControlCmd_Parse(const ::std::string& name,
      XrayControlCmd* value) {
    return XrayControlMsg_XrayControlCmd_Parse(name, value);
  }

  typedef XrayControlMsg_SeasoningMode SeasoningMode;
  static const SeasoningMode NONE =
    XrayControlMsg_SeasoningMode_NONE;
  static const SeasoningMode SHORT =
    XrayControlMsg_SeasoningMode_SHORT;
  static const SeasoningMode MEDIUM =
    XrayControlMsg_SeasoningMode_MEDIUM;
  static const SeasoningMode LONG =
    XrayControlMsg_SeasoningMode_LONG;
  static inline bool SeasoningMode_IsValid(int value) {
    return XrayControlMsg_SeasoningMode_IsValid(value);
  }
  static const SeasoningMode SeasoningMode_MIN =
    XrayControlMsg_SeasoningMode_SeasoningMode_MIN;
  static const SeasoningMode SeasoningMode_MAX =
    XrayControlMsg_SeasoningMode_SeasoningMode_MAX;
  static const int SeasoningMode_ARRAYSIZE =
    XrayControlMsg_SeasoningMode_SeasoningMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SeasoningMode_descriptor() {
    return XrayControlMsg_SeasoningMode_descriptor();
  }
  static inline const ::std::string& SeasoningMode_Name(SeasoningMode value) {
    return XrayControlMsg_SeasoningMode_Name(value);
  }
  static inline bool SeasoningMode_Parse(const ::std::string& name,
      SeasoningMode* value) {
    return XrayControlMsg_SeasoningMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .analogic.ancp00.XrayControlMsg.XrayControlCmd cmd_id = 1;
  void clear_cmd_id();
  static const int kCmdIdFieldNumber = 1;
  ::analogic::ancp00::XrayControlMsg_XrayControlCmd cmd_id() const;
  void set_cmd_id(::analogic::ancp00::XrayControlMsg_XrayControlCmd value);

  // optional .analogic.ancp00.XrayControlMsg.SeasoningMode mode = 2;
  void clear_mode();
  static const int kModeFieldNumber = 2;
  ::analogic::ancp00::XrayControlMsg_SeasoningMode mode() const;
  void set_mode(::analogic::ancp00::XrayControlMsg_SeasoningMode value);

  // @@protoc_insertion_point(class_scope:analogic.ancp00.XrayControlMsg)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  int cmd_id_;
  int mode_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_proto_2fXrayControl_2eproto();
  friend void protobuf_AssignDesc_proto_2fXrayControl_2eproto();
  friend void protobuf_ShutdownFile_proto_2fXrayControl_2eproto();

  void InitAsDefaultInstance();
  static XrayControlMsg* default_instance_;
};
// -------------------------------------------------------------------

class XrayControlStatusMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:analogic.ancp00.XrayControlStatusMsg) */ {
 public:
  XrayControlStatusMsg();
  virtual ~XrayControlStatusMsg();

  XrayControlStatusMsg(const XrayControlStatusMsg& from);

  inline XrayControlStatusMsg& operator=(const XrayControlStatusMsg& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const XrayControlStatusMsg& default_instance();

  void Swap(XrayControlStatusMsg* other);

  // implements Message ----------------------------------------------

  inline XrayControlStatusMsg* New() const { return New(NULL); }

  XrayControlStatusMsg* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const XrayControlStatusMsg& from);
  void MergeFrom(const XrayControlStatusMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(XrayControlStatusMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef XrayControlStatusMsg_XrayControlState XrayControlState;
  static const XrayControlState UNINIT =
    XrayControlStatusMsg_XrayControlState_UNINIT;
  static const XrayControlState XRAY_OFF =
    XrayControlStatusMsg_XrayControlState_XRAY_OFF;
  static const XrayControlState XRAY_SEASONING =
    XrayControlStatusMsg_XrayControlState_XRAY_SEASONING;
  static const XrayControlState XRAY_ON =
    XrayControlStatusMsg_XrayControlState_XRAY_ON;
  static const XrayControlState XRAY_FAULT =
    XrayControlStatusMsg_XrayControlState_XRAY_FAULT;
  static inline bool XrayControlState_IsValid(int value) {
    return XrayControlStatusMsg_XrayControlState_IsValid(value);
  }
  static const XrayControlState XrayControlState_MIN =
    XrayControlStatusMsg_XrayControlState_XrayControlState_MIN;
  static const XrayControlState XrayControlState_MAX =
    XrayControlStatusMsg_XrayControlState_XrayControlState_MAX;
  static const int XrayControlState_ARRAYSIZE =
    XrayControlStatusMsg_XrayControlState_XrayControlState_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  XrayControlState_descriptor() {
    return XrayControlStatusMsg_XrayControlState_descriptor();
  }
  static inline const ::std::string& XrayControlState_Name(XrayControlState value) {
    return XrayControlStatusMsg_XrayControlState_Name(value);
  }
  static inline bool XrayControlState_Parse(const ::std::string& name,
      XrayControlState* value) {
    return XrayControlStatusMsg_XrayControlState_Parse(name, value);
  }

  typedef XrayControlStatusMsg_XrayControlSubstate XrayControlSubstate;
  static const XrayControlSubstate MAXIMIZED =
    XrayControlStatusMsg_XrayControlSubstate_MAXIMIZED;
  static const XrayControlSubstate MINIMIZED =
    XrayControlStatusMsg_XrayControlSubstate_MINIMIZED;
  static inline bool XrayControlSubstate_IsValid(int value) {
    return XrayControlStatusMsg_XrayControlSubstate_IsValid(value);
  }
  static const XrayControlSubstate XrayControlSubstate_MIN =
    XrayControlStatusMsg_XrayControlSubstate_XrayControlSubstate_MIN;
  static const XrayControlSubstate XrayControlSubstate_MAX =
    XrayControlStatusMsg_XrayControlSubstate_XrayControlSubstate_MAX;
  static const int XrayControlSubstate_ARRAYSIZE =
    XrayControlStatusMsg_XrayControlSubstate_XrayControlSubstate_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  XrayControlSubstate_descriptor() {
    return XrayControlStatusMsg_XrayControlSubstate_descriptor();
  }
  static inline const ::std::string& XrayControlSubstate_Name(XrayControlSubstate value) {
    return XrayControlStatusMsg_XrayControlSubstate_Name(value);
  }
  static inline bool XrayControlSubstate_Parse(const ::std::string& name,
      XrayControlSubstate* value) {
    return XrayControlStatusMsg_XrayControlSubstate_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .analogic.ancp00.XrayControlStatusMsg.XrayControlState state = 1;
  void clear_state();
  static const int kStateFieldNumber = 1;
  ::analogic::ancp00::XrayControlStatusMsg_XrayControlState state() const;
  void set_state(::analogic::ancp00::XrayControlStatusMsg_XrayControlState value);

  // optional .analogic.ancp00.XrayControlStatusMsg.XrayControlSubstate substate = 2;
  void clear_substate();
  static const int kSubstateFieldNumber = 2;
  ::analogic::ancp00::XrayControlStatusMsg_XrayControlSubstate substate() const;
  void set_substate(::analogic::ancp00::XrayControlStatusMsg_XrayControlSubstate value);

  // optional uint64 xray_on_hours = 3;
  void clear_xray_on_hours();
  static const int kXrayOnHoursFieldNumber = 3;
  ::google::protobuf::uint64 xray_on_hours() const;
  void set_xray_on_hours(::google::protobuf::uint64 value);

  // optional string last_xray_on_time = 4;
  void clear_last_xray_on_time();
  static const int kLastXrayOnTimeFieldNumber = 4;
  const ::std::string& last_xray_on_time() const;
  void set_last_xray_on_time(const ::std::string& value);
  void set_last_xray_on_time(const char* value);
  void set_last_xray_on_time(const char* value, size_t size);
  ::std::string* mutable_last_xray_on_time();
  ::std::string* release_last_xray_on_time();
  void set_allocated_last_xray_on_time(::std::string* last_xray_on_time);

  // @@protoc_insertion_point(class_scope:analogic.ancp00.XrayControlStatusMsg)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  int state_;
  int substate_;
  ::google::protobuf::uint64 xray_on_hours_;
  ::google::protobuf::internal::ArenaStringPtr last_xray_on_time_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_proto_2fXrayControl_2eproto();
  friend void protobuf_AssignDesc_proto_2fXrayControl_2eproto();
  friend void protobuf_ShutdownFile_proto_2fXrayControl_2eproto();

  void InitAsDefaultInstance();
  static XrayControlStatusMsg* default_instance_;
};
// -------------------------------------------------------------------

class XrayControlEvent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:analogic.ancp00.XrayControlEvent) */ {
 public:
  XrayControlEvent();
  virtual ~XrayControlEvent();

  XrayControlEvent(const XrayControlEvent& from);

  inline XrayControlEvent& operator=(const XrayControlEvent& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const XrayControlEvent& default_instance();

  void Swap(XrayControlEvent* other);

  // implements Message ----------------------------------------------

  inline XrayControlEvent* New() const { return New(NULL); }

  XrayControlEvent* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const XrayControlEvent& from);
  void MergeFrom(const XrayControlEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(XrayControlEvent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef XrayControlEvent_EVENT_ID EVENT_ID;
  static const EVENT_ID NOT_USED =
    XrayControlEvent_EVENT_ID_NOT_USED;
  static const EVENT_ID INIT_COMPLETE_EVENT =
    XrayControlEvent_EVENT_ID_INIT_COMPLETE_EVENT;
  static const EVENT_ID ON_COMMAND_EVENT =
    XrayControlEvent_EVENT_ID_ON_COMMAND_EVENT;
  static const EVENT_ID OFF_COMMAND_EVENT =
    XrayControlEvent_EVENT_ID_OFF_COMMAND_EVENT;
  static const EVENT_ID SEASON_COMMAND_EVENT =
    XrayControlEvent_EVENT_ID_SEASON_COMMAND_EVENT;
  static const EVENT_ID SEASONING_COMPLETE_EVENT =
    XrayControlEvent_EVENT_ID_SEASONING_COMPLETE_EVENT;
  static const EVENT_ID MINIMIZE_COMMAND_EVENT =
    XrayControlEvent_EVENT_ID_MINIMIZE_COMMAND_EVENT;
  static const EVENT_ID MAXIMIZE_COMMAND_EVENT =
    XrayControlEvent_EVENT_ID_MAXIMIZE_COMMAND_EVENT;
  static const EVENT_ID FAULT_EVENT =
    XrayControlEvent_EVENT_ID_FAULT_EVENT;
  static const EVENT_ID RESET_FAULT_EVENT =
    XrayControlEvent_EVENT_ID_RESET_FAULT_EVENT;
  static inline bool EVENT_ID_IsValid(int value) {
    return XrayControlEvent_EVENT_ID_IsValid(value);
  }
  static const EVENT_ID EVENT_ID_MIN =
    XrayControlEvent_EVENT_ID_EVENT_ID_MIN;
  static const EVENT_ID EVENT_ID_MAX =
    XrayControlEvent_EVENT_ID_EVENT_ID_MAX;
  static const int EVENT_ID_ARRAYSIZE =
    XrayControlEvent_EVENT_ID_EVENT_ID_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EVENT_ID_descriptor() {
    return XrayControlEvent_EVENT_ID_descriptor();
  }
  static inline const ::std::string& EVENT_ID_Name(EVENT_ID value) {
    return XrayControlEvent_EVENT_ID_Name(value);
  }
  static inline bool EVENT_ID_Parse(const ::std::string& name,
      EVENT_ID* value) {
    return XrayControlEvent_EVENT_ID_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:analogic.ancp00.XrayControlEvent)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_proto_2fXrayControl_2eproto();
  friend void protobuf_AssignDesc_proto_2fXrayControl_2eproto();
  friend void protobuf_ShutdownFile_proto_2fXrayControl_2eproto();

  void InitAsDefaultInstance();
  static XrayControlEvent* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// XrayControlMsg

// optional .analogic.ancp00.XrayControlMsg.XrayControlCmd cmd_id = 1;
inline void XrayControlMsg::clear_cmd_id() {
  cmd_id_ = 0;
}
inline ::analogic::ancp00::XrayControlMsg_XrayControlCmd XrayControlMsg::cmd_id() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.XrayControlMsg.cmd_id)
  return static_cast< ::analogic::ancp00::XrayControlMsg_XrayControlCmd >(cmd_id_);
}
inline void XrayControlMsg::set_cmd_id(::analogic::ancp00::XrayControlMsg_XrayControlCmd value) {
  
  cmd_id_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.XrayControlMsg.cmd_id)
}

// optional .analogic.ancp00.XrayControlMsg.SeasoningMode mode = 2;
inline void XrayControlMsg::clear_mode() {
  mode_ = 0;
}
inline ::analogic::ancp00::XrayControlMsg_SeasoningMode XrayControlMsg::mode() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.XrayControlMsg.mode)
  return static_cast< ::analogic::ancp00::XrayControlMsg_SeasoningMode >(mode_);
}
inline void XrayControlMsg::set_mode(::analogic::ancp00::XrayControlMsg_SeasoningMode value) {
  
  mode_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.XrayControlMsg.mode)
}

// -------------------------------------------------------------------

// XrayControlStatusMsg

// optional .analogic.ancp00.XrayControlStatusMsg.XrayControlState state = 1;
inline void XrayControlStatusMsg::clear_state() {
  state_ = 0;
}
inline ::analogic::ancp00::XrayControlStatusMsg_XrayControlState XrayControlStatusMsg::state() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.XrayControlStatusMsg.state)
  return static_cast< ::analogic::ancp00::XrayControlStatusMsg_XrayControlState >(state_);
}
inline void XrayControlStatusMsg::set_state(::analogic::ancp00::XrayControlStatusMsg_XrayControlState value) {
  
  state_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.XrayControlStatusMsg.state)
}

// optional .analogic.ancp00.XrayControlStatusMsg.XrayControlSubstate substate = 2;
inline void XrayControlStatusMsg::clear_substate() {
  substate_ = 0;
}
inline ::analogic::ancp00::XrayControlStatusMsg_XrayControlSubstate XrayControlStatusMsg::substate() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.XrayControlStatusMsg.substate)
  return static_cast< ::analogic::ancp00::XrayControlStatusMsg_XrayControlSubstate >(substate_);
}
inline void XrayControlStatusMsg::set_substate(::analogic::ancp00::XrayControlStatusMsg_XrayControlSubstate value) {
  
  substate_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.XrayControlStatusMsg.substate)
}

// optional uint64 xray_on_hours = 3;
inline void XrayControlStatusMsg::clear_xray_on_hours() {
  xray_on_hours_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 XrayControlStatusMsg::xray_on_hours() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.XrayControlStatusMsg.xray_on_hours)
  return xray_on_hours_;
}
inline void XrayControlStatusMsg::set_xray_on_hours(::google::protobuf::uint64 value) {
  
  xray_on_hours_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.XrayControlStatusMsg.xray_on_hours)
}

// optional string last_xray_on_time = 4;
inline void XrayControlStatusMsg::clear_last_xray_on_time() {
  last_xray_on_time_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& XrayControlStatusMsg::last_xray_on_time() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.XrayControlStatusMsg.last_xray_on_time)
  return last_xray_on_time_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void XrayControlStatusMsg::set_last_xray_on_time(const ::std::string& value) {
  
  last_xray_on_time_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:analogic.ancp00.XrayControlStatusMsg.last_xray_on_time)
}
inline void XrayControlStatusMsg::set_last_xray_on_time(const char* value) {
  
  last_xray_on_time_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:analogic.ancp00.XrayControlStatusMsg.last_xray_on_time)
}
inline void XrayControlStatusMsg::set_last_xray_on_time(const char* value, size_t size) {
  
  last_xray_on_time_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:analogic.ancp00.XrayControlStatusMsg.last_xray_on_time)
}
inline ::std::string* XrayControlStatusMsg::mutable_last_xray_on_time() {
  
  // @@protoc_insertion_point(field_mutable:analogic.ancp00.XrayControlStatusMsg.last_xray_on_time)
  return last_xray_on_time_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* XrayControlStatusMsg::release_last_xray_on_time() {
  // @@protoc_insertion_point(field_release:analogic.ancp00.XrayControlStatusMsg.last_xray_on_time)
  
  return last_xray_on_time_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void XrayControlStatusMsg::set_allocated_last_xray_on_time(::std::string* last_xray_on_time) {
  if (last_xray_on_time != NULL) {
    
  } else {
    
  }
  last_xray_on_time_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), last_xray_on_time);
  // @@protoc_insertion_point(field_set_allocated:analogic.ancp00.XrayControlStatusMsg.last_xray_on_time)
}

// -------------------------------------------------------------------

// XrayControlEvent

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace ancp00
}  // namespace analogic

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::analogic::ancp00::XrayControlMsg_XrayControlCmd> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::analogic::ancp00::XrayControlMsg_XrayControlCmd>() {
  return ::analogic::ancp00::XrayControlMsg_XrayControlCmd_descriptor();
}
template <> struct is_proto_enum< ::analogic::ancp00::XrayControlMsg_SeasoningMode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::analogic::ancp00::XrayControlMsg_SeasoningMode>() {
  return ::analogic::ancp00::XrayControlMsg_SeasoningMode_descriptor();
}
template <> struct is_proto_enum< ::analogic::ancp00::XrayControlStatusMsg_XrayControlState> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::analogic::ancp00::XrayControlStatusMsg_XrayControlState>() {
  return ::analogic::ancp00::XrayControlStatusMsg_XrayControlState_descriptor();
}
template <> struct is_proto_enum< ::analogic::ancp00::XrayControlStatusMsg_XrayControlSubstate> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::analogic::ancp00::XrayControlStatusMsg_XrayControlSubstate>() {
  return ::analogic::ancp00::XrayControlStatusMsg_XrayControlSubstate_descriptor();
}
template <> struct is_proto_enum< ::analogic::ancp00::XrayControlEvent_EVENT_ID> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::analogic::ancp00::XrayControlEvent_EVENT_ID>() {
  return ::analogic::ancp00::XrayControlEvent_EVENT_ID_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_proto_2fXrayControl_2eproto__INCLUDED
