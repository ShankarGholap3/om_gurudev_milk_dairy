// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/SubsystemIds.proto

#ifndef PROTOBUF_proto_2fSubsystemIds_2eproto__INCLUDED
#define PROTOBUF_proto_2fSubsystemIds_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
// @@protoc_insertion_point(includes)

namespace analogic {
namespace ancp00 {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_proto_2fSubsystemIds_2eproto();
void protobuf_AssignDesc_proto_2fSubsystemIds_2eproto();
void protobuf_ShutdownFile_proto_2fSubsystemIds_2eproto();


enum SUBSYSTEM_ID {
  SCANNER = 0,
  GANTRY = 1,
  CONVEYOR = 2,
  XRAY = 3,
  DETECTION = 4,
  RECON = 5,
  BAGSEP = 6,
  BAGLIFECYCLE = 7,
  CALTEST = 8,
  DYNCAL = 9,
  FRAMEWORK = 10,
  NETINTERFACE = 11,
  BHSINTERFACE = 12,
  COMMMONITOR = 13,
  COMPUTERSTATUS = 14,
  FAULT_LISTENER = 15,
  AIR_OFFSET_CALIBRATION = 16,
  BHS_DIAGNOSTIC = 17,
  BHS_TEST_CMD = 18,
  SAFETYIOCOMM = 50,
  POWERLINKCOMM = 51,
  PDUCOMM = 52,
  GANTRYCOMM = 53,
  CONVEYORCOMM = 54,
  TEMPHUMIDITYCOMM = 55,
  UPLINKCMDSTATUS = 56,
  DRBCOMM = 57,
  RCBCOMM = 100,
  XRAYCOMM = 101,
  DCB1COMM = 102,
  DCB2COMM = 103,
  DCB3COMM = 104,
  DCB4COMM = 105,
  DCB5COMM = 106,
  UPLINKREADBACKSTATUS = 108,
  SERIALSERVER1 = 150,
  SERIALSERVER2 = 151,
  UPSCOMM = 152,
  CAMERACOMM = 153,
  NETWORKCOMM = 154,
  SCARABEE_SL = 200,
  RAPISCAN_TRS = 201,
  MACH_TRS = 202,
  TEST1 = 2500,
  TEST2 = 2501,
  TEST3 = 2502,
  TEST4 = 2503,
  TEST5 = 2504,
  TEST6 = 2505,
  TEST7 = 2506,
  TEST8 = 2507,
  TEST9 = 2508,
  TEST10 = 2509,
  TEST11 = 2510,
  TEST12 = 2511,
  TEST13 = 2512,
  TEST14 = 2513,
  TEST15 = 2514,
  TEST16 = 2515,
  TEST17 = 2516,
  TEST18 = 2517,
  TEST19 = 2518,
  TEST20 = 2519,
  TEST21 = 2520,
  TEST22 = 2521,
  TEST23 = 2522,
  TEST24 = 2523,
  TEST25 = 2524,
  TEST26 = 2525,
  TEST27 = 2526,
  TEST28 = 2527,
  TEST29 = 2528,
  TEST30 = 2529,
  UNKNOWN_ID = 10000,
  SUBSYSTEM_ID_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SUBSYSTEM_ID_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SUBSYSTEM_ID_IsValid(int value);
const SUBSYSTEM_ID SUBSYSTEM_ID_MIN = SCANNER;
const SUBSYSTEM_ID SUBSYSTEM_ID_MAX = UNKNOWN_ID;
const int SUBSYSTEM_ID_ARRAYSIZE = SUBSYSTEM_ID_MAX + 1;

const ::google::protobuf::EnumDescriptor* SUBSYSTEM_ID_descriptor();
inline const ::std::string& SUBSYSTEM_ID_Name(SUBSYSTEM_ID value) {
  return ::google::protobuf::internal::NameOfEnum(
    SUBSYSTEM_ID_descriptor(), value);
}
inline bool SUBSYSTEM_ID_Parse(
    const ::std::string& name, SUBSYSTEM_ID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SUBSYSTEM_ID>(
    SUBSYSTEM_ID_descriptor(), name, value);
}
// ===================================================================


// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace ancp00
}  // namespace analogic

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::analogic::ancp00::SUBSYSTEM_ID> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::analogic::ancp00::SUBSYSTEM_ID>() {
  return ::analogic::ancp00::SUBSYSTEM_ID_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_proto_2fSubsystemIds_2eproto__INCLUDED
