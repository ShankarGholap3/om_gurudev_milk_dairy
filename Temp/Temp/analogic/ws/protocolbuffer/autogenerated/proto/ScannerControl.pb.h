// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/ScannerControl.proto

#ifndef PROTOBUF_proto_2fScannerControl_2eproto__INCLUDED
#define PROTOBUF_proto_2fScannerControl_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace analogic {
namespace ancp00 {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_proto_2fScannerControl_2eproto();
void protobuf_AssignDesc_proto_2fScannerControl_2eproto();
void protobuf_ShutdownFile_proto_2fScannerControl_2eproto();

class CtrlSeqStatus;
class ScannerControlMsg;
class ScannerControlRpcSeq;
class ScannerControlStatusMsg;

enum ScannerControlMsg_SCANNER_CONTROL_CMD {
  ScannerControlMsg_SCANNER_CONTROL_CMD_IDLE_CMD = 0,
  ScannerControlMsg_SCANNER_CONTROL_CMD_SCAN_CMD = 1,
  ScannerControlMsg_SCANNER_CONTROL_CMD_STANDBY_CMD = 2,
  ScannerControlMsg_SCANNER_CONTROL_CMD_PASSTHRU_CMD = 3,
  ScannerControlMsg_SCANNER_CONTROL_CMD_RESET_FAULT_CMD = 4,
  ScannerControlMsg_SCANNER_CONTROL_CMD_SHUTDOWN_CMD = 5,
  ScannerControlMsg_SCANNER_CONTROL_CMD_SERVICE_ACTIVE_CMD = 6,
  ScannerControlMsg_SCANNER_CONTROL_CMD_SERVICE_INACTIVE_CMD = 7,
  ScannerControlMsg_SCANNER_CONTROL_CMD_RAISE_RTR_REQ = 8,
  ScannerControlMsg_SCANNER_CONTROL_CMD_LOWER_RTR_REQ = 9,
  ScannerControlMsg_SCANNER_CONTROL_CMD_RECON_START_CMD = 12,
  ScannerControlMsg_SCANNER_CONTROL_CMD_RECON_STOP_CMD = 13,
  ScannerControlMsg_SCANNER_CONTROL_CMD_CONVEYOR_STOP_CMD = 14,
  ScannerControlMsg_SCANNER_CONTROL_CMD_CONVEYOR_RUN_CMD = 15,
  ScannerControlMsg_SCANNER_CONTROL_CMD_ENTRANCE_CONVEYOR_STOP_CMD = 16,
  ScannerControlMsg_SCANNER_CONTROL_CMD_ENTRANCE_CONVEYOR_RUN_CMD = 17,
  ScannerControlMsg_SCANNER_CONTROL_CMD_EXIT_CONVEYOR_STOP_CMD = 18,
  ScannerControlMsg_SCANNER_CONTROL_CMD_EXIT_CONVEYOR_RUN_CMD = 19,
  ScannerControlMsg_SCANNER_CONTROL_CMD_BHS_EMERGENCY_REQUEST = 20,
  ScannerControlMsg_SCANNER_CONTROL_CMD_BHS_EMERGENCY_RELEASE = 21,
  ScannerControlMsg_SCANNER_CONTROL_CMD_GANTRY_STOP_CMD = 22,
  ScannerControlMsg_SCANNER_CONTROL_CMD_GANTRY_RUN_CMD = 23,
  ScannerControlMsg_SCANNER_CONTROL_CMD_CONVEYOR_RUN_REVERSE_CMD = 24,
  ScannerControlMsg_SCANNER_CONTROL_CMD_ScannerControlMsg_SCANNER_CONTROL_CMD_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ScannerControlMsg_SCANNER_CONTROL_CMD_ScannerControlMsg_SCANNER_CONTROL_CMD_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ScannerControlMsg_SCANNER_CONTROL_CMD_IsValid(int value);
const ScannerControlMsg_SCANNER_CONTROL_CMD ScannerControlMsg_SCANNER_CONTROL_CMD_SCANNER_CONTROL_CMD_MIN = ScannerControlMsg_SCANNER_CONTROL_CMD_IDLE_CMD;
const ScannerControlMsg_SCANNER_CONTROL_CMD ScannerControlMsg_SCANNER_CONTROL_CMD_SCANNER_CONTROL_CMD_MAX = ScannerControlMsg_SCANNER_CONTROL_CMD_CONVEYOR_RUN_REVERSE_CMD;
const int ScannerControlMsg_SCANNER_CONTROL_CMD_SCANNER_CONTROL_CMD_ARRAYSIZE = ScannerControlMsg_SCANNER_CONTROL_CMD_SCANNER_CONTROL_CMD_MAX + 1;

const ::google::protobuf::EnumDescriptor* ScannerControlMsg_SCANNER_CONTROL_CMD_descriptor();
inline const ::std::string& ScannerControlMsg_SCANNER_CONTROL_CMD_Name(ScannerControlMsg_SCANNER_CONTROL_CMD value) {
  return ::google::protobuf::internal::NameOfEnum(
    ScannerControlMsg_SCANNER_CONTROL_CMD_descriptor(), value);
}
inline bool ScannerControlMsg_SCANNER_CONTROL_CMD_Parse(
    const ::std::string& name, ScannerControlMsg_SCANNER_CONTROL_CMD* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ScannerControlMsg_SCANNER_CONTROL_CMD>(
    ScannerControlMsg_SCANNER_CONTROL_CMD_descriptor(), name, value);
}
enum ScannerControlStatusMsg_SCANNER_CONTROL_STATE {
  ScannerControlStatusMsg_SCANNER_CONTROL_STATE_UNINIT = 0,
  ScannerControlStatusMsg_SCANNER_CONTROL_STATE_IDLE = 1,
  ScannerControlStatusMsg_SCANNER_CONTROL_STATE_PASSTHRU = 2,
  ScannerControlStatusMsg_SCANNER_CONTROL_STATE_STANDBY = 3,
  ScannerControlStatusMsg_SCANNER_CONTROL_STATE_SCAN = 4,
  ScannerControlStatusMsg_SCANNER_CONTROL_STATE_FAULT = 5,
  ScannerControlStatusMsg_SCANNER_CONTROL_STATE_CAL_SERVICE = 6,
  ScannerControlStatusMsg_SCANNER_CONTROL_STATE_SHUTDOWN = 7,
  ScannerControlStatusMsg_SCANNER_CONTROL_STATE_ScannerControlStatusMsg_SCANNER_CONTROL_STATE_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ScannerControlStatusMsg_SCANNER_CONTROL_STATE_ScannerControlStatusMsg_SCANNER_CONTROL_STATE_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ScannerControlStatusMsg_SCANNER_CONTROL_STATE_IsValid(int value);
const ScannerControlStatusMsg_SCANNER_CONTROL_STATE ScannerControlStatusMsg_SCANNER_CONTROL_STATE_SCANNER_CONTROL_STATE_MIN = ScannerControlStatusMsg_SCANNER_CONTROL_STATE_UNINIT;
const ScannerControlStatusMsg_SCANNER_CONTROL_STATE ScannerControlStatusMsg_SCANNER_CONTROL_STATE_SCANNER_CONTROL_STATE_MAX = ScannerControlStatusMsg_SCANNER_CONTROL_STATE_SHUTDOWN;
const int ScannerControlStatusMsg_SCANNER_CONTROL_STATE_SCANNER_CONTROL_STATE_ARRAYSIZE = ScannerControlStatusMsg_SCANNER_CONTROL_STATE_SCANNER_CONTROL_STATE_MAX + 1;

const ::google::protobuf::EnumDescriptor* ScannerControlStatusMsg_SCANNER_CONTROL_STATE_descriptor();
inline const ::std::string& ScannerControlStatusMsg_SCANNER_CONTROL_STATE_Name(ScannerControlStatusMsg_SCANNER_CONTROL_STATE value) {
  return ::google::protobuf::internal::NameOfEnum(
    ScannerControlStatusMsg_SCANNER_CONTROL_STATE_descriptor(), value);
}
inline bool ScannerControlStatusMsg_SCANNER_CONTROL_STATE_Parse(
    const ::std::string& name, ScannerControlStatusMsg_SCANNER_CONTROL_STATE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ScannerControlStatusMsg_SCANNER_CONTROL_STATE>(
    ScannerControlStatusMsg_SCANNER_CONTROL_STATE_descriptor(), name, value);
}
enum ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE {
  ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_NOT_USED_SS = 0,
  ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_IDLE_SS = 2,
  ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_GOING_TO_PASSTHRU_SS = 3,
  ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_PASSTHRU_SS = 4,
  ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_GOING_TO_STANDYBY_SS = 5,
  ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_STANDBY_SS = 6,
  ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_STANDBY_XRAY_SEASONING_SS = 7,
  ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_SCANNING_SS = 10,
  ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_SCANNING_NOT_RTR_SS = 11,
  ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_GOING_TO_SCAN_SS = 20,
  ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_GANTRY_SPINUP_SS = 21,
  ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_XRAY_SEASONING_SS = 22,
  ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_XRAY_ENERGIZING_SS = 23,
  ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_CALIBRATING_SS = 24,
  ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_CONVEYOR_STARTUP_SS = 25,
  ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_POWERLINK_COMM_CHECK_SS = 26,
  ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_CONVEYOR_RUNOUT_SS = 27,
  ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_XRAY_MINIMIZED_SS = 28,
  ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_SHUTDOWN_IN_PROGRESS_SS = 30,
  ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_AIR_CAL_SS = 50,
  ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_OFFSET_CAL_SS = 51,
  ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_PIN_CAL_SS = 52,
  ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_ZEE_ALIGN_SS = 53,
  ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_SPECTRAL_CAL_SS = 54,
  ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_RAD_SURVEY_SS = 55,
  ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_IMAGE_QUALITY_SS = 56,
  ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_RAW_DATA_COLLECT_SS = 58,
  ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_RAD_SURVEY_CANCEL_SS = 59,
  ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_BELT_TUNNEL_CAL_SS = 65,
  ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_INTRUSION_DETECTED_SS = 70,
  ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_IsValid(int value);
const ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_SCANNER_CONTROL_SUBSTATE_MIN = ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_NOT_USED_SS;
const ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_SCANNER_CONTROL_SUBSTATE_MAX = ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_INTRUSION_DETECTED_SS;
const int ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_SCANNER_CONTROL_SUBSTATE_ARRAYSIZE = ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_SCANNER_CONTROL_SUBSTATE_MAX + 1;

const ::google::protobuf::EnumDescriptor* ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_descriptor();
inline const ::std::string& ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_Name(ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE value) {
  return ::google::protobuf::internal::NameOfEnum(
    ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_descriptor(), value);
}
inline bool ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_Parse(
    const ::std::string& name, ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE>(
    ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_descriptor(), name, value);
}
enum ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID {
  ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_GET_COMPUTER_INFO = 0,
  ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_GET_BAD_DETECTOR_MAP_FILES = 1,
  ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_GET_BAD_DETECTOR_MANUAL_FILE = 2,
  ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_UPDATE_BAD_DETECTOR_MANUAL_FILE = 3,
  ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_GET_ERROR_LOG_FILE = 4,
  ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_GET_IMAGE_CALIBRATION_FILES = 5,
  ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_VIEW_IMAGE_QUALITY_REPORT = 8,
  ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_RUN_IMAGE_CALIBRATION = 9,
  ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_UPDATE_IMAGE_CALIBRATION_BELT_HEIGHT = 10,
  ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_UPDATE_IMAGE_CALIBRATION_NYLON_SCALE = 11,
  ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_EXPORT_FILES = 12,
  ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_GET_SCANNER_CONFIG_FILE = 13,
  ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_UPDATE_SCANNER_CONFIG_FILE = 14,
  ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_GET_WS_SCANNER_CONFIG_FILE = 15,
  ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_UPDATE_WS_SCANNER_CONFIG_FILE = 16,
  ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_GET_IMAGE_QUALITY_MASS_VALUES = 17,
  ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_GET_INSTALLED_ALARM_LIBS = 18,
  ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_GET_INSTALLABLE_ALARM_LIBS = 19,
  ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_INSTALL_ALARM_LIB = 20,
  ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_UPDATE_IMAGE_CALIBRATION_BELT_FREQ = 21,
  ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_EXPORT_CAL_PARAM_DATA = 22,
  ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_IMPORT_CAL_PARAM_DATA = 23,
  ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_AIR_CAL = 1000,
  ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_OFFSET_CAL = 1001,
  ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_PIN_CAL = 1002,
  ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_ZEE_ALIGN = 1003,
  ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_SPECTRAL_CAL = 1004,
  ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_RADIATION_SURVEY = 1005,
  ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_RADIATION_SURVEY_CANCEL = 1006,
  ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_RAW_DATA_COLLECT = 1007,
  ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_IMAGE_QUALITY_TEST_RUN = 1008,
  ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_IMAGE_QUALITY_TEST_CANCEL = 1009,
  ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_CAL_PROCEED = 1010,
  ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_CAL_CANCEL = 1011,
  ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_ZEE_PIN_SPECTRAL_CAL_SEQ = 1012,
  ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_BELT_TUNNEL_CAL_NO_WINDOW = 1013,
  ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_BELT_TUNNEL_CAL_WITH_WINDOW = 1014,
  ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_GANTRY_CONTROL_SEQ = 5000,
  ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_CONVEYOR_CONTROL_SEQ = 5001,
  ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_XRAY_CONTROL_SEQ = 5002,
  ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_XRAY_SEASON_SEQ = 5003,
  ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_GO_TO_IDLE_SEQ = 5004,
  ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_GO_TO_SCAN_SEQ = 5005,
  ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_GO_TO_PASSTHRU_SEQ = 5006,
  ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_GO_TO_STANDBY_SEQ = 5007,
  ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_RESET_FAULT_SEQ = 5008,
  ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_SHUTDOWN_SEQ = 5009,
  ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_DYNAMIC_AIR_CAL_SEQ = 5010,
  ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_DYNAMIC_OFFSET_CAL_SEQ = 5011,
  ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_CONV_STOP_XRAY_MIN_SEQ = 5012,
  ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_XRAY_MAX_CONV_RUN_SEQ = 5013,
  ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_CONV_STOP_XRAY_MIN_CONV_RUN_SEQ = 5014,
  ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_CONVEYOR_FLUSH_SEQ = 5015,
  ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_GANTRY_RUN_SEQ = 5050,
  ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_GANTRY_STOP_SEQ = 5051,
  ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_CONVEYOR_RUN_SEQ = 5052,
  ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_CONVEYOR_STOP_SEQ = 5053,
  ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_XRAY_ON_SEQ = 5100,
  ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_XRAY_OFF_SEQ = 5101,
  ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_XRAY_MINIMIZE_SEQ = 5102,
  ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_XRAY_MAXIMIZE_SEQ = 5103,
  ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_XRAY_SEASONING_SHORT_SEQ = 5104,
  ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_XRAY_SEASONING_MEDIUM_SEQ = 5105,
  ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_XRAY_SEASONING_LONG_SEQ = 5106,
  ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_IsValid(int value);
const ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_SCANNER_CONTROL_RPC_SEQ_ID_MIN = ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_GET_COMPUTER_INFO;
const ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_SCANNER_CONTROL_RPC_SEQ_ID_MAX = ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_XRAY_SEASONING_LONG_SEQ;
const int ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_SCANNER_CONTROL_RPC_SEQ_ID_ARRAYSIZE = ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_SCANNER_CONTROL_RPC_SEQ_ID_MAX + 1;

const ::google::protobuf::EnumDescriptor* ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_descriptor();
inline const ::std::string& ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_Name(ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID value) {
  return ::google::protobuf::internal::NameOfEnum(
    ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_descriptor(), value);
}
inline bool ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_Parse(
    const ::std::string& name, ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID>(
    ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_descriptor(), name, value);
}
enum CtrlSeqStatus_CTRL_SEQ_STATUS {
  CtrlSeqStatus_CTRL_SEQ_STATUS_CTRL_SEQ_IDLE = 0,
  CtrlSeqStatus_CTRL_SEQ_STATUS_CTRL_SEQ_RUNNING = 1,
  CtrlSeqStatus_CTRL_SEQ_STATUS_CTRL_SEQ_PAUSED = 2,
  CtrlSeqStatus_CTRL_SEQ_STATUS_CTRL_SEQ_RESUMED = 3,
  CtrlSeqStatus_CTRL_SEQ_STATUS_CTRL_SEQ_COMPLETE = 4,
  CtrlSeqStatus_CTRL_SEQ_STATUS_CTRL_SEQ_ERROR = 5,
  CtrlSeqStatus_CTRL_SEQ_STATUS_CTRL_SEQ_ABORTED = 6,
  CtrlSeqStatus_CTRL_SEQ_STATUS_CtrlSeqStatus_CTRL_SEQ_STATUS_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  CtrlSeqStatus_CTRL_SEQ_STATUS_CtrlSeqStatus_CTRL_SEQ_STATUS_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool CtrlSeqStatus_CTRL_SEQ_STATUS_IsValid(int value);
const CtrlSeqStatus_CTRL_SEQ_STATUS CtrlSeqStatus_CTRL_SEQ_STATUS_CTRL_SEQ_STATUS_MIN = CtrlSeqStatus_CTRL_SEQ_STATUS_CTRL_SEQ_IDLE;
const CtrlSeqStatus_CTRL_SEQ_STATUS CtrlSeqStatus_CTRL_SEQ_STATUS_CTRL_SEQ_STATUS_MAX = CtrlSeqStatus_CTRL_SEQ_STATUS_CTRL_SEQ_ABORTED;
const int CtrlSeqStatus_CTRL_SEQ_STATUS_CTRL_SEQ_STATUS_ARRAYSIZE = CtrlSeqStatus_CTRL_SEQ_STATUS_CTRL_SEQ_STATUS_MAX + 1;

const ::google::protobuf::EnumDescriptor* CtrlSeqStatus_CTRL_SEQ_STATUS_descriptor();
inline const ::std::string& CtrlSeqStatus_CTRL_SEQ_STATUS_Name(CtrlSeqStatus_CTRL_SEQ_STATUS value) {
  return ::google::protobuf::internal::NameOfEnum(
    CtrlSeqStatus_CTRL_SEQ_STATUS_descriptor(), value);
}
inline bool CtrlSeqStatus_CTRL_SEQ_STATUS_Parse(
    const ::std::string& name, CtrlSeqStatus_CTRL_SEQ_STATUS* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CtrlSeqStatus_CTRL_SEQ_STATUS>(
    CtrlSeqStatus_CTRL_SEQ_STATUS_descriptor(), name, value);
}
enum CtrlSeqStatus_CTRL_SEQ_ERROR_CODE {
  CtrlSeqStatus_CTRL_SEQ_ERROR_CODE_CTRL_SEQ_ERROR_NONE = 0,
  CtrlSeqStatus_CTRL_SEQ_ERROR_CODE_CTRL_SEQ_ERROR_TIMEOUT = 1,
  CtrlSeqStatus_CTRL_SEQ_ERROR_CODE_CTRL_SEQ_SEQ_ERROR = 2,
  CtrlSeqStatus_CTRL_SEQ_ERROR_CODE_CtrlSeqStatus_CTRL_SEQ_ERROR_CODE_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  CtrlSeqStatus_CTRL_SEQ_ERROR_CODE_CtrlSeqStatus_CTRL_SEQ_ERROR_CODE_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool CtrlSeqStatus_CTRL_SEQ_ERROR_CODE_IsValid(int value);
const CtrlSeqStatus_CTRL_SEQ_ERROR_CODE CtrlSeqStatus_CTRL_SEQ_ERROR_CODE_CTRL_SEQ_ERROR_CODE_MIN = CtrlSeqStatus_CTRL_SEQ_ERROR_CODE_CTRL_SEQ_ERROR_NONE;
const CtrlSeqStatus_CTRL_SEQ_ERROR_CODE CtrlSeqStatus_CTRL_SEQ_ERROR_CODE_CTRL_SEQ_ERROR_CODE_MAX = CtrlSeqStatus_CTRL_SEQ_ERROR_CODE_CTRL_SEQ_SEQ_ERROR;
const int CtrlSeqStatus_CTRL_SEQ_ERROR_CODE_CTRL_SEQ_ERROR_CODE_ARRAYSIZE = CtrlSeqStatus_CTRL_SEQ_ERROR_CODE_CTRL_SEQ_ERROR_CODE_MAX + 1;

const ::google::protobuf::EnumDescriptor* CtrlSeqStatus_CTRL_SEQ_ERROR_CODE_descriptor();
inline const ::std::string& CtrlSeqStatus_CTRL_SEQ_ERROR_CODE_Name(CtrlSeqStatus_CTRL_SEQ_ERROR_CODE value) {
  return ::google::protobuf::internal::NameOfEnum(
    CtrlSeqStatus_CTRL_SEQ_ERROR_CODE_descriptor(), value);
}
inline bool CtrlSeqStatus_CTRL_SEQ_ERROR_CODE_Parse(
    const ::std::string& name, CtrlSeqStatus_CTRL_SEQ_ERROR_CODE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CtrlSeqStatus_CTRL_SEQ_ERROR_CODE>(
    CtrlSeqStatus_CTRL_SEQ_ERROR_CODE_descriptor(), name, value);
}
enum DYNAMIC_AIR_CAL_STATE {
  DYN_AIR_CAL_CLEAR_ERROR = 0,
  DYN_AIR_CAL_CONVEYOR_CONTROL = 1,
  DYN_AIR_CAL_CALIBRATE = 2,
  DYN_AIR_CAL_CONVEYOR_RUN = 3,
  DYNAMIC_AIR_CAL_STATE_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DYNAMIC_AIR_CAL_STATE_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DYNAMIC_AIR_CAL_STATE_IsValid(int value);
const DYNAMIC_AIR_CAL_STATE DYNAMIC_AIR_CAL_STATE_MIN = DYN_AIR_CAL_CLEAR_ERROR;
const DYNAMIC_AIR_CAL_STATE DYNAMIC_AIR_CAL_STATE_MAX = DYN_AIR_CAL_CONVEYOR_RUN;
const int DYNAMIC_AIR_CAL_STATE_ARRAYSIZE = DYNAMIC_AIR_CAL_STATE_MAX + 1;

const ::google::protobuf::EnumDescriptor* DYNAMIC_AIR_CAL_STATE_descriptor();
inline const ::std::string& DYNAMIC_AIR_CAL_STATE_Name(DYNAMIC_AIR_CAL_STATE value) {
  return ::google::protobuf::internal::NameOfEnum(
    DYNAMIC_AIR_CAL_STATE_descriptor(), value);
}
inline bool DYNAMIC_AIR_CAL_STATE_Parse(
    const ::std::string& name, DYNAMIC_AIR_CAL_STATE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DYNAMIC_AIR_CAL_STATE>(
    DYNAMIC_AIR_CAL_STATE_descriptor(), name, value);
}
enum DYNAMIC_OFFSET_CAL_STATE {
  DYN_OFFSET_CAL_CLEAR_ERROR = 0,
  DYN_OFFSET_CAL_CONVEYOR_STOP = 1,
  DYN_OFFSET_CAL_XRAY_OFF = 2,
  DYN_OFFSET_CAL_CALIBRATE = 3,
  DYN_OFFSET_CAL_XRAY_ON = 4,
  DYN_OFFSET_CAL_CONVEYOR_RUN = 5,
  DYNAMIC_OFFSET_CAL_STATE_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DYNAMIC_OFFSET_CAL_STATE_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DYNAMIC_OFFSET_CAL_STATE_IsValid(int value);
const DYNAMIC_OFFSET_CAL_STATE DYNAMIC_OFFSET_CAL_STATE_MIN = DYN_OFFSET_CAL_CLEAR_ERROR;
const DYNAMIC_OFFSET_CAL_STATE DYNAMIC_OFFSET_CAL_STATE_MAX = DYN_OFFSET_CAL_CONVEYOR_RUN;
const int DYNAMIC_OFFSET_CAL_STATE_ARRAYSIZE = DYNAMIC_OFFSET_CAL_STATE_MAX + 1;

const ::google::protobuf::EnumDescriptor* DYNAMIC_OFFSET_CAL_STATE_descriptor();
inline const ::std::string& DYNAMIC_OFFSET_CAL_STATE_Name(DYNAMIC_OFFSET_CAL_STATE value) {
  return ::google::protobuf::internal::NameOfEnum(
    DYNAMIC_OFFSET_CAL_STATE_descriptor(), value);
}
inline bool DYNAMIC_OFFSET_CAL_STATE_Parse(
    const ::std::string& name, DYNAMIC_OFFSET_CAL_STATE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DYNAMIC_OFFSET_CAL_STATE>(
    DYNAMIC_OFFSET_CAL_STATE_descriptor(), name, value);
}
enum BHS_TYPE {
  BHS_NONE = 0,
  BHS_SCARABEE_SL = 1,
  BHS_TYPE_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  BHS_TYPE_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool BHS_TYPE_IsValid(int value);
const BHS_TYPE BHS_TYPE_MIN = BHS_NONE;
const BHS_TYPE BHS_TYPE_MAX = BHS_SCARABEE_SL;
const int BHS_TYPE_ARRAYSIZE = BHS_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* BHS_TYPE_descriptor();
inline const ::std::string& BHS_TYPE_Name(BHS_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    BHS_TYPE_descriptor(), value);
}
inline bool BHS_TYPE_Parse(
    const ::std::string& name, BHS_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BHS_TYPE>(
    BHS_TYPE_descriptor(), name, value);
}
// ===================================================================

class ScannerControlMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:analogic.ancp00.ScannerControlMsg) */ {
 public:
  ScannerControlMsg();
  virtual ~ScannerControlMsg();

  ScannerControlMsg(const ScannerControlMsg& from);

  inline ScannerControlMsg& operator=(const ScannerControlMsg& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ScannerControlMsg& default_instance();

  void Swap(ScannerControlMsg* other);

  // implements Message ----------------------------------------------

  inline ScannerControlMsg* New() const { return New(NULL); }

  ScannerControlMsg* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ScannerControlMsg& from);
  void MergeFrom(const ScannerControlMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ScannerControlMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ScannerControlMsg_SCANNER_CONTROL_CMD SCANNER_CONTROL_CMD;
  static const SCANNER_CONTROL_CMD IDLE_CMD =
    ScannerControlMsg_SCANNER_CONTROL_CMD_IDLE_CMD;
  static const SCANNER_CONTROL_CMD SCAN_CMD =
    ScannerControlMsg_SCANNER_CONTROL_CMD_SCAN_CMD;
  static const SCANNER_CONTROL_CMD STANDBY_CMD =
    ScannerControlMsg_SCANNER_CONTROL_CMD_STANDBY_CMD;
  static const SCANNER_CONTROL_CMD PASSTHRU_CMD =
    ScannerControlMsg_SCANNER_CONTROL_CMD_PASSTHRU_CMD;
  static const SCANNER_CONTROL_CMD RESET_FAULT_CMD =
    ScannerControlMsg_SCANNER_CONTROL_CMD_RESET_FAULT_CMD;
  static const SCANNER_CONTROL_CMD SHUTDOWN_CMD =
    ScannerControlMsg_SCANNER_CONTROL_CMD_SHUTDOWN_CMD;
  static const SCANNER_CONTROL_CMD SERVICE_ACTIVE_CMD =
    ScannerControlMsg_SCANNER_CONTROL_CMD_SERVICE_ACTIVE_CMD;
  static const SCANNER_CONTROL_CMD SERVICE_INACTIVE_CMD =
    ScannerControlMsg_SCANNER_CONTROL_CMD_SERVICE_INACTIVE_CMD;
  static const SCANNER_CONTROL_CMD RAISE_RTR_REQ =
    ScannerControlMsg_SCANNER_CONTROL_CMD_RAISE_RTR_REQ;
  static const SCANNER_CONTROL_CMD LOWER_RTR_REQ =
    ScannerControlMsg_SCANNER_CONTROL_CMD_LOWER_RTR_REQ;
  static const SCANNER_CONTROL_CMD RECON_START_CMD =
    ScannerControlMsg_SCANNER_CONTROL_CMD_RECON_START_CMD;
  static const SCANNER_CONTROL_CMD RECON_STOP_CMD =
    ScannerControlMsg_SCANNER_CONTROL_CMD_RECON_STOP_CMD;
  static const SCANNER_CONTROL_CMD CONVEYOR_STOP_CMD =
    ScannerControlMsg_SCANNER_CONTROL_CMD_CONVEYOR_STOP_CMD;
  static const SCANNER_CONTROL_CMD CONVEYOR_RUN_CMD =
    ScannerControlMsg_SCANNER_CONTROL_CMD_CONVEYOR_RUN_CMD;
  static const SCANNER_CONTROL_CMD ENTRANCE_CONVEYOR_STOP_CMD =
    ScannerControlMsg_SCANNER_CONTROL_CMD_ENTRANCE_CONVEYOR_STOP_CMD;
  static const SCANNER_CONTROL_CMD ENTRANCE_CONVEYOR_RUN_CMD =
    ScannerControlMsg_SCANNER_CONTROL_CMD_ENTRANCE_CONVEYOR_RUN_CMD;
  static const SCANNER_CONTROL_CMD EXIT_CONVEYOR_STOP_CMD =
    ScannerControlMsg_SCANNER_CONTROL_CMD_EXIT_CONVEYOR_STOP_CMD;
  static const SCANNER_CONTROL_CMD EXIT_CONVEYOR_RUN_CMD =
    ScannerControlMsg_SCANNER_CONTROL_CMD_EXIT_CONVEYOR_RUN_CMD;
  static const SCANNER_CONTROL_CMD BHS_EMERGENCY_REQUEST =
    ScannerControlMsg_SCANNER_CONTROL_CMD_BHS_EMERGENCY_REQUEST;
  static const SCANNER_CONTROL_CMD BHS_EMERGENCY_RELEASE =
    ScannerControlMsg_SCANNER_CONTROL_CMD_BHS_EMERGENCY_RELEASE;
  static const SCANNER_CONTROL_CMD GANTRY_STOP_CMD =
    ScannerControlMsg_SCANNER_CONTROL_CMD_GANTRY_STOP_CMD;
  static const SCANNER_CONTROL_CMD GANTRY_RUN_CMD =
    ScannerControlMsg_SCANNER_CONTROL_CMD_GANTRY_RUN_CMD;
  static const SCANNER_CONTROL_CMD CONVEYOR_RUN_REVERSE_CMD =
    ScannerControlMsg_SCANNER_CONTROL_CMD_CONVEYOR_RUN_REVERSE_CMD;
  static inline bool SCANNER_CONTROL_CMD_IsValid(int value) {
    return ScannerControlMsg_SCANNER_CONTROL_CMD_IsValid(value);
  }
  static const SCANNER_CONTROL_CMD SCANNER_CONTROL_CMD_MIN =
    ScannerControlMsg_SCANNER_CONTROL_CMD_SCANNER_CONTROL_CMD_MIN;
  static const SCANNER_CONTROL_CMD SCANNER_CONTROL_CMD_MAX =
    ScannerControlMsg_SCANNER_CONTROL_CMD_SCANNER_CONTROL_CMD_MAX;
  static const int SCANNER_CONTROL_CMD_ARRAYSIZE =
    ScannerControlMsg_SCANNER_CONTROL_CMD_SCANNER_CONTROL_CMD_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SCANNER_CONTROL_CMD_descriptor() {
    return ScannerControlMsg_SCANNER_CONTROL_CMD_descriptor();
  }
  static inline const ::std::string& SCANNER_CONTROL_CMD_Name(SCANNER_CONTROL_CMD value) {
    return ScannerControlMsg_SCANNER_CONTROL_CMD_Name(value);
  }
  static inline bool SCANNER_CONTROL_CMD_Parse(const ::std::string& name,
      SCANNER_CONTROL_CMD* value) {
    return ScannerControlMsg_SCANNER_CONTROL_CMD_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .analogic.ancp00.ScannerControlMsg.SCANNER_CONTROL_CMD cmd_id = 1;
  void clear_cmd_id();
  static const int kCmdIdFieldNumber = 1;
  ::analogic::ancp00::ScannerControlMsg_SCANNER_CONTROL_CMD cmd_id() const;
  void set_cmd_id(::analogic::ancp00::ScannerControlMsg_SCANNER_CONTROL_CMD value);

  // optional string text = 2;
  void clear_text();
  static const int kTextFieldNumber = 2;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // @@protoc_insertion_point(class_scope:analogic.ancp00.ScannerControlMsg)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  int cmd_id_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_proto_2fScannerControl_2eproto();
  friend void protobuf_AssignDesc_proto_2fScannerControl_2eproto();
  friend void protobuf_ShutdownFile_proto_2fScannerControl_2eproto();

  void InitAsDefaultInstance();
  static ScannerControlMsg* default_instance_;
};
// -------------------------------------------------------------------

class ScannerControlStatusMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:analogic.ancp00.ScannerControlStatusMsg) */ {
 public:
  ScannerControlStatusMsg();
  virtual ~ScannerControlStatusMsg();

  ScannerControlStatusMsg(const ScannerControlStatusMsg& from);

  inline ScannerControlStatusMsg& operator=(const ScannerControlStatusMsg& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ScannerControlStatusMsg& default_instance();

  void Swap(ScannerControlStatusMsg* other);

  // implements Message ----------------------------------------------

  inline ScannerControlStatusMsg* New() const { return New(NULL); }

  ScannerControlStatusMsg* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ScannerControlStatusMsg& from);
  void MergeFrom(const ScannerControlStatusMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ScannerControlStatusMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ScannerControlStatusMsg_SCANNER_CONTROL_STATE SCANNER_CONTROL_STATE;
  static const SCANNER_CONTROL_STATE UNINIT =
    ScannerControlStatusMsg_SCANNER_CONTROL_STATE_UNINIT;
  static const SCANNER_CONTROL_STATE IDLE =
    ScannerControlStatusMsg_SCANNER_CONTROL_STATE_IDLE;
  static const SCANNER_CONTROL_STATE PASSTHRU =
    ScannerControlStatusMsg_SCANNER_CONTROL_STATE_PASSTHRU;
  static const SCANNER_CONTROL_STATE STANDBY =
    ScannerControlStatusMsg_SCANNER_CONTROL_STATE_STANDBY;
  static const SCANNER_CONTROL_STATE SCAN =
    ScannerControlStatusMsg_SCANNER_CONTROL_STATE_SCAN;
  static const SCANNER_CONTROL_STATE FAULT =
    ScannerControlStatusMsg_SCANNER_CONTROL_STATE_FAULT;
  static const SCANNER_CONTROL_STATE CAL_SERVICE =
    ScannerControlStatusMsg_SCANNER_CONTROL_STATE_CAL_SERVICE;
  static const SCANNER_CONTROL_STATE SHUTDOWN =
    ScannerControlStatusMsg_SCANNER_CONTROL_STATE_SHUTDOWN;
  static inline bool SCANNER_CONTROL_STATE_IsValid(int value) {
    return ScannerControlStatusMsg_SCANNER_CONTROL_STATE_IsValid(value);
  }
  static const SCANNER_CONTROL_STATE SCANNER_CONTROL_STATE_MIN =
    ScannerControlStatusMsg_SCANNER_CONTROL_STATE_SCANNER_CONTROL_STATE_MIN;
  static const SCANNER_CONTROL_STATE SCANNER_CONTROL_STATE_MAX =
    ScannerControlStatusMsg_SCANNER_CONTROL_STATE_SCANNER_CONTROL_STATE_MAX;
  static const int SCANNER_CONTROL_STATE_ARRAYSIZE =
    ScannerControlStatusMsg_SCANNER_CONTROL_STATE_SCANNER_CONTROL_STATE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SCANNER_CONTROL_STATE_descriptor() {
    return ScannerControlStatusMsg_SCANNER_CONTROL_STATE_descriptor();
  }
  static inline const ::std::string& SCANNER_CONTROL_STATE_Name(SCANNER_CONTROL_STATE value) {
    return ScannerControlStatusMsg_SCANNER_CONTROL_STATE_Name(value);
  }
  static inline bool SCANNER_CONTROL_STATE_Parse(const ::std::string& name,
      SCANNER_CONTROL_STATE* value) {
    return ScannerControlStatusMsg_SCANNER_CONTROL_STATE_Parse(name, value);
  }

  typedef ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE SCANNER_CONTROL_SUBSTATE;
  static const SCANNER_CONTROL_SUBSTATE NOT_USED_SS =
    ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_NOT_USED_SS;
  static const SCANNER_CONTROL_SUBSTATE IDLE_SS =
    ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_IDLE_SS;
  static const SCANNER_CONTROL_SUBSTATE GOING_TO_PASSTHRU_SS =
    ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_GOING_TO_PASSTHRU_SS;
  static const SCANNER_CONTROL_SUBSTATE PASSTHRU_SS =
    ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_PASSTHRU_SS;
  static const SCANNER_CONTROL_SUBSTATE GOING_TO_STANDYBY_SS =
    ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_GOING_TO_STANDYBY_SS;
  static const SCANNER_CONTROL_SUBSTATE STANDBY_SS =
    ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_STANDBY_SS;
  static const SCANNER_CONTROL_SUBSTATE STANDBY_XRAY_SEASONING_SS =
    ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_STANDBY_XRAY_SEASONING_SS;
  static const SCANNER_CONTROL_SUBSTATE SCANNING_SS =
    ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_SCANNING_SS;
  static const SCANNER_CONTROL_SUBSTATE SCANNING_NOT_RTR_SS =
    ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_SCANNING_NOT_RTR_SS;
  static const SCANNER_CONTROL_SUBSTATE GOING_TO_SCAN_SS =
    ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_GOING_TO_SCAN_SS;
  static const SCANNER_CONTROL_SUBSTATE GANTRY_SPINUP_SS =
    ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_GANTRY_SPINUP_SS;
  static const SCANNER_CONTROL_SUBSTATE XRAY_SEASONING_SS =
    ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_XRAY_SEASONING_SS;
  static const SCANNER_CONTROL_SUBSTATE XRAY_ENERGIZING_SS =
    ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_XRAY_ENERGIZING_SS;
  static const SCANNER_CONTROL_SUBSTATE CALIBRATING_SS =
    ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_CALIBRATING_SS;
  static const SCANNER_CONTROL_SUBSTATE CONVEYOR_STARTUP_SS =
    ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_CONVEYOR_STARTUP_SS;
  static const SCANNER_CONTROL_SUBSTATE POWERLINK_COMM_CHECK_SS =
    ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_POWERLINK_COMM_CHECK_SS;
  static const SCANNER_CONTROL_SUBSTATE CONVEYOR_RUNOUT_SS =
    ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_CONVEYOR_RUNOUT_SS;
  static const SCANNER_CONTROL_SUBSTATE XRAY_MINIMIZED_SS =
    ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_XRAY_MINIMIZED_SS;
  static const SCANNER_CONTROL_SUBSTATE SHUTDOWN_IN_PROGRESS_SS =
    ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_SHUTDOWN_IN_PROGRESS_SS;
  static const SCANNER_CONTROL_SUBSTATE AIR_CAL_SS =
    ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_AIR_CAL_SS;
  static const SCANNER_CONTROL_SUBSTATE OFFSET_CAL_SS =
    ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_OFFSET_CAL_SS;
  static const SCANNER_CONTROL_SUBSTATE PIN_CAL_SS =
    ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_PIN_CAL_SS;
  static const SCANNER_CONTROL_SUBSTATE ZEE_ALIGN_SS =
    ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_ZEE_ALIGN_SS;
  static const SCANNER_CONTROL_SUBSTATE SPECTRAL_CAL_SS =
    ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_SPECTRAL_CAL_SS;
  static const SCANNER_CONTROL_SUBSTATE RAD_SURVEY_SS =
    ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_RAD_SURVEY_SS;
  static const SCANNER_CONTROL_SUBSTATE IMAGE_QUALITY_SS =
    ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_IMAGE_QUALITY_SS;
  static const SCANNER_CONTROL_SUBSTATE RAW_DATA_COLLECT_SS =
    ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_RAW_DATA_COLLECT_SS;
  static const SCANNER_CONTROL_SUBSTATE RAD_SURVEY_CANCEL_SS =
    ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_RAD_SURVEY_CANCEL_SS;
  static const SCANNER_CONTROL_SUBSTATE BELT_TUNNEL_CAL_SS =
    ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_BELT_TUNNEL_CAL_SS;
  static const SCANNER_CONTROL_SUBSTATE INTRUSION_DETECTED_SS =
    ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_INTRUSION_DETECTED_SS;
  static inline bool SCANNER_CONTROL_SUBSTATE_IsValid(int value) {
    return ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_IsValid(value);
  }
  static const SCANNER_CONTROL_SUBSTATE SCANNER_CONTROL_SUBSTATE_MIN =
    ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_SCANNER_CONTROL_SUBSTATE_MIN;
  static const SCANNER_CONTROL_SUBSTATE SCANNER_CONTROL_SUBSTATE_MAX =
    ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_SCANNER_CONTROL_SUBSTATE_MAX;
  static const int SCANNER_CONTROL_SUBSTATE_ARRAYSIZE =
    ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_SCANNER_CONTROL_SUBSTATE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SCANNER_CONTROL_SUBSTATE_descriptor() {
    return ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_descriptor();
  }
  static inline const ::std::string& SCANNER_CONTROL_SUBSTATE_Name(SCANNER_CONTROL_SUBSTATE value) {
    return ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_Name(value);
  }
  static inline bool SCANNER_CONTROL_SUBSTATE_Parse(const ::std::string& name,
      SCANNER_CONTROL_SUBSTATE* value) {
    return ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .analogic.ancp00.ScannerControlStatusMsg.SCANNER_CONTROL_STATE state = 1;
  void clear_state();
  static const int kStateFieldNumber = 1;
  ::analogic::ancp00::ScannerControlStatusMsg_SCANNER_CONTROL_STATE state() const;
  void set_state(::analogic::ancp00::ScannerControlStatusMsg_SCANNER_CONTROL_STATE value);

  // optional .analogic.ancp00.ScannerControlStatusMsg.SCANNER_CONTROL_SUBSTATE substate = 2;
  void clear_substate();
  static const int kSubstateFieldNumber = 2;
  ::analogic::ancp00::ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE substate() const;
  void set_substate(::analogic::ancp00::ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE value);

  // optional string scanner_name = 20;
  void clear_scanner_name();
  static const int kScannerNameFieldNumber = 20;
  const ::std::string& scanner_name() const;
  void set_scanner_name(const ::std::string& value);
  void set_scanner_name(const char* value);
  void set_scanner_name(const char* value, size_t size);
  ::std::string* mutable_scanner_name();
  ::std::string* release_scanner_name();
  void set_allocated_scanner_name(::std::string* scanner_name);

  // optional string scanner_state = 21;
  void clear_scanner_state();
  static const int kScannerStateFieldNumber = 21;
  const ::std::string& scanner_state() const;
  void set_scanner_state(const ::std::string& value);
  void set_scanner_state(const char* value);
  void set_scanner_state(const char* value, size_t size);
  ::std::string* mutable_scanner_state();
  ::std::string* release_scanner_state();
  void set_allocated_scanner_state(::std::string* scanner_state);

  // optional string xray_state = 22;
  void clear_xray_state();
  static const int kXrayStateFieldNumber = 22;
  const ::std::string& xray_state() const;
  void set_xray_state(const ::std::string& value);
  void set_xray_state(const char* value);
  void set_xray_state(const char* value, size_t size);
  ::std::string* mutable_xray_state();
  ::std::string* release_xray_state();
  void set_allocated_xray_state(::std::string* xray_state);

  // optional string current_date = 23;
  void clear_current_date();
  static const int kCurrentDateFieldNumber = 23;
  const ::std::string& current_date() const;
  void set_current_date(const ::std::string& value);
  void set_current_date(const char* value);
  void set_current_date(const char* value, size_t size);
  ::std::string* mutable_current_date();
  ::std::string* release_current_date();
  void set_allocated_current_date(::std::string* current_date);

  // optional string user_name = 24;
  void clear_user_name();
  static const int kUserNameFieldNumber = 24;
  const ::std::string& user_name() const;
  void set_user_name(const ::std::string& value);
  void set_user_name(const char* value);
  void set_user_name(const char* value, size_t size);
  ::std::string* mutable_user_name();
  ::std::string* release_user_name();
  void set_allocated_user_name(::std::string* user_name);

  // optional bool xray_on = 25;
  void clear_xray_on();
  static const int kXrayOnFieldNumber = 25;
  bool xray_on() const;
  void set_xray_on(bool value);

  // optional string last_air_cal_time = 26;
  void clear_last_air_cal_time();
  static const int kLastAirCalTimeFieldNumber = 26;
  const ::std::string& last_air_cal_time() const;
  void set_last_air_cal_time(const ::std::string& value);
  void set_last_air_cal_time(const char* value);
  void set_last_air_cal_time(const char* value, size_t size);
  ::std::string* mutable_last_air_cal_time();
  ::std::string* release_last_air_cal_time();
  void set_allocated_last_air_cal_time(::std::string* last_air_cal_time);

  // optional string last_offset_cal_time = 27;
  void clear_last_offset_cal_time();
  static const int kLastOffsetCalTimeFieldNumber = 27;
  const ::std::string& last_offset_cal_time() const;
  void set_last_offset_cal_time(const ::std::string& value);
  void set_last_offset_cal_time(const char* value);
  void set_last_offset_cal_time(const char* value, size_t size);
  ::std::string* mutable_last_offset_cal_time();
  ::std::string* release_last_offset_cal_time();
  void set_allocated_last_offset_cal_time(::std::string* last_offset_cal_time);

  // optional bool rtr = 28;
  void clear_rtr();
  static const int kRtrFieldNumber = 28;
  bool rtr() const;
  void set_rtr(bool value);

  // @@protoc_insertion_point(class_scope:analogic.ancp00.ScannerControlStatusMsg)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  int state_;
  int substate_;
  ::google::protobuf::internal::ArenaStringPtr scanner_name_;
  ::google::protobuf::internal::ArenaStringPtr scanner_state_;
  ::google::protobuf::internal::ArenaStringPtr xray_state_;
  ::google::protobuf::internal::ArenaStringPtr current_date_;
  ::google::protobuf::internal::ArenaStringPtr user_name_;
  ::google::protobuf::internal::ArenaStringPtr last_air_cal_time_;
  ::google::protobuf::internal::ArenaStringPtr last_offset_cal_time_;
  bool xray_on_;
  bool rtr_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_proto_2fScannerControl_2eproto();
  friend void protobuf_AssignDesc_proto_2fScannerControl_2eproto();
  friend void protobuf_ShutdownFile_proto_2fScannerControl_2eproto();

  void InitAsDefaultInstance();
  static ScannerControlStatusMsg* default_instance_;
};
// -------------------------------------------------------------------

class ScannerControlRpcSeq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:analogic.ancp00.ScannerControlRpcSeq) */ {
 public:
  ScannerControlRpcSeq();
  virtual ~ScannerControlRpcSeq();

  ScannerControlRpcSeq(const ScannerControlRpcSeq& from);

  inline ScannerControlRpcSeq& operator=(const ScannerControlRpcSeq& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ScannerControlRpcSeq& default_instance();

  void Swap(ScannerControlRpcSeq* other);

  // implements Message ----------------------------------------------

  inline ScannerControlRpcSeq* New() const { return New(NULL); }

  ScannerControlRpcSeq* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ScannerControlRpcSeq& from);
  void MergeFrom(const ScannerControlRpcSeq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ScannerControlRpcSeq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID SCANNER_CONTROL_RPC_SEQ_ID;
  static const SCANNER_CONTROL_RPC_SEQ_ID GET_COMPUTER_INFO =
    ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_GET_COMPUTER_INFO;
  static const SCANNER_CONTROL_RPC_SEQ_ID GET_BAD_DETECTOR_MAP_FILES =
    ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_GET_BAD_DETECTOR_MAP_FILES;
  static const SCANNER_CONTROL_RPC_SEQ_ID GET_BAD_DETECTOR_MANUAL_FILE =
    ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_GET_BAD_DETECTOR_MANUAL_FILE;
  static const SCANNER_CONTROL_RPC_SEQ_ID UPDATE_BAD_DETECTOR_MANUAL_FILE =
    ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_UPDATE_BAD_DETECTOR_MANUAL_FILE;
  static const SCANNER_CONTROL_RPC_SEQ_ID GET_ERROR_LOG_FILE =
    ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_GET_ERROR_LOG_FILE;
  static const SCANNER_CONTROL_RPC_SEQ_ID GET_IMAGE_CALIBRATION_FILES =
    ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_GET_IMAGE_CALIBRATION_FILES;
  static const SCANNER_CONTROL_RPC_SEQ_ID VIEW_IMAGE_QUALITY_REPORT =
    ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_VIEW_IMAGE_QUALITY_REPORT;
  static const SCANNER_CONTROL_RPC_SEQ_ID RUN_IMAGE_CALIBRATION =
    ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_RUN_IMAGE_CALIBRATION;
  static const SCANNER_CONTROL_RPC_SEQ_ID UPDATE_IMAGE_CALIBRATION_BELT_HEIGHT =
    ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_UPDATE_IMAGE_CALIBRATION_BELT_HEIGHT;
  static const SCANNER_CONTROL_RPC_SEQ_ID UPDATE_IMAGE_CALIBRATION_NYLON_SCALE =
    ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_UPDATE_IMAGE_CALIBRATION_NYLON_SCALE;
  static const SCANNER_CONTROL_RPC_SEQ_ID EXPORT_FILES =
    ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_EXPORT_FILES;
  static const SCANNER_CONTROL_RPC_SEQ_ID GET_SCANNER_CONFIG_FILE =
    ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_GET_SCANNER_CONFIG_FILE;
  static const SCANNER_CONTROL_RPC_SEQ_ID UPDATE_SCANNER_CONFIG_FILE =
    ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_UPDATE_SCANNER_CONFIG_FILE;
  static const SCANNER_CONTROL_RPC_SEQ_ID GET_WS_SCANNER_CONFIG_FILE =
    ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_GET_WS_SCANNER_CONFIG_FILE;
  static const SCANNER_CONTROL_RPC_SEQ_ID UPDATE_WS_SCANNER_CONFIG_FILE =
    ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_UPDATE_WS_SCANNER_CONFIG_FILE;
  static const SCANNER_CONTROL_RPC_SEQ_ID GET_IMAGE_QUALITY_MASS_VALUES =
    ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_GET_IMAGE_QUALITY_MASS_VALUES;
  static const SCANNER_CONTROL_RPC_SEQ_ID GET_INSTALLED_ALARM_LIBS =
    ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_GET_INSTALLED_ALARM_LIBS;
  static const SCANNER_CONTROL_RPC_SEQ_ID GET_INSTALLABLE_ALARM_LIBS =
    ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_GET_INSTALLABLE_ALARM_LIBS;
  static const SCANNER_CONTROL_RPC_SEQ_ID INSTALL_ALARM_LIB =
    ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_INSTALL_ALARM_LIB;
  static const SCANNER_CONTROL_RPC_SEQ_ID UPDATE_IMAGE_CALIBRATION_BELT_FREQ =
    ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_UPDATE_IMAGE_CALIBRATION_BELT_FREQ;
  static const SCANNER_CONTROL_RPC_SEQ_ID EXPORT_CAL_PARAM_DATA =
    ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_EXPORT_CAL_PARAM_DATA;
  static const SCANNER_CONTROL_RPC_SEQ_ID IMPORT_CAL_PARAM_DATA =
    ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_IMPORT_CAL_PARAM_DATA;
  static const SCANNER_CONTROL_RPC_SEQ_ID AIR_CAL =
    ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_AIR_CAL;
  static const SCANNER_CONTROL_RPC_SEQ_ID OFFSET_CAL =
    ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_OFFSET_CAL;
  static const SCANNER_CONTROL_RPC_SEQ_ID PIN_CAL =
    ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_PIN_CAL;
  static const SCANNER_CONTROL_RPC_SEQ_ID ZEE_ALIGN =
    ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_ZEE_ALIGN;
  static const SCANNER_CONTROL_RPC_SEQ_ID SPECTRAL_CAL =
    ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_SPECTRAL_CAL;
  static const SCANNER_CONTROL_RPC_SEQ_ID RADIATION_SURVEY =
    ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_RADIATION_SURVEY;
  static const SCANNER_CONTROL_RPC_SEQ_ID RADIATION_SURVEY_CANCEL =
    ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_RADIATION_SURVEY_CANCEL;
  static const SCANNER_CONTROL_RPC_SEQ_ID RAW_DATA_COLLECT =
    ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_RAW_DATA_COLLECT;
  static const SCANNER_CONTROL_RPC_SEQ_ID IMAGE_QUALITY_TEST_RUN =
    ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_IMAGE_QUALITY_TEST_RUN;
  static const SCANNER_CONTROL_RPC_SEQ_ID IMAGE_QUALITY_TEST_CANCEL =
    ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_IMAGE_QUALITY_TEST_CANCEL;
  static const SCANNER_CONTROL_RPC_SEQ_ID CAL_PROCEED =
    ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_CAL_PROCEED;
  static const SCANNER_CONTROL_RPC_SEQ_ID CAL_CANCEL =
    ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_CAL_CANCEL;
  static const SCANNER_CONTROL_RPC_SEQ_ID ZEE_PIN_SPECTRAL_CAL_SEQ =
    ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_ZEE_PIN_SPECTRAL_CAL_SEQ;
  static const SCANNER_CONTROL_RPC_SEQ_ID BELT_TUNNEL_CAL_NO_WINDOW =
    ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_BELT_TUNNEL_CAL_NO_WINDOW;
  static const SCANNER_CONTROL_RPC_SEQ_ID BELT_TUNNEL_CAL_WITH_WINDOW =
    ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_BELT_TUNNEL_CAL_WITH_WINDOW;
  static const SCANNER_CONTROL_RPC_SEQ_ID GANTRY_CONTROL_SEQ =
    ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_GANTRY_CONTROL_SEQ;
  static const SCANNER_CONTROL_RPC_SEQ_ID CONVEYOR_CONTROL_SEQ =
    ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_CONVEYOR_CONTROL_SEQ;
  static const SCANNER_CONTROL_RPC_SEQ_ID XRAY_CONTROL_SEQ =
    ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_XRAY_CONTROL_SEQ;
  static const SCANNER_CONTROL_RPC_SEQ_ID XRAY_SEASON_SEQ =
    ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_XRAY_SEASON_SEQ;
  static const SCANNER_CONTROL_RPC_SEQ_ID GO_TO_IDLE_SEQ =
    ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_GO_TO_IDLE_SEQ;
  static const SCANNER_CONTROL_RPC_SEQ_ID GO_TO_SCAN_SEQ =
    ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_GO_TO_SCAN_SEQ;
  static const SCANNER_CONTROL_RPC_SEQ_ID GO_TO_PASSTHRU_SEQ =
    ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_GO_TO_PASSTHRU_SEQ;
  static const SCANNER_CONTROL_RPC_SEQ_ID GO_TO_STANDBY_SEQ =
    ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_GO_TO_STANDBY_SEQ;
  static const SCANNER_CONTROL_RPC_SEQ_ID RESET_FAULT_SEQ =
    ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_RESET_FAULT_SEQ;
  static const SCANNER_CONTROL_RPC_SEQ_ID SHUTDOWN_SEQ =
    ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_SHUTDOWN_SEQ;
  static const SCANNER_CONTROL_RPC_SEQ_ID DYNAMIC_AIR_CAL_SEQ =
    ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_DYNAMIC_AIR_CAL_SEQ;
  static const SCANNER_CONTROL_RPC_SEQ_ID DYNAMIC_OFFSET_CAL_SEQ =
    ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_DYNAMIC_OFFSET_CAL_SEQ;
  static const SCANNER_CONTROL_RPC_SEQ_ID CONV_STOP_XRAY_MIN_SEQ =
    ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_CONV_STOP_XRAY_MIN_SEQ;
  static const SCANNER_CONTROL_RPC_SEQ_ID XRAY_MAX_CONV_RUN_SEQ =
    ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_XRAY_MAX_CONV_RUN_SEQ;
  static const SCANNER_CONTROL_RPC_SEQ_ID CONV_STOP_XRAY_MIN_CONV_RUN_SEQ =
    ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_CONV_STOP_XRAY_MIN_CONV_RUN_SEQ;
  static const SCANNER_CONTROL_RPC_SEQ_ID CONVEYOR_FLUSH_SEQ =
    ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_CONVEYOR_FLUSH_SEQ;
  static const SCANNER_CONTROL_RPC_SEQ_ID GANTRY_RUN_SEQ =
    ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_GANTRY_RUN_SEQ;
  static const SCANNER_CONTROL_RPC_SEQ_ID GANTRY_STOP_SEQ =
    ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_GANTRY_STOP_SEQ;
  static const SCANNER_CONTROL_RPC_SEQ_ID CONVEYOR_RUN_SEQ =
    ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_CONVEYOR_RUN_SEQ;
  static const SCANNER_CONTROL_RPC_SEQ_ID CONVEYOR_STOP_SEQ =
    ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_CONVEYOR_STOP_SEQ;
  static const SCANNER_CONTROL_RPC_SEQ_ID XRAY_ON_SEQ =
    ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_XRAY_ON_SEQ;
  static const SCANNER_CONTROL_RPC_SEQ_ID XRAY_OFF_SEQ =
    ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_XRAY_OFF_SEQ;
  static const SCANNER_CONTROL_RPC_SEQ_ID XRAY_MINIMIZE_SEQ =
    ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_XRAY_MINIMIZE_SEQ;
  static const SCANNER_CONTROL_RPC_SEQ_ID XRAY_MAXIMIZE_SEQ =
    ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_XRAY_MAXIMIZE_SEQ;
  static const SCANNER_CONTROL_RPC_SEQ_ID XRAY_SEASONING_SHORT_SEQ =
    ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_XRAY_SEASONING_SHORT_SEQ;
  static const SCANNER_CONTROL_RPC_SEQ_ID XRAY_SEASONING_MEDIUM_SEQ =
    ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_XRAY_SEASONING_MEDIUM_SEQ;
  static const SCANNER_CONTROL_RPC_SEQ_ID XRAY_SEASONING_LONG_SEQ =
    ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_XRAY_SEASONING_LONG_SEQ;
  static inline bool SCANNER_CONTROL_RPC_SEQ_ID_IsValid(int value) {
    return ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_IsValid(value);
  }
  static const SCANNER_CONTROL_RPC_SEQ_ID SCANNER_CONTROL_RPC_SEQ_ID_MIN =
    ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_SCANNER_CONTROL_RPC_SEQ_ID_MIN;
  static const SCANNER_CONTROL_RPC_SEQ_ID SCANNER_CONTROL_RPC_SEQ_ID_MAX =
    ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_SCANNER_CONTROL_RPC_SEQ_ID_MAX;
  static const int SCANNER_CONTROL_RPC_SEQ_ID_ARRAYSIZE =
    ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_SCANNER_CONTROL_RPC_SEQ_ID_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SCANNER_CONTROL_RPC_SEQ_ID_descriptor() {
    return ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_descriptor();
  }
  static inline const ::std::string& SCANNER_CONTROL_RPC_SEQ_ID_Name(SCANNER_CONTROL_RPC_SEQ_ID value) {
    return ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_Name(value);
  }
  static inline bool SCANNER_CONTROL_RPC_SEQ_ID_Parse(const ::std::string& name,
      SCANNER_CONTROL_RPC_SEQ_ID* value) {
    return ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .analogic.ancp00.ScannerControlRpcSeq.SCANNER_CONTROL_RPC_SEQ_ID id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::analogic::ancp00::ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID id() const;
  void set_id(::analogic::ancp00::ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID value);

  // @@protoc_insertion_point(class_scope:analogic.ancp00.ScannerControlRpcSeq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  int id_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_proto_2fScannerControl_2eproto();
  friend void protobuf_AssignDesc_proto_2fScannerControl_2eproto();
  friend void protobuf_ShutdownFile_proto_2fScannerControl_2eproto();

  void InitAsDefaultInstance();
  static ScannerControlRpcSeq* default_instance_;
};
// -------------------------------------------------------------------

class CtrlSeqStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:analogic.ancp00.CtrlSeqStatus) */ {
 public:
  CtrlSeqStatus();
  virtual ~CtrlSeqStatus();

  CtrlSeqStatus(const CtrlSeqStatus& from);

  inline CtrlSeqStatus& operator=(const CtrlSeqStatus& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CtrlSeqStatus& default_instance();

  void Swap(CtrlSeqStatus* other);

  // implements Message ----------------------------------------------

  inline CtrlSeqStatus* New() const { return New(NULL); }

  CtrlSeqStatus* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CtrlSeqStatus& from);
  void MergeFrom(const CtrlSeqStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CtrlSeqStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CtrlSeqStatus_CTRL_SEQ_STATUS CTRL_SEQ_STATUS;
  static const CTRL_SEQ_STATUS CTRL_SEQ_IDLE =
    CtrlSeqStatus_CTRL_SEQ_STATUS_CTRL_SEQ_IDLE;
  static const CTRL_SEQ_STATUS CTRL_SEQ_RUNNING =
    CtrlSeqStatus_CTRL_SEQ_STATUS_CTRL_SEQ_RUNNING;
  static const CTRL_SEQ_STATUS CTRL_SEQ_PAUSED =
    CtrlSeqStatus_CTRL_SEQ_STATUS_CTRL_SEQ_PAUSED;
  static const CTRL_SEQ_STATUS CTRL_SEQ_RESUMED =
    CtrlSeqStatus_CTRL_SEQ_STATUS_CTRL_SEQ_RESUMED;
  static const CTRL_SEQ_STATUS CTRL_SEQ_COMPLETE =
    CtrlSeqStatus_CTRL_SEQ_STATUS_CTRL_SEQ_COMPLETE;
  static const CTRL_SEQ_STATUS CTRL_SEQ_ERROR =
    CtrlSeqStatus_CTRL_SEQ_STATUS_CTRL_SEQ_ERROR;
  static const CTRL_SEQ_STATUS CTRL_SEQ_ABORTED =
    CtrlSeqStatus_CTRL_SEQ_STATUS_CTRL_SEQ_ABORTED;
  static inline bool CTRL_SEQ_STATUS_IsValid(int value) {
    return CtrlSeqStatus_CTRL_SEQ_STATUS_IsValid(value);
  }
  static const CTRL_SEQ_STATUS CTRL_SEQ_STATUS_MIN =
    CtrlSeqStatus_CTRL_SEQ_STATUS_CTRL_SEQ_STATUS_MIN;
  static const CTRL_SEQ_STATUS CTRL_SEQ_STATUS_MAX =
    CtrlSeqStatus_CTRL_SEQ_STATUS_CTRL_SEQ_STATUS_MAX;
  static const int CTRL_SEQ_STATUS_ARRAYSIZE =
    CtrlSeqStatus_CTRL_SEQ_STATUS_CTRL_SEQ_STATUS_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CTRL_SEQ_STATUS_descriptor() {
    return CtrlSeqStatus_CTRL_SEQ_STATUS_descriptor();
  }
  static inline const ::std::string& CTRL_SEQ_STATUS_Name(CTRL_SEQ_STATUS value) {
    return CtrlSeqStatus_CTRL_SEQ_STATUS_Name(value);
  }
  static inline bool CTRL_SEQ_STATUS_Parse(const ::std::string& name,
      CTRL_SEQ_STATUS* value) {
    return CtrlSeqStatus_CTRL_SEQ_STATUS_Parse(name, value);
  }

  typedef CtrlSeqStatus_CTRL_SEQ_ERROR_CODE CTRL_SEQ_ERROR_CODE;
  static const CTRL_SEQ_ERROR_CODE CTRL_SEQ_ERROR_NONE =
    CtrlSeqStatus_CTRL_SEQ_ERROR_CODE_CTRL_SEQ_ERROR_NONE;
  static const CTRL_SEQ_ERROR_CODE CTRL_SEQ_ERROR_TIMEOUT =
    CtrlSeqStatus_CTRL_SEQ_ERROR_CODE_CTRL_SEQ_ERROR_TIMEOUT;
  static const CTRL_SEQ_ERROR_CODE CTRL_SEQ_SEQ_ERROR =
    CtrlSeqStatus_CTRL_SEQ_ERROR_CODE_CTRL_SEQ_SEQ_ERROR;
  static inline bool CTRL_SEQ_ERROR_CODE_IsValid(int value) {
    return CtrlSeqStatus_CTRL_SEQ_ERROR_CODE_IsValid(value);
  }
  static const CTRL_SEQ_ERROR_CODE CTRL_SEQ_ERROR_CODE_MIN =
    CtrlSeqStatus_CTRL_SEQ_ERROR_CODE_CTRL_SEQ_ERROR_CODE_MIN;
  static const CTRL_SEQ_ERROR_CODE CTRL_SEQ_ERROR_CODE_MAX =
    CtrlSeqStatus_CTRL_SEQ_ERROR_CODE_CTRL_SEQ_ERROR_CODE_MAX;
  static const int CTRL_SEQ_ERROR_CODE_ARRAYSIZE =
    CtrlSeqStatus_CTRL_SEQ_ERROR_CODE_CTRL_SEQ_ERROR_CODE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CTRL_SEQ_ERROR_CODE_descriptor() {
    return CtrlSeqStatus_CTRL_SEQ_ERROR_CODE_descriptor();
  }
  static inline const ::std::string& CTRL_SEQ_ERROR_CODE_Name(CTRL_SEQ_ERROR_CODE value) {
    return CtrlSeqStatus_CTRL_SEQ_ERROR_CODE_Name(value);
  }
  static inline bool CTRL_SEQ_ERROR_CODE_Parse(const ::std::string& name,
      CTRL_SEQ_ERROR_CODE* value) {
    return CtrlSeqStatus_CTRL_SEQ_ERROR_CODE_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .analogic.ancp00.CtrlSeqStatus.CTRL_SEQ_STATUS status = 1;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::analogic::ancp00::CtrlSeqStatus_CTRL_SEQ_STATUS status() const;
  void set_status(::analogic::ancp00::CtrlSeqStatus_CTRL_SEQ_STATUS value);

  // optional .analogic.ancp00.CtrlSeqStatus.CTRL_SEQ_ERROR_CODE error_code = 2;
  void clear_error_code();
  static const int kErrorCodeFieldNumber = 2;
  ::analogic::ancp00::CtrlSeqStatus_CTRL_SEQ_ERROR_CODE error_code() const;
  void set_error_code(::analogic::ancp00::CtrlSeqStatus_CTRL_SEQ_ERROR_CODE value);

  // @@protoc_insertion_point(class_scope:analogic.ancp00.CtrlSeqStatus)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  int status_;
  int error_code_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_proto_2fScannerControl_2eproto();
  friend void protobuf_AssignDesc_proto_2fScannerControl_2eproto();
  friend void protobuf_ShutdownFile_proto_2fScannerControl_2eproto();

  void InitAsDefaultInstance();
  static CtrlSeqStatus* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// ScannerControlMsg

// optional .analogic.ancp00.ScannerControlMsg.SCANNER_CONTROL_CMD cmd_id = 1;
inline void ScannerControlMsg::clear_cmd_id() {
  cmd_id_ = 0;
}
inline ::analogic::ancp00::ScannerControlMsg_SCANNER_CONTROL_CMD ScannerControlMsg::cmd_id() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.ScannerControlMsg.cmd_id)
  return static_cast< ::analogic::ancp00::ScannerControlMsg_SCANNER_CONTROL_CMD >(cmd_id_);
}
inline void ScannerControlMsg::set_cmd_id(::analogic::ancp00::ScannerControlMsg_SCANNER_CONTROL_CMD value) {
  
  cmd_id_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.ScannerControlMsg.cmd_id)
}

// optional string text = 2;
inline void ScannerControlMsg::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ScannerControlMsg::text() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.ScannerControlMsg.text)
  return text_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ScannerControlMsg::set_text(const ::std::string& value) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:analogic.ancp00.ScannerControlMsg.text)
}
inline void ScannerControlMsg::set_text(const char* value) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:analogic.ancp00.ScannerControlMsg.text)
}
inline void ScannerControlMsg::set_text(const char* value, size_t size) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:analogic.ancp00.ScannerControlMsg.text)
}
inline ::std::string* ScannerControlMsg::mutable_text() {
  
  // @@protoc_insertion_point(field_mutable:analogic.ancp00.ScannerControlMsg.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ScannerControlMsg::release_text() {
  // @@protoc_insertion_point(field_release:analogic.ancp00.ScannerControlMsg.text)
  
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ScannerControlMsg::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    
  } else {
    
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:analogic.ancp00.ScannerControlMsg.text)
}

// -------------------------------------------------------------------

// ScannerControlStatusMsg

// optional .analogic.ancp00.ScannerControlStatusMsg.SCANNER_CONTROL_STATE state = 1;
inline void ScannerControlStatusMsg::clear_state() {
  state_ = 0;
}
inline ::analogic::ancp00::ScannerControlStatusMsg_SCANNER_CONTROL_STATE ScannerControlStatusMsg::state() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.ScannerControlStatusMsg.state)
  return static_cast< ::analogic::ancp00::ScannerControlStatusMsg_SCANNER_CONTROL_STATE >(state_);
}
inline void ScannerControlStatusMsg::set_state(::analogic::ancp00::ScannerControlStatusMsg_SCANNER_CONTROL_STATE value) {
  
  state_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.ScannerControlStatusMsg.state)
}

// optional .analogic.ancp00.ScannerControlStatusMsg.SCANNER_CONTROL_SUBSTATE substate = 2;
inline void ScannerControlStatusMsg::clear_substate() {
  substate_ = 0;
}
inline ::analogic::ancp00::ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE ScannerControlStatusMsg::substate() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.ScannerControlStatusMsg.substate)
  return static_cast< ::analogic::ancp00::ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE >(substate_);
}
inline void ScannerControlStatusMsg::set_substate(::analogic::ancp00::ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE value) {
  
  substate_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.ScannerControlStatusMsg.substate)
}

// optional string scanner_name = 20;
inline void ScannerControlStatusMsg::clear_scanner_name() {
  scanner_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ScannerControlStatusMsg::scanner_name() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.ScannerControlStatusMsg.scanner_name)
  return scanner_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ScannerControlStatusMsg::set_scanner_name(const ::std::string& value) {
  
  scanner_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:analogic.ancp00.ScannerControlStatusMsg.scanner_name)
}
inline void ScannerControlStatusMsg::set_scanner_name(const char* value) {
  
  scanner_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:analogic.ancp00.ScannerControlStatusMsg.scanner_name)
}
inline void ScannerControlStatusMsg::set_scanner_name(const char* value, size_t size) {
  
  scanner_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:analogic.ancp00.ScannerControlStatusMsg.scanner_name)
}
inline ::std::string* ScannerControlStatusMsg::mutable_scanner_name() {
  
  // @@protoc_insertion_point(field_mutable:analogic.ancp00.ScannerControlStatusMsg.scanner_name)
  return scanner_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ScannerControlStatusMsg::release_scanner_name() {
  // @@protoc_insertion_point(field_release:analogic.ancp00.ScannerControlStatusMsg.scanner_name)
  
  return scanner_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ScannerControlStatusMsg::set_allocated_scanner_name(::std::string* scanner_name) {
  if (scanner_name != NULL) {
    
  } else {
    
  }
  scanner_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), scanner_name);
  // @@protoc_insertion_point(field_set_allocated:analogic.ancp00.ScannerControlStatusMsg.scanner_name)
}

// optional string scanner_state = 21;
inline void ScannerControlStatusMsg::clear_scanner_state() {
  scanner_state_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ScannerControlStatusMsg::scanner_state() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.ScannerControlStatusMsg.scanner_state)
  return scanner_state_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ScannerControlStatusMsg::set_scanner_state(const ::std::string& value) {
  
  scanner_state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:analogic.ancp00.ScannerControlStatusMsg.scanner_state)
}
inline void ScannerControlStatusMsg::set_scanner_state(const char* value) {
  
  scanner_state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:analogic.ancp00.ScannerControlStatusMsg.scanner_state)
}
inline void ScannerControlStatusMsg::set_scanner_state(const char* value, size_t size) {
  
  scanner_state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:analogic.ancp00.ScannerControlStatusMsg.scanner_state)
}
inline ::std::string* ScannerControlStatusMsg::mutable_scanner_state() {
  
  // @@protoc_insertion_point(field_mutable:analogic.ancp00.ScannerControlStatusMsg.scanner_state)
  return scanner_state_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ScannerControlStatusMsg::release_scanner_state() {
  // @@protoc_insertion_point(field_release:analogic.ancp00.ScannerControlStatusMsg.scanner_state)
  
  return scanner_state_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ScannerControlStatusMsg::set_allocated_scanner_state(::std::string* scanner_state) {
  if (scanner_state != NULL) {
    
  } else {
    
  }
  scanner_state_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), scanner_state);
  // @@protoc_insertion_point(field_set_allocated:analogic.ancp00.ScannerControlStatusMsg.scanner_state)
}

// optional string xray_state = 22;
inline void ScannerControlStatusMsg::clear_xray_state() {
  xray_state_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ScannerControlStatusMsg::xray_state() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.ScannerControlStatusMsg.xray_state)
  return xray_state_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ScannerControlStatusMsg::set_xray_state(const ::std::string& value) {
  
  xray_state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:analogic.ancp00.ScannerControlStatusMsg.xray_state)
}
inline void ScannerControlStatusMsg::set_xray_state(const char* value) {
  
  xray_state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:analogic.ancp00.ScannerControlStatusMsg.xray_state)
}
inline void ScannerControlStatusMsg::set_xray_state(const char* value, size_t size) {
  
  xray_state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:analogic.ancp00.ScannerControlStatusMsg.xray_state)
}
inline ::std::string* ScannerControlStatusMsg::mutable_xray_state() {
  
  // @@protoc_insertion_point(field_mutable:analogic.ancp00.ScannerControlStatusMsg.xray_state)
  return xray_state_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ScannerControlStatusMsg::release_xray_state() {
  // @@protoc_insertion_point(field_release:analogic.ancp00.ScannerControlStatusMsg.xray_state)
  
  return xray_state_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ScannerControlStatusMsg::set_allocated_xray_state(::std::string* xray_state) {
  if (xray_state != NULL) {
    
  } else {
    
  }
  xray_state_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), xray_state);
  // @@protoc_insertion_point(field_set_allocated:analogic.ancp00.ScannerControlStatusMsg.xray_state)
}

// optional string current_date = 23;
inline void ScannerControlStatusMsg::clear_current_date() {
  current_date_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ScannerControlStatusMsg::current_date() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.ScannerControlStatusMsg.current_date)
  return current_date_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ScannerControlStatusMsg::set_current_date(const ::std::string& value) {
  
  current_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:analogic.ancp00.ScannerControlStatusMsg.current_date)
}
inline void ScannerControlStatusMsg::set_current_date(const char* value) {
  
  current_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:analogic.ancp00.ScannerControlStatusMsg.current_date)
}
inline void ScannerControlStatusMsg::set_current_date(const char* value, size_t size) {
  
  current_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:analogic.ancp00.ScannerControlStatusMsg.current_date)
}
inline ::std::string* ScannerControlStatusMsg::mutable_current_date() {
  
  // @@protoc_insertion_point(field_mutable:analogic.ancp00.ScannerControlStatusMsg.current_date)
  return current_date_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ScannerControlStatusMsg::release_current_date() {
  // @@protoc_insertion_point(field_release:analogic.ancp00.ScannerControlStatusMsg.current_date)
  
  return current_date_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ScannerControlStatusMsg::set_allocated_current_date(::std::string* current_date) {
  if (current_date != NULL) {
    
  } else {
    
  }
  current_date_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), current_date);
  // @@protoc_insertion_point(field_set_allocated:analogic.ancp00.ScannerControlStatusMsg.current_date)
}

// optional string user_name = 24;
inline void ScannerControlStatusMsg::clear_user_name() {
  user_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ScannerControlStatusMsg::user_name() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.ScannerControlStatusMsg.user_name)
  return user_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ScannerControlStatusMsg::set_user_name(const ::std::string& value) {
  
  user_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:analogic.ancp00.ScannerControlStatusMsg.user_name)
}
inline void ScannerControlStatusMsg::set_user_name(const char* value) {
  
  user_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:analogic.ancp00.ScannerControlStatusMsg.user_name)
}
inline void ScannerControlStatusMsg::set_user_name(const char* value, size_t size) {
  
  user_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:analogic.ancp00.ScannerControlStatusMsg.user_name)
}
inline ::std::string* ScannerControlStatusMsg::mutable_user_name() {
  
  // @@protoc_insertion_point(field_mutable:analogic.ancp00.ScannerControlStatusMsg.user_name)
  return user_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ScannerControlStatusMsg::release_user_name() {
  // @@protoc_insertion_point(field_release:analogic.ancp00.ScannerControlStatusMsg.user_name)
  
  return user_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ScannerControlStatusMsg::set_allocated_user_name(::std::string* user_name) {
  if (user_name != NULL) {
    
  } else {
    
  }
  user_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user_name);
  // @@protoc_insertion_point(field_set_allocated:analogic.ancp00.ScannerControlStatusMsg.user_name)
}

// optional bool xray_on = 25;
inline void ScannerControlStatusMsg::clear_xray_on() {
  xray_on_ = false;
}
inline bool ScannerControlStatusMsg::xray_on() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.ScannerControlStatusMsg.xray_on)
  return xray_on_;
}
inline void ScannerControlStatusMsg::set_xray_on(bool value) {
  
  xray_on_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.ScannerControlStatusMsg.xray_on)
}

// optional string last_air_cal_time = 26;
inline void ScannerControlStatusMsg::clear_last_air_cal_time() {
  last_air_cal_time_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ScannerControlStatusMsg::last_air_cal_time() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.ScannerControlStatusMsg.last_air_cal_time)
  return last_air_cal_time_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ScannerControlStatusMsg::set_last_air_cal_time(const ::std::string& value) {
  
  last_air_cal_time_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:analogic.ancp00.ScannerControlStatusMsg.last_air_cal_time)
}
inline void ScannerControlStatusMsg::set_last_air_cal_time(const char* value) {
  
  last_air_cal_time_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:analogic.ancp00.ScannerControlStatusMsg.last_air_cal_time)
}
inline void ScannerControlStatusMsg::set_last_air_cal_time(const char* value, size_t size) {
  
  last_air_cal_time_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:analogic.ancp00.ScannerControlStatusMsg.last_air_cal_time)
}
inline ::std::string* ScannerControlStatusMsg::mutable_last_air_cal_time() {
  
  // @@protoc_insertion_point(field_mutable:analogic.ancp00.ScannerControlStatusMsg.last_air_cal_time)
  return last_air_cal_time_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ScannerControlStatusMsg::release_last_air_cal_time() {
  // @@protoc_insertion_point(field_release:analogic.ancp00.ScannerControlStatusMsg.last_air_cal_time)
  
  return last_air_cal_time_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ScannerControlStatusMsg::set_allocated_last_air_cal_time(::std::string* last_air_cal_time) {
  if (last_air_cal_time != NULL) {
    
  } else {
    
  }
  last_air_cal_time_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), last_air_cal_time);
  // @@protoc_insertion_point(field_set_allocated:analogic.ancp00.ScannerControlStatusMsg.last_air_cal_time)
}

// optional string last_offset_cal_time = 27;
inline void ScannerControlStatusMsg::clear_last_offset_cal_time() {
  last_offset_cal_time_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ScannerControlStatusMsg::last_offset_cal_time() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.ScannerControlStatusMsg.last_offset_cal_time)
  return last_offset_cal_time_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ScannerControlStatusMsg::set_last_offset_cal_time(const ::std::string& value) {
  
  last_offset_cal_time_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:analogic.ancp00.ScannerControlStatusMsg.last_offset_cal_time)
}
inline void ScannerControlStatusMsg::set_last_offset_cal_time(const char* value) {
  
  last_offset_cal_time_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:analogic.ancp00.ScannerControlStatusMsg.last_offset_cal_time)
}
inline void ScannerControlStatusMsg::set_last_offset_cal_time(const char* value, size_t size) {
  
  last_offset_cal_time_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:analogic.ancp00.ScannerControlStatusMsg.last_offset_cal_time)
}
inline ::std::string* ScannerControlStatusMsg::mutable_last_offset_cal_time() {
  
  // @@protoc_insertion_point(field_mutable:analogic.ancp00.ScannerControlStatusMsg.last_offset_cal_time)
  return last_offset_cal_time_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ScannerControlStatusMsg::release_last_offset_cal_time() {
  // @@protoc_insertion_point(field_release:analogic.ancp00.ScannerControlStatusMsg.last_offset_cal_time)
  
  return last_offset_cal_time_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ScannerControlStatusMsg::set_allocated_last_offset_cal_time(::std::string* last_offset_cal_time) {
  if (last_offset_cal_time != NULL) {
    
  } else {
    
  }
  last_offset_cal_time_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), last_offset_cal_time);
  // @@protoc_insertion_point(field_set_allocated:analogic.ancp00.ScannerControlStatusMsg.last_offset_cal_time)
}

// optional bool rtr = 28;
inline void ScannerControlStatusMsg::clear_rtr() {
  rtr_ = false;
}
inline bool ScannerControlStatusMsg::rtr() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.ScannerControlStatusMsg.rtr)
  return rtr_;
}
inline void ScannerControlStatusMsg::set_rtr(bool value) {
  
  rtr_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.ScannerControlStatusMsg.rtr)
}

// -------------------------------------------------------------------

// ScannerControlRpcSeq

// optional .analogic.ancp00.ScannerControlRpcSeq.SCANNER_CONTROL_RPC_SEQ_ID id = 1;
inline void ScannerControlRpcSeq::clear_id() {
  id_ = 0;
}
inline ::analogic::ancp00::ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID ScannerControlRpcSeq::id() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.ScannerControlRpcSeq.id)
  return static_cast< ::analogic::ancp00::ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID >(id_);
}
inline void ScannerControlRpcSeq::set_id(::analogic::ancp00::ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.ScannerControlRpcSeq.id)
}

// -------------------------------------------------------------------

// CtrlSeqStatus

// optional .analogic.ancp00.CtrlSeqStatus.CTRL_SEQ_STATUS status = 1;
inline void CtrlSeqStatus::clear_status() {
  status_ = 0;
}
inline ::analogic::ancp00::CtrlSeqStatus_CTRL_SEQ_STATUS CtrlSeqStatus::status() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.CtrlSeqStatus.status)
  return static_cast< ::analogic::ancp00::CtrlSeqStatus_CTRL_SEQ_STATUS >(status_);
}
inline void CtrlSeqStatus::set_status(::analogic::ancp00::CtrlSeqStatus_CTRL_SEQ_STATUS value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.CtrlSeqStatus.status)
}

// optional .analogic.ancp00.CtrlSeqStatus.CTRL_SEQ_ERROR_CODE error_code = 2;
inline void CtrlSeqStatus::clear_error_code() {
  error_code_ = 0;
}
inline ::analogic::ancp00::CtrlSeqStatus_CTRL_SEQ_ERROR_CODE CtrlSeqStatus::error_code() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.CtrlSeqStatus.error_code)
  return static_cast< ::analogic::ancp00::CtrlSeqStatus_CTRL_SEQ_ERROR_CODE >(error_code_);
}
inline void CtrlSeqStatus::set_error_code(::analogic::ancp00::CtrlSeqStatus_CTRL_SEQ_ERROR_CODE value) {
  
  error_code_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.CtrlSeqStatus.error_code)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace ancp00
}  // namespace analogic

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::analogic::ancp00::ScannerControlMsg_SCANNER_CONTROL_CMD> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::analogic::ancp00::ScannerControlMsg_SCANNER_CONTROL_CMD>() {
  return ::analogic::ancp00::ScannerControlMsg_SCANNER_CONTROL_CMD_descriptor();
}
template <> struct is_proto_enum< ::analogic::ancp00::ScannerControlStatusMsg_SCANNER_CONTROL_STATE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::analogic::ancp00::ScannerControlStatusMsg_SCANNER_CONTROL_STATE>() {
  return ::analogic::ancp00::ScannerControlStatusMsg_SCANNER_CONTROL_STATE_descriptor();
}
template <> struct is_proto_enum< ::analogic::ancp00::ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::analogic::ancp00::ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE>() {
  return ::analogic::ancp00::ScannerControlStatusMsg_SCANNER_CONTROL_SUBSTATE_descriptor();
}
template <> struct is_proto_enum< ::analogic::ancp00::ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::analogic::ancp00::ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID>() {
  return ::analogic::ancp00::ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID_descriptor();
}
template <> struct is_proto_enum< ::analogic::ancp00::CtrlSeqStatus_CTRL_SEQ_STATUS> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::analogic::ancp00::CtrlSeqStatus_CTRL_SEQ_STATUS>() {
  return ::analogic::ancp00::CtrlSeqStatus_CTRL_SEQ_STATUS_descriptor();
}
template <> struct is_proto_enum< ::analogic::ancp00::CtrlSeqStatus_CTRL_SEQ_ERROR_CODE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::analogic::ancp00::CtrlSeqStatus_CTRL_SEQ_ERROR_CODE>() {
  return ::analogic::ancp00::CtrlSeqStatus_CTRL_SEQ_ERROR_CODE_descriptor();
}
template <> struct is_proto_enum< ::analogic::ancp00::DYNAMIC_AIR_CAL_STATE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::analogic::ancp00::DYNAMIC_AIR_CAL_STATE>() {
  return ::analogic::ancp00::DYNAMIC_AIR_CAL_STATE_descriptor();
}
template <> struct is_proto_enum< ::analogic::ancp00::DYNAMIC_OFFSET_CAL_STATE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::analogic::ancp00::DYNAMIC_OFFSET_CAL_STATE>() {
  return ::analogic::ancp00::DYNAMIC_OFFSET_CAL_STATE_descriptor();
}
template <> struct is_proto_enum< ::analogic::ancp00::BHS_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::analogic::ancp00::BHS_TYPE>() {
  return ::analogic::ancp00::BHS_TYPE_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_proto_2fScannerControl_2eproto__INCLUDED
