// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/PowerlinkComm.proto

#ifndef PROTOBUF_proto_2fPowerlinkComm_2eproto__INCLUDED
#define PROTOBUF_proto_2fPowerlinkComm_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace analogic {
namespace ancp00 {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_proto_2fPowerlinkComm_2eproto();
void protobuf_AssignDesc_proto_2fPowerlinkComm_2eproto();
void protobuf_ShutdownFile_proto_2fPowerlinkComm_2eproto();

class PowerlinkData;

enum PowerlinkData_STATUS_BITS {
  PowerlinkData_STATUS_BITS_NOT_USED_0 = 0,
  PowerlinkData_STATUS_BITS_GAP_FAULT = 1,
  PowerlinkData_STATUS_BITS_INVERTER_OVERCURRENT_FAULT = 2,
  PowerlinkData_STATUS_BITS_STATOR_CABLE_FAULT = 4,
  PowerlinkData_STATUS_BITS_FAN_FAULT = 8,
  PowerlinkData_STATUS_BITS_MASTER_FAULT = 128,
  PowerlinkData_STATUS_BITS_UNDERVOLTAGE_FAULT = 256,
  PowerlinkData_STATUS_BITS_OVERCURRENT_FAULT = 512,
  PowerlinkData_STATUS_BITS_POWER_ENABLED = 2048,
  PowerlinkData_STATUS_BITS_VBUSIN_UNDERVOLTAGE_FAULT = 134217728,
  PowerlinkData_STATUS_BITS_VCC_UNDERVOLTAGE_FAULT = 268435456,
  PowerlinkData_STATUS_BITS_SOFT_START_HEATSINK_TEMP_ALERT_70C = 536870912,
  PowerlinkData_STATUS_BITS_POWER_MOSFET_TEMP_ALERT_70C = 1073741824,
  PowerlinkData_STATUS_BITS_PowerlinkData_STATUS_BITS_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  PowerlinkData_STATUS_BITS_PowerlinkData_STATUS_BITS_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool PowerlinkData_STATUS_BITS_IsValid(int value);
const PowerlinkData_STATUS_BITS PowerlinkData_STATUS_BITS_STATUS_BITS_MIN = PowerlinkData_STATUS_BITS_NOT_USED_0;
const PowerlinkData_STATUS_BITS PowerlinkData_STATUS_BITS_STATUS_BITS_MAX = PowerlinkData_STATUS_BITS_POWER_MOSFET_TEMP_ALERT_70C;
const int PowerlinkData_STATUS_BITS_STATUS_BITS_ARRAYSIZE = PowerlinkData_STATUS_BITS_STATUS_BITS_MAX + 1;

const ::google::protobuf::EnumDescriptor* PowerlinkData_STATUS_BITS_descriptor();
inline const ::std::string& PowerlinkData_STATUS_BITS_Name(PowerlinkData_STATUS_BITS value) {
  return ::google::protobuf::internal::NameOfEnum(
    PowerlinkData_STATUS_BITS_descriptor(), value);
}
inline bool PowerlinkData_STATUS_BITS_Parse(
    const ::std::string& name, PowerlinkData_STATUS_BITS* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PowerlinkData_STATUS_BITS>(
    PowerlinkData_STATUS_BITS_descriptor(), name, value);
}
// ===================================================================

class PowerlinkData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:analogic.ancp00.PowerlinkData) */ {
 public:
  PowerlinkData();
  virtual ~PowerlinkData();

  PowerlinkData(const PowerlinkData& from);

  inline PowerlinkData& operator=(const PowerlinkData& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PowerlinkData& default_instance();

  void Swap(PowerlinkData* other);

  // implements Message ----------------------------------------------

  inline PowerlinkData* New() const { return New(NULL); }

  PowerlinkData* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PowerlinkData& from);
  void MergeFrom(const PowerlinkData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PowerlinkData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef PowerlinkData_STATUS_BITS STATUS_BITS;
  static const STATUS_BITS NOT_USED_0 =
    PowerlinkData_STATUS_BITS_NOT_USED_0;
  static const STATUS_BITS GAP_FAULT =
    PowerlinkData_STATUS_BITS_GAP_FAULT;
  static const STATUS_BITS INVERTER_OVERCURRENT_FAULT =
    PowerlinkData_STATUS_BITS_INVERTER_OVERCURRENT_FAULT;
  static const STATUS_BITS STATOR_CABLE_FAULT =
    PowerlinkData_STATUS_BITS_STATOR_CABLE_FAULT;
  static const STATUS_BITS FAN_FAULT =
    PowerlinkData_STATUS_BITS_FAN_FAULT;
  static const STATUS_BITS MASTER_FAULT =
    PowerlinkData_STATUS_BITS_MASTER_FAULT;
  static const STATUS_BITS UNDERVOLTAGE_FAULT =
    PowerlinkData_STATUS_BITS_UNDERVOLTAGE_FAULT;
  static const STATUS_BITS OVERCURRENT_FAULT =
    PowerlinkData_STATUS_BITS_OVERCURRENT_FAULT;
  static const STATUS_BITS POWER_ENABLED =
    PowerlinkData_STATUS_BITS_POWER_ENABLED;
  static const STATUS_BITS VBUSIN_UNDERVOLTAGE_FAULT =
    PowerlinkData_STATUS_BITS_VBUSIN_UNDERVOLTAGE_FAULT;
  static const STATUS_BITS VCC_UNDERVOLTAGE_FAULT =
    PowerlinkData_STATUS_BITS_VCC_UNDERVOLTAGE_FAULT;
  static const STATUS_BITS SOFT_START_HEATSINK_TEMP_ALERT_70C =
    PowerlinkData_STATUS_BITS_SOFT_START_HEATSINK_TEMP_ALERT_70C;
  static const STATUS_BITS POWER_MOSFET_TEMP_ALERT_70C =
    PowerlinkData_STATUS_BITS_POWER_MOSFET_TEMP_ALERT_70C;
  static inline bool STATUS_BITS_IsValid(int value) {
    return PowerlinkData_STATUS_BITS_IsValid(value);
  }
  static const STATUS_BITS STATUS_BITS_MIN =
    PowerlinkData_STATUS_BITS_STATUS_BITS_MIN;
  static const STATUS_BITS STATUS_BITS_MAX =
    PowerlinkData_STATUS_BITS_STATUS_BITS_MAX;
  static const int STATUS_BITS_ARRAYSIZE =
    PowerlinkData_STATUS_BITS_STATUS_BITS_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  STATUS_BITS_descriptor() {
    return PowerlinkData_STATUS_BITS_descriptor();
  }
  static inline const ::std::string& STATUS_BITS_Name(STATUS_BITS value) {
    return PowerlinkData_STATUS_BITS_Name(value);
  }
  static inline bool STATUS_BITS_Parse(const ::std::string& name,
      STATUS_BITS* value) {
    return PowerlinkData_STATUS_BITS_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional fixed32 status_bits = 1;
  void clear_status_bits();
  static const int kStatusBitsFieldNumber = 1;
  ::google::protobuf::uint32 status_bits() const;
  void set_status_bits(::google::protobuf::uint32 value);

  // optional string version = 2;
  void clear_version();
  static const int kVersionFieldNumber = 2;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // optional string revision = 3;
  void clear_revision();
  static const int kRevisionFieldNumber = 3;
  const ::std::string& revision() const;
  void set_revision(const ::std::string& value);
  void set_revision(const char* value);
  void set_revision(const char* value, size_t size);
  ::std::string* mutable_revision();
  ::std::string* release_revision();
  void set_allocated_revision(::std::string* revision);

  // optional bool gap_fault = 10;
  void clear_gap_fault();
  static const int kGapFaultFieldNumber = 10;
  bool gap_fault() const;
  void set_gap_fault(bool value);

  // optional bool inverter_overcurrent_fault = 11;
  void clear_inverter_overcurrent_fault();
  static const int kInverterOvercurrentFaultFieldNumber = 11;
  bool inverter_overcurrent_fault() const;
  void set_inverter_overcurrent_fault(bool value);

  // optional bool stator_cable_fault = 12;
  void clear_stator_cable_fault();
  static const int kStatorCableFaultFieldNumber = 12;
  bool stator_cable_fault() const;
  void set_stator_cable_fault(bool value);

  // optional bool fan_fault = 13;
  void clear_fan_fault();
  static const int kFanFaultFieldNumber = 13;
  bool fan_fault() const;
  void set_fan_fault(bool value);

  // optional bool master_fault = 14;
  void clear_master_fault();
  static const int kMasterFaultFieldNumber = 14;
  bool master_fault() const;
  void set_master_fault(bool value);

  // optional bool undervoltage_fault = 15;
  void clear_undervoltage_fault();
  static const int kUndervoltageFaultFieldNumber = 15;
  bool undervoltage_fault() const;
  void set_undervoltage_fault(bool value);

  // optional bool overcurrent_fault = 16;
  void clear_overcurrent_fault();
  static const int kOvercurrentFaultFieldNumber = 16;
  bool overcurrent_fault() const;
  void set_overcurrent_fault(bool value);

  // optional bool power_enabled = 17;
  void clear_power_enabled();
  static const int kPowerEnabledFieldNumber = 17;
  bool power_enabled() const;
  void set_power_enabled(bool value);

  // optional bool vbusin_undervoltage_fault = 18;
  void clear_vbusin_undervoltage_fault();
  static const int kVbusinUndervoltageFaultFieldNumber = 18;
  bool vbusin_undervoltage_fault() const;
  void set_vbusin_undervoltage_fault(bool value);

  // optional bool vcc_undervoltage_fault = 19;
  void clear_vcc_undervoltage_fault();
  static const int kVccUndervoltageFaultFieldNumber = 19;
  bool vcc_undervoltage_fault() const;
  void set_vcc_undervoltage_fault(bool value);

  // optional bool soft_start_heatsink_temp_alert = 20;
  void clear_soft_start_heatsink_temp_alert();
  static const int kSoftStartHeatsinkTempAlertFieldNumber = 20;
  bool soft_start_heatsink_temp_alert() const;
  void set_soft_start_heatsink_temp_alert(bool value);

  // optional bool power_mosfet_temp_alert = 21;
  void clear_power_mosfet_temp_alert();
  static const int kPowerMosfetTempAlertFieldNumber = 21;
  bool power_mosfet_temp_alert() const;
  void set_power_mosfet_temp_alert(bool value);

  // optional bool pfc_heatsink_temp_alert = 22;
  void clear_pfc_heatsink_temp_alert();
  static const int kPfcHeatsinkTempAlertFieldNumber = 22;
  bool pfc_heatsink_temp_alert() const;
  void set_pfc_heatsink_temp_alert(bool value);

  // @@protoc_insertion_point(class_scope:analogic.ancp00.PowerlinkData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::internal::ArenaStringPtr revision_;
  ::google::protobuf::uint32 status_bits_;
  bool gap_fault_;
  bool inverter_overcurrent_fault_;
  bool stator_cable_fault_;
  bool fan_fault_;
  bool master_fault_;
  bool undervoltage_fault_;
  bool overcurrent_fault_;
  bool power_enabled_;
  bool vbusin_undervoltage_fault_;
  bool vcc_undervoltage_fault_;
  bool soft_start_heatsink_temp_alert_;
  bool power_mosfet_temp_alert_;
  bool pfc_heatsink_temp_alert_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_proto_2fPowerlinkComm_2eproto();
  friend void protobuf_AssignDesc_proto_2fPowerlinkComm_2eproto();
  friend void protobuf_ShutdownFile_proto_2fPowerlinkComm_2eproto();

  void InitAsDefaultInstance();
  static PowerlinkData* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// PowerlinkData

// optional fixed32 status_bits = 1;
inline void PowerlinkData::clear_status_bits() {
  status_bits_ = 0u;
}
inline ::google::protobuf::uint32 PowerlinkData::status_bits() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.PowerlinkData.status_bits)
  return status_bits_;
}
inline void PowerlinkData::set_status_bits(::google::protobuf::uint32 value) {
  
  status_bits_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.PowerlinkData.status_bits)
}

// optional string version = 2;
inline void PowerlinkData::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PowerlinkData::version() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.PowerlinkData.version)
  return version_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PowerlinkData::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:analogic.ancp00.PowerlinkData.version)
}
inline void PowerlinkData::set_version(const char* value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:analogic.ancp00.PowerlinkData.version)
}
inline void PowerlinkData::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:analogic.ancp00.PowerlinkData.version)
}
inline ::std::string* PowerlinkData::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:analogic.ancp00.PowerlinkData.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PowerlinkData::release_version() {
  // @@protoc_insertion_point(field_release:analogic.ancp00.PowerlinkData.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PowerlinkData::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:analogic.ancp00.PowerlinkData.version)
}

// optional string revision = 3;
inline void PowerlinkData::clear_revision() {
  revision_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PowerlinkData::revision() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.PowerlinkData.revision)
  return revision_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PowerlinkData::set_revision(const ::std::string& value) {
  
  revision_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:analogic.ancp00.PowerlinkData.revision)
}
inline void PowerlinkData::set_revision(const char* value) {
  
  revision_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:analogic.ancp00.PowerlinkData.revision)
}
inline void PowerlinkData::set_revision(const char* value, size_t size) {
  
  revision_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:analogic.ancp00.PowerlinkData.revision)
}
inline ::std::string* PowerlinkData::mutable_revision() {
  
  // @@protoc_insertion_point(field_mutable:analogic.ancp00.PowerlinkData.revision)
  return revision_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PowerlinkData::release_revision() {
  // @@protoc_insertion_point(field_release:analogic.ancp00.PowerlinkData.revision)
  
  return revision_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PowerlinkData::set_allocated_revision(::std::string* revision) {
  if (revision != NULL) {
    
  } else {
    
  }
  revision_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), revision);
  // @@protoc_insertion_point(field_set_allocated:analogic.ancp00.PowerlinkData.revision)
}

// optional bool gap_fault = 10;
inline void PowerlinkData::clear_gap_fault() {
  gap_fault_ = false;
}
inline bool PowerlinkData::gap_fault() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.PowerlinkData.gap_fault)
  return gap_fault_;
}
inline void PowerlinkData::set_gap_fault(bool value) {
  
  gap_fault_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.PowerlinkData.gap_fault)
}

// optional bool inverter_overcurrent_fault = 11;
inline void PowerlinkData::clear_inverter_overcurrent_fault() {
  inverter_overcurrent_fault_ = false;
}
inline bool PowerlinkData::inverter_overcurrent_fault() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.PowerlinkData.inverter_overcurrent_fault)
  return inverter_overcurrent_fault_;
}
inline void PowerlinkData::set_inverter_overcurrent_fault(bool value) {
  
  inverter_overcurrent_fault_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.PowerlinkData.inverter_overcurrent_fault)
}

// optional bool stator_cable_fault = 12;
inline void PowerlinkData::clear_stator_cable_fault() {
  stator_cable_fault_ = false;
}
inline bool PowerlinkData::stator_cable_fault() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.PowerlinkData.stator_cable_fault)
  return stator_cable_fault_;
}
inline void PowerlinkData::set_stator_cable_fault(bool value) {
  
  stator_cable_fault_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.PowerlinkData.stator_cable_fault)
}

// optional bool fan_fault = 13;
inline void PowerlinkData::clear_fan_fault() {
  fan_fault_ = false;
}
inline bool PowerlinkData::fan_fault() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.PowerlinkData.fan_fault)
  return fan_fault_;
}
inline void PowerlinkData::set_fan_fault(bool value) {
  
  fan_fault_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.PowerlinkData.fan_fault)
}

// optional bool master_fault = 14;
inline void PowerlinkData::clear_master_fault() {
  master_fault_ = false;
}
inline bool PowerlinkData::master_fault() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.PowerlinkData.master_fault)
  return master_fault_;
}
inline void PowerlinkData::set_master_fault(bool value) {
  
  master_fault_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.PowerlinkData.master_fault)
}

// optional bool undervoltage_fault = 15;
inline void PowerlinkData::clear_undervoltage_fault() {
  undervoltage_fault_ = false;
}
inline bool PowerlinkData::undervoltage_fault() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.PowerlinkData.undervoltage_fault)
  return undervoltage_fault_;
}
inline void PowerlinkData::set_undervoltage_fault(bool value) {
  
  undervoltage_fault_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.PowerlinkData.undervoltage_fault)
}

// optional bool overcurrent_fault = 16;
inline void PowerlinkData::clear_overcurrent_fault() {
  overcurrent_fault_ = false;
}
inline bool PowerlinkData::overcurrent_fault() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.PowerlinkData.overcurrent_fault)
  return overcurrent_fault_;
}
inline void PowerlinkData::set_overcurrent_fault(bool value) {
  
  overcurrent_fault_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.PowerlinkData.overcurrent_fault)
}

// optional bool power_enabled = 17;
inline void PowerlinkData::clear_power_enabled() {
  power_enabled_ = false;
}
inline bool PowerlinkData::power_enabled() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.PowerlinkData.power_enabled)
  return power_enabled_;
}
inline void PowerlinkData::set_power_enabled(bool value) {
  
  power_enabled_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.PowerlinkData.power_enabled)
}

// optional bool vbusin_undervoltage_fault = 18;
inline void PowerlinkData::clear_vbusin_undervoltage_fault() {
  vbusin_undervoltage_fault_ = false;
}
inline bool PowerlinkData::vbusin_undervoltage_fault() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.PowerlinkData.vbusin_undervoltage_fault)
  return vbusin_undervoltage_fault_;
}
inline void PowerlinkData::set_vbusin_undervoltage_fault(bool value) {
  
  vbusin_undervoltage_fault_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.PowerlinkData.vbusin_undervoltage_fault)
}

// optional bool vcc_undervoltage_fault = 19;
inline void PowerlinkData::clear_vcc_undervoltage_fault() {
  vcc_undervoltage_fault_ = false;
}
inline bool PowerlinkData::vcc_undervoltage_fault() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.PowerlinkData.vcc_undervoltage_fault)
  return vcc_undervoltage_fault_;
}
inline void PowerlinkData::set_vcc_undervoltage_fault(bool value) {
  
  vcc_undervoltage_fault_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.PowerlinkData.vcc_undervoltage_fault)
}

// optional bool soft_start_heatsink_temp_alert = 20;
inline void PowerlinkData::clear_soft_start_heatsink_temp_alert() {
  soft_start_heatsink_temp_alert_ = false;
}
inline bool PowerlinkData::soft_start_heatsink_temp_alert() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.PowerlinkData.soft_start_heatsink_temp_alert)
  return soft_start_heatsink_temp_alert_;
}
inline void PowerlinkData::set_soft_start_heatsink_temp_alert(bool value) {
  
  soft_start_heatsink_temp_alert_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.PowerlinkData.soft_start_heatsink_temp_alert)
}

// optional bool power_mosfet_temp_alert = 21;
inline void PowerlinkData::clear_power_mosfet_temp_alert() {
  power_mosfet_temp_alert_ = false;
}
inline bool PowerlinkData::power_mosfet_temp_alert() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.PowerlinkData.power_mosfet_temp_alert)
  return power_mosfet_temp_alert_;
}
inline void PowerlinkData::set_power_mosfet_temp_alert(bool value) {
  
  power_mosfet_temp_alert_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.PowerlinkData.power_mosfet_temp_alert)
}

// optional bool pfc_heatsink_temp_alert = 22;
inline void PowerlinkData::clear_pfc_heatsink_temp_alert() {
  pfc_heatsink_temp_alert_ = false;
}
inline bool PowerlinkData::pfc_heatsink_temp_alert() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.PowerlinkData.pfc_heatsink_temp_alert)
  return pfc_heatsink_temp_alert_;
}
inline void PowerlinkData::set_pfc_heatsink_temp_alert(bool value) {
  
  pfc_heatsink_temp_alert_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.PowerlinkData.pfc_heatsink_temp_alert)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace ancp00
}  // namespace analogic

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::analogic::ancp00::PowerlinkData_STATUS_BITS> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::analogic::ancp00::PowerlinkData_STATUS_BITS>() {
  return ::analogic::ancp00::PowerlinkData_STATUS_BITS_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_proto_2fPowerlinkComm_2eproto__INCLUDED
