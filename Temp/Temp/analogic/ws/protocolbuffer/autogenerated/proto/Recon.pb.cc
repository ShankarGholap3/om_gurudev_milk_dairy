// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/Recon.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "proto/Recon.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace analogic {
namespace ancp00 {

namespace {

const ::google::protobuf::Descriptor* ReconCmdMsg_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ReconCmdMsg_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* ReconCmdMsg_ReconCommand_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* ReconCmdMsg_ParamType_descriptor_ = NULL;
const ::google::protobuf::Descriptor* ReconStatusMsg_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ReconStatusMsg_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* ReconStatusMsg_StatusType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* ReconStatusMsg_Status_descriptor_ = NULL;
const ::google::protobuf::Descriptor* ReconEnum_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ReconEnum_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* ReconEnum_CalReturnCode_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_proto_2fRecon_2eproto() GOOGLE_ATTRIBUTE_COLD;
void protobuf_AssignDesc_proto_2fRecon_2eproto() {
  protobuf_AddDesc_proto_2fRecon_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "proto/Recon.proto");
  GOOGLE_CHECK(file != NULL);
  ReconCmdMsg_descriptor_ = file->message_type(0);
  static const int ReconCmdMsg_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReconCmdMsg, cmd_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReconCmdMsg, param_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReconCmdMsg, param_value_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReconCmdMsg, bypass_cal_checks_),
  };
  ReconCmdMsg_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ReconCmdMsg_descriptor_,
      ReconCmdMsg::default_instance_,
      ReconCmdMsg_offsets_,
      -1,
      -1,
      -1,
      sizeof(ReconCmdMsg),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReconCmdMsg, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReconCmdMsg, _is_default_instance_));
  ReconCmdMsg_ReconCommand_descriptor_ = ReconCmdMsg_descriptor_->enum_type(0);
  ReconCmdMsg_ParamType_descriptor_ = ReconCmdMsg_descriptor_->enum_type(1);
  ReconStatusMsg_descriptor_ = file->message_type(1);
  static const int ReconStatusMsg_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReconStatusMsg, status_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReconStatusMsg, status_),
  };
  ReconStatusMsg_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ReconStatusMsg_descriptor_,
      ReconStatusMsg::default_instance_,
      ReconStatusMsg_offsets_,
      -1,
      -1,
      -1,
      sizeof(ReconStatusMsg),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReconStatusMsg, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReconStatusMsg, _is_default_instance_));
  ReconStatusMsg_StatusType_descriptor_ = ReconStatusMsg_descriptor_->enum_type(0);
  ReconStatusMsg_Status_descriptor_ = ReconStatusMsg_descriptor_->enum_type(1);
  ReconEnum_descriptor_ = file->message_type(2);
  static const int ReconEnum_offsets_[1] = {
  };
  ReconEnum_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ReconEnum_descriptor_,
      ReconEnum::default_instance_,
      ReconEnum_offsets_,
      -1,
      -1,
      -1,
      sizeof(ReconEnum),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReconEnum, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReconEnum, _is_default_instance_));
  ReconEnum_CalReturnCode_descriptor_ = ReconEnum_descriptor_->enum_type(0);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_proto_2fRecon_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) GOOGLE_ATTRIBUTE_COLD;
void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ReconCmdMsg_descriptor_, &ReconCmdMsg::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ReconStatusMsg_descriptor_, &ReconStatusMsg::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ReconEnum_descriptor_, &ReconEnum::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_proto_2fRecon_2eproto() {
  delete ReconCmdMsg::default_instance_;
  delete ReconCmdMsg_reflection_;
  delete ReconStatusMsg::default_instance_;
  delete ReconStatusMsg_reflection_;
  delete ReconEnum::default_instance_;
  delete ReconEnum_reflection_;
}

void protobuf_AddDesc_proto_2fRecon_2eproto() GOOGLE_ATTRIBUTE_COLD;
void protobuf_AddDesc_proto_2fRecon_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\021proto/Recon.proto\022\017analogic.ancp00\"\343\003\n"
    "\013ReconCmdMsg\0229\n\006cmd_id\030\001 \001(\0162).analogic."
    "ancp00.ReconCmdMsg.ReconCommand\022:\n\nparam"
    "_type\030\002 \001(\0162&.analogic.ancp00.ReconCmdMs"
    "g.ParamType\022\023\n\013param_value\030\003 \001(\002\022\031\n\021bypa"
    "ss_cal_checks\030\004 \001(\010\"\323\001\n\014ReconCommand\022\026\n\022"
    "OFFSET_AND_AIR_CAL\020\000\022\016\n\nOFFSET_CAL\020\001\022\013\n\007"
    "AIR_CAL\020\002\022\017\n\013START_RECON\020\003\022\016\n\nSTOP_RECON"
    "\020\004\022\032\n\026UPDATE_MANUAL_BAD_DETS\020\005\022\020\n\014UPDATE"
    "_PARAM\020\006\022\026\n\022REINITIALIZE_RECON\020\007\022\016\n\nEXIT"
    "_RECON\020\010\022\027\n\023AIR_DATA_VALIDATION\020\t\"W\n\tPar"
    "amType\022\010\n\004NONE\020\000\022\017\n\013NYLON_SCALE\020\001\022\017\n\013BEL"
    "T_HEIGHT\020\002\022\016\n\nCENTER_DET\020\003\022\016\n\nNONLIN_TAB"
    "\020\004\"\267\002\n\016ReconStatusMsg\022\?\n\013status_type\030\001 \001"
    "(\0162*.analogic.ancp00.ReconStatusMsg.Stat"
    "usType\0226\n\006status\030\002 \001(\0162&.analogic.ancp00"
    ".ReconStatusMsg.Status\">\n\nStatusType\022\016\n\n"
    "OFFSET_CAL\020\000\022\013\n\007AIR_CAL\020\001\022\023\n\017MANUAL_BAD_"
    "DETS\020\002\"l\n\006Status\022\013\n\007SUCCESS\020\000\022\010\n\004FAIL\020\001\022"
    "\r\n\tNOT_READY\020\002\022\022\n\016ZIPPER_IN_BEAM\020\003\022\022\n\016AI"
    "R_DATA_VALID\020\004\022\024\n\020AIR_DATA_INVALID\020\005\"\323\003\n"
    "\tReconEnum\"\305\003\n\rCalReturnCode\022\013\n\007SUCCESS\020"
    "\000\022\026\n\022TOO_MANY_BAD_VIEWS\020\001\022\024\n\020WRONG_INPUT"
    "_SIZE\020\002\022\032\n\026EXTRACT_RAW_DATA_ERROR\020\003\022\'\n#T"
    "OO_MANY_INTERIOR_ADJACENT_BAD_DETS\020\004\022#\n\037"
    "TOO_MANY_EDGE_ADJACENT_BAD_DETS\020\005\022\032\n\026TOO"
    "_MANY_BAD_DETS_MAIN\020\006\022\035\n\031TOO_MANY_BAD_DE"
    "T_PAIRS_DE\020\007\022\024\n\020WHOLE_MODULE_BAD\020\010\022\036\n\032AI"
    "R_CONSISTENCY_CHECK_FAIL\020\t\022\"\n\036BAD_DET_CO"
    "NSISTENCY_CHECK_FAIL\020\n\022\025\n\021ZIPPER_CHECK_F"
    "AIL\020\013\022\031\n\025NO_PREVIOUS_CAL_TABLE\020\014\022(\n$AIR_"
    "CONSISTENCY_OR_ZIPPER_CHECK_FAIL\020\r\022\036\n\032TR"
    "IGGER_POS_NOT_ZERO_START\020\016b\006proto3", 1314);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "proto/Recon.proto", &protobuf_RegisterTypes);
  ReconCmdMsg::default_instance_ = new ReconCmdMsg();
  ReconStatusMsg::default_instance_ = new ReconStatusMsg();
  ReconEnum::default_instance_ = new ReconEnum();
  ReconCmdMsg::default_instance_->InitAsDefaultInstance();
  ReconStatusMsg::default_instance_->InitAsDefaultInstance();
  ReconEnum::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_proto_2fRecon_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_proto_2fRecon_2eproto {
  StaticDescriptorInitializer_proto_2fRecon_2eproto() {
    protobuf_AddDesc_proto_2fRecon_2eproto();
  }
} static_descriptor_initializer_proto_2fRecon_2eproto_;

// ===================================================================

const ::google::protobuf::EnumDescriptor* ReconCmdMsg_ReconCommand_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ReconCmdMsg_ReconCommand_descriptor_;
}
bool ReconCmdMsg_ReconCommand_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const ReconCmdMsg_ReconCommand ReconCmdMsg::OFFSET_AND_AIR_CAL;
const ReconCmdMsg_ReconCommand ReconCmdMsg::OFFSET_CAL;
const ReconCmdMsg_ReconCommand ReconCmdMsg::AIR_CAL;
const ReconCmdMsg_ReconCommand ReconCmdMsg::START_RECON;
const ReconCmdMsg_ReconCommand ReconCmdMsg::STOP_RECON;
const ReconCmdMsg_ReconCommand ReconCmdMsg::UPDATE_MANUAL_BAD_DETS;
const ReconCmdMsg_ReconCommand ReconCmdMsg::UPDATE_PARAM;
const ReconCmdMsg_ReconCommand ReconCmdMsg::REINITIALIZE_RECON;
const ReconCmdMsg_ReconCommand ReconCmdMsg::EXIT_RECON;
const ReconCmdMsg_ReconCommand ReconCmdMsg::AIR_DATA_VALIDATION;
const ReconCmdMsg_ReconCommand ReconCmdMsg::ReconCommand_MIN;
const ReconCmdMsg_ReconCommand ReconCmdMsg::ReconCommand_MAX;
const int ReconCmdMsg::ReconCommand_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
const ::google::protobuf::EnumDescriptor* ReconCmdMsg_ParamType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ReconCmdMsg_ParamType_descriptor_;
}
bool ReconCmdMsg_ParamType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const ReconCmdMsg_ParamType ReconCmdMsg::NONE;
const ReconCmdMsg_ParamType ReconCmdMsg::NYLON_SCALE;
const ReconCmdMsg_ParamType ReconCmdMsg::BELT_HEIGHT;
const ReconCmdMsg_ParamType ReconCmdMsg::CENTER_DET;
const ReconCmdMsg_ParamType ReconCmdMsg::NONLIN_TAB;
const ReconCmdMsg_ParamType ReconCmdMsg::ParamType_MIN;
const ReconCmdMsg_ParamType ReconCmdMsg::ParamType_MAX;
const int ReconCmdMsg::ParamType_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ReconCmdMsg::kCmdIdFieldNumber;
const int ReconCmdMsg::kParamTypeFieldNumber;
const int ReconCmdMsg::kParamValueFieldNumber;
const int ReconCmdMsg::kBypassCalChecksFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ReconCmdMsg::ReconCmdMsg()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:analogic.ancp00.ReconCmdMsg)
}

void ReconCmdMsg::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

ReconCmdMsg::ReconCmdMsg(const ReconCmdMsg& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:analogic.ancp00.ReconCmdMsg)
}

void ReconCmdMsg::SharedCtor() {
    _is_default_instance_ = false;
  _cached_size_ = 0;
  cmd_id_ = 0;
  param_type_ = 0;
  param_value_ = 0;
  bypass_cal_checks_ = false;
}

ReconCmdMsg::~ReconCmdMsg() {
  // @@protoc_insertion_point(destructor:analogic.ancp00.ReconCmdMsg)
  SharedDtor();
}

void ReconCmdMsg::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ReconCmdMsg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ReconCmdMsg::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ReconCmdMsg_descriptor_;
}

const ReconCmdMsg& ReconCmdMsg::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_proto_2fRecon_2eproto();
  return *default_instance_;
}

ReconCmdMsg* ReconCmdMsg::default_instance_ = NULL;

ReconCmdMsg* ReconCmdMsg::New(::google::protobuf::Arena* arena) const {
  ReconCmdMsg* n = new ReconCmdMsg;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ReconCmdMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:analogic.ancp00.ReconCmdMsg)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(ReconCmdMsg, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<ReconCmdMsg*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(cmd_id_, bypass_cal_checks_);

#undef ZR_HELPER_
#undef ZR_

}

bool ReconCmdMsg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:analogic.ancp00.ReconCmdMsg)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .analogic.ancp00.ReconCmdMsg.ReconCommand cmd_id = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_cmd_id(static_cast< ::analogic::ancp00::ReconCmdMsg_ReconCommand >(value));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_param_type;
        break;
      }

      // optional .analogic.ancp00.ReconCmdMsg.ParamType param_type = 2;
      case 2: {
        if (tag == 16) {
         parse_param_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_param_type(static_cast< ::analogic::ancp00::ReconCmdMsg_ParamType >(value));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(29)) goto parse_param_value;
        break;
      }

      // optional float param_value = 3;
      case 3: {
        if (tag == 29) {
         parse_param_value:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &param_value_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_bypass_cal_checks;
        break;
      }

      // optional bool bypass_cal_checks = 4;
      case 4: {
        if (tag == 32) {
         parse_bypass_cal_checks:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &bypass_cal_checks_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:analogic.ancp00.ReconCmdMsg)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:analogic.ancp00.ReconCmdMsg)
  return false;
#undef DO_
}

void ReconCmdMsg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:analogic.ancp00.ReconCmdMsg)
  // optional .analogic.ancp00.ReconCmdMsg.ReconCommand cmd_id = 1;
  if (this->cmd_id() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->cmd_id(), output);
  }

  // optional .analogic.ancp00.ReconCmdMsg.ParamType param_type = 2;
  if (this->param_type() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->param_type(), output);
  }

  // optional float param_value = 3;
  if (this->param_value() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->param_value(), output);
  }

  // optional bool bypass_cal_checks = 4;
  if (this->bypass_cal_checks() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->bypass_cal_checks(), output);
  }

  // @@protoc_insertion_point(serialize_end:analogic.ancp00.ReconCmdMsg)
}

::google::protobuf::uint8* ReconCmdMsg::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:analogic.ancp00.ReconCmdMsg)
  // optional .analogic.ancp00.ReconCmdMsg.ReconCommand cmd_id = 1;
  if (this->cmd_id() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->cmd_id(), target);
  }

  // optional .analogic.ancp00.ReconCmdMsg.ParamType param_type = 2;
  if (this->param_type() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->param_type(), target);
  }

  // optional float param_value = 3;
  if (this->param_value() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->param_value(), target);
  }

  // optional bool bypass_cal_checks = 4;
  if (this->bypass_cal_checks() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->bypass_cal_checks(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:analogic.ancp00.ReconCmdMsg)
  return target;
}

int ReconCmdMsg::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:analogic.ancp00.ReconCmdMsg)
  int total_size = 0;

  // optional .analogic.ancp00.ReconCmdMsg.ReconCommand cmd_id = 1;
  if (this->cmd_id() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->cmd_id());
  }

  // optional .analogic.ancp00.ReconCmdMsg.ParamType param_type = 2;
  if (this->param_type() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->param_type());
  }

  // optional float param_value = 3;
  if (this->param_value() != 0) {
    total_size += 1 + 4;
  }

  // optional bool bypass_cal_checks = 4;
  if (this->bypass_cal_checks() != 0) {
    total_size += 1 + 1;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReconCmdMsg::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:analogic.ancp00.ReconCmdMsg)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const ReconCmdMsg* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ReconCmdMsg>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:analogic.ancp00.ReconCmdMsg)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:analogic.ancp00.ReconCmdMsg)
    MergeFrom(*source);
  }
}

void ReconCmdMsg::MergeFrom(const ReconCmdMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:analogic.ancp00.ReconCmdMsg)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from.cmd_id() != 0) {
    set_cmd_id(from.cmd_id());
  }
  if (from.param_type() != 0) {
    set_param_type(from.param_type());
  }
  if (from.param_value() != 0) {
    set_param_value(from.param_value());
  }
  if (from.bypass_cal_checks() != 0) {
    set_bypass_cal_checks(from.bypass_cal_checks());
  }
}

void ReconCmdMsg::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:analogic.ancp00.ReconCmdMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ReconCmdMsg::CopyFrom(const ReconCmdMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:analogic.ancp00.ReconCmdMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReconCmdMsg::IsInitialized() const {

  return true;
}

void ReconCmdMsg::Swap(ReconCmdMsg* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ReconCmdMsg::InternalSwap(ReconCmdMsg* other) {
  std::swap(cmd_id_, other->cmd_id_);
  std::swap(param_type_, other->param_type_);
  std::swap(param_value_, other->param_value_);
  std::swap(bypass_cal_checks_, other->bypass_cal_checks_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ReconCmdMsg::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ReconCmdMsg_descriptor_;
  metadata.reflection = ReconCmdMsg_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ReconCmdMsg

// optional .analogic.ancp00.ReconCmdMsg.ReconCommand cmd_id = 1;
void ReconCmdMsg::clear_cmd_id() {
  cmd_id_ = 0;
}
 ::analogic::ancp00::ReconCmdMsg_ReconCommand ReconCmdMsg::cmd_id() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.ReconCmdMsg.cmd_id)
  return static_cast< ::analogic::ancp00::ReconCmdMsg_ReconCommand >(cmd_id_);
}
 void ReconCmdMsg::set_cmd_id(::analogic::ancp00::ReconCmdMsg_ReconCommand value) {
  
  cmd_id_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.ReconCmdMsg.cmd_id)
}

// optional .analogic.ancp00.ReconCmdMsg.ParamType param_type = 2;
void ReconCmdMsg::clear_param_type() {
  param_type_ = 0;
}
 ::analogic::ancp00::ReconCmdMsg_ParamType ReconCmdMsg::param_type() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.ReconCmdMsg.param_type)
  return static_cast< ::analogic::ancp00::ReconCmdMsg_ParamType >(param_type_);
}
 void ReconCmdMsg::set_param_type(::analogic::ancp00::ReconCmdMsg_ParamType value) {
  
  param_type_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.ReconCmdMsg.param_type)
}

// optional float param_value = 3;
void ReconCmdMsg::clear_param_value() {
  param_value_ = 0;
}
 float ReconCmdMsg::param_value() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.ReconCmdMsg.param_value)
  return param_value_;
}
 void ReconCmdMsg::set_param_value(float value) {
  
  param_value_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.ReconCmdMsg.param_value)
}

// optional bool bypass_cal_checks = 4;
void ReconCmdMsg::clear_bypass_cal_checks() {
  bypass_cal_checks_ = false;
}
 bool ReconCmdMsg::bypass_cal_checks() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.ReconCmdMsg.bypass_cal_checks)
  return bypass_cal_checks_;
}
 void ReconCmdMsg::set_bypass_cal_checks(bool value) {
  
  bypass_cal_checks_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.ReconCmdMsg.bypass_cal_checks)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

const ::google::protobuf::EnumDescriptor* ReconStatusMsg_StatusType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ReconStatusMsg_StatusType_descriptor_;
}
bool ReconStatusMsg_StatusType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const ReconStatusMsg_StatusType ReconStatusMsg::OFFSET_CAL;
const ReconStatusMsg_StatusType ReconStatusMsg::AIR_CAL;
const ReconStatusMsg_StatusType ReconStatusMsg::MANUAL_BAD_DETS;
const ReconStatusMsg_StatusType ReconStatusMsg::StatusType_MIN;
const ReconStatusMsg_StatusType ReconStatusMsg::StatusType_MAX;
const int ReconStatusMsg::StatusType_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
const ::google::protobuf::EnumDescriptor* ReconStatusMsg_Status_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ReconStatusMsg_Status_descriptor_;
}
bool ReconStatusMsg_Status_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const ReconStatusMsg_Status ReconStatusMsg::SUCCESS;
const ReconStatusMsg_Status ReconStatusMsg::FAIL;
const ReconStatusMsg_Status ReconStatusMsg::NOT_READY;
const ReconStatusMsg_Status ReconStatusMsg::ZIPPER_IN_BEAM;
const ReconStatusMsg_Status ReconStatusMsg::AIR_DATA_VALID;
const ReconStatusMsg_Status ReconStatusMsg::AIR_DATA_INVALID;
const ReconStatusMsg_Status ReconStatusMsg::Status_MIN;
const ReconStatusMsg_Status ReconStatusMsg::Status_MAX;
const int ReconStatusMsg::Status_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ReconStatusMsg::kStatusTypeFieldNumber;
const int ReconStatusMsg::kStatusFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ReconStatusMsg::ReconStatusMsg()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:analogic.ancp00.ReconStatusMsg)
}

void ReconStatusMsg::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

ReconStatusMsg::ReconStatusMsg(const ReconStatusMsg& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:analogic.ancp00.ReconStatusMsg)
}

void ReconStatusMsg::SharedCtor() {
    _is_default_instance_ = false;
  _cached_size_ = 0;
  status_type_ = 0;
  status_ = 0;
}

ReconStatusMsg::~ReconStatusMsg() {
  // @@protoc_insertion_point(destructor:analogic.ancp00.ReconStatusMsg)
  SharedDtor();
}

void ReconStatusMsg::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ReconStatusMsg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ReconStatusMsg::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ReconStatusMsg_descriptor_;
}

const ReconStatusMsg& ReconStatusMsg::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_proto_2fRecon_2eproto();
  return *default_instance_;
}

ReconStatusMsg* ReconStatusMsg::default_instance_ = NULL;

ReconStatusMsg* ReconStatusMsg::New(::google::protobuf::Arena* arena) const {
  ReconStatusMsg* n = new ReconStatusMsg;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ReconStatusMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:analogic.ancp00.ReconStatusMsg)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(ReconStatusMsg, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<ReconStatusMsg*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(status_type_, status_);

#undef ZR_HELPER_
#undef ZR_

}

bool ReconStatusMsg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:analogic.ancp00.ReconStatusMsg)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .analogic.ancp00.ReconStatusMsg.StatusType status_type = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_status_type(static_cast< ::analogic::ancp00::ReconStatusMsg_StatusType >(value));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_status;
        break;
      }

      // optional .analogic.ancp00.ReconStatusMsg.Status status = 2;
      case 2: {
        if (tag == 16) {
         parse_status:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_status(static_cast< ::analogic::ancp00::ReconStatusMsg_Status >(value));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:analogic.ancp00.ReconStatusMsg)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:analogic.ancp00.ReconStatusMsg)
  return false;
#undef DO_
}

void ReconStatusMsg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:analogic.ancp00.ReconStatusMsg)
  // optional .analogic.ancp00.ReconStatusMsg.StatusType status_type = 1;
  if (this->status_type() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->status_type(), output);
  }

  // optional .analogic.ancp00.ReconStatusMsg.Status status = 2;
  if (this->status() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->status(), output);
  }

  // @@protoc_insertion_point(serialize_end:analogic.ancp00.ReconStatusMsg)
}

::google::protobuf::uint8* ReconStatusMsg::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:analogic.ancp00.ReconStatusMsg)
  // optional .analogic.ancp00.ReconStatusMsg.StatusType status_type = 1;
  if (this->status_type() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->status_type(), target);
  }

  // optional .analogic.ancp00.ReconStatusMsg.Status status = 2;
  if (this->status() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->status(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:analogic.ancp00.ReconStatusMsg)
  return target;
}

int ReconStatusMsg::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:analogic.ancp00.ReconStatusMsg)
  int total_size = 0;

  // optional .analogic.ancp00.ReconStatusMsg.StatusType status_type = 1;
  if (this->status_type() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->status_type());
  }

  // optional .analogic.ancp00.ReconStatusMsg.Status status = 2;
  if (this->status() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->status());
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReconStatusMsg::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:analogic.ancp00.ReconStatusMsg)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const ReconStatusMsg* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ReconStatusMsg>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:analogic.ancp00.ReconStatusMsg)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:analogic.ancp00.ReconStatusMsg)
    MergeFrom(*source);
  }
}

void ReconStatusMsg::MergeFrom(const ReconStatusMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:analogic.ancp00.ReconStatusMsg)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from.status_type() != 0) {
    set_status_type(from.status_type());
  }
  if (from.status() != 0) {
    set_status(from.status());
  }
}

void ReconStatusMsg::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:analogic.ancp00.ReconStatusMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ReconStatusMsg::CopyFrom(const ReconStatusMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:analogic.ancp00.ReconStatusMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReconStatusMsg::IsInitialized() const {

  return true;
}

void ReconStatusMsg::Swap(ReconStatusMsg* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ReconStatusMsg::InternalSwap(ReconStatusMsg* other) {
  std::swap(status_type_, other->status_type_);
  std::swap(status_, other->status_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ReconStatusMsg::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ReconStatusMsg_descriptor_;
  metadata.reflection = ReconStatusMsg_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ReconStatusMsg

// optional .analogic.ancp00.ReconStatusMsg.StatusType status_type = 1;
void ReconStatusMsg::clear_status_type() {
  status_type_ = 0;
}
 ::analogic::ancp00::ReconStatusMsg_StatusType ReconStatusMsg::status_type() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.ReconStatusMsg.status_type)
  return static_cast< ::analogic::ancp00::ReconStatusMsg_StatusType >(status_type_);
}
 void ReconStatusMsg::set_status_type(::analogic::ancp00::ReconStatusMsg_StatusType value) {
  
  status_type_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.ReconStatusMsg.status_type)
}

// optional .analogic.ancp00.ReconStatusMsg.Status status = 2;
void ReconStatusMsg::clear_status() {
  status_ = 0;
}
 ::analogic::ancp00::ReconStatusMsg_Status ReconStatusMsg::status() const {
  // @@protoc_insertion_point(field_get:analogic.ancp00.ReconStatusMsg.status)
  return static_cast< ::analogic::ancp00::ReconStatusMsg_Status >(status_);
}
 void ReconStatusMsg::set_status(::analogic::ancp00::ReconStatusMsg_Status value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:analogic.ancp00.ReconStatusMsg.status)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

const ::google::protobuf::EnumDescriptor* ReconEnum_CalReturnCode_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ReconEnum_CalReturnCode_descriptor_;
}
bool ReconEnum_CalReturnCode_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const ReconEnum_CalReturnCode ReconEnum::SUCCESS;
const ReconEnum_CalReturnCode ReconEnum::TOO_MANY_BAD_VIEWS;
const ReconEnum_CalReturnCode ReconEnum::WRONG_INPUT_SIZE;
const ReconEnum_CalReturnCode ReconEnum::EXTRACT_RAW_DATA_ERROR;
const ReconEnum_CalReturnCode ReconEnum::TOO_MANY_INTERIOR_ADJACENT_BAD_DETS;
const ReconEnum_CalReturnCode ReconEnum::TOO_MANY_EDGE_ADJACENT_BAD_DETS;
const ReconEnum_CalReturnCode ReconEnum::TOO_MANY_BAD_DETS_MAIN;
const ReconEnum_CalReturnCode ReconEnum::TOO_MANY_BAD_DET_PAIRS_DE;
const ReconEnum_CalReturnCode ReconEnum::WHOLE_MODULE_BAD;
const ReconEnum_CalReturnCode ReconEnum::AIR_CONSISTENCY_CHECK_FAIL;
const ReconEnum_CalReturnCode ReconEnum::BAD_DET_CONSISTENCY_CHECK_FAIL;
const ReconEnum_CalReturnCode ReconEnum::ZIPPER_CHECK_FAIL;
const ReconEnum_CalReturnCode ReconEnum::NO_PREVIOUS_CAL_TABLE;
const ReconEnum_CalReturnCode ReconEnum::AIR_CONSISTENCY_OR_ZIPPER_CHECK_FAIL;
const ReconEnum_CalReturnCode ReconEnum::TRIGGER_POS_NOT_ZERO_START;
const ReconEnum_CalReturnCode ReconEnum::CalReturnCode_MIN;
const ReconEnum_CalReturnCode ReconEnum::CalReturnCode_MAX;
const int ReconEnum::CalReturnCode_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ReconEnum::ReconEnum()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:analogic.ancp00.ReconEnum)
}

void ReconEnum::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

ReconEnum::ReconEnum(const ReconEnum& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:analogic.ancp00.ReconEnum)
}

void ReconEnum::SharedCtor() {
    _is_default_instance_ = false;
  _cached_size_ = 0;
}

ReconEnum::~ReconEnum() {
  // @@protoc_insertion_point(destructor:analogic.ancp00.ReconEnum)
  SharedDtor();
}

void ReconEnum::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ReconEnum::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ReconEnum::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ReconEnum_descriptor_;
}

const ReconEnum& ReconEnum::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_proto_2fRecon_2eproto();
  return *default_instance_;
}

ReconEnum* ReconEnum::default_instance_ = NULL;

ReconEnum* ReconEnum::New(::google::protobuf::Arena* arena) const {
  ReconEnum* n = new ReconEnum;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ReconEnum::Clear() {
// @@protoc_insertion_point(message_clear_start:analogic.ancp00.ReconEnum)
}

bool ReconEnum::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:analogic.ancp00.ReconEnum)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
  }
success:
  // @@protoc_insertion_point(parse_success:analogic.ancp00.ReconEnum)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:analogic.ancp00.ReconEnum)
  return false;
#undef DO_
}

void ReconEnum::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:analogic.ancp00.ReconEnum)
  // @@protoc_insertion_point(serialize_end:analogic.ancp00.ReconEnum)
}

::google::protobuf::uint8* ReconEnum::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:analogic.ancp00.ReconEnum)
  // @@protoc_insertion_point(serialize_to_array_end:analogic.ancp00.ReconEnum)
  return target;
}

int ReconEnum::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:analogic.ancp00.ReconEnum)
  int total_size = 0;

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReconEnum::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:analogic.ancp00.ReconEnum)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const ReconEnum* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ReconEnum>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:analogic.ancp00.ReconEnum)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:analogic.ancp00.ReconEnum)
    MergeFrom(*source);
  }
}

void ReconEnum::MergeFrom(const ReconEnum& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:analogic.ancp00.ReconEnum)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
}

void ReconEnum::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:analogic.ancp00.ReconEnum)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ReconEnum::CopyFrom(const ReconEnum& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:analogic.ancp00.ReconEnum)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReconEnum::IsInitialized() const {

  return true;
}

void ReconEnum::Swap(ReconEnum* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ReconEnum::InternalSwap(ReconEnum* other) {
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ReconEnum::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ReconEnum_descriptor_;
  metadata.reflection = ReconEnum_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ReconEnum

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace ancp00
}  // namespace analogic

// @@protoc_insertion_point(global_scope)
