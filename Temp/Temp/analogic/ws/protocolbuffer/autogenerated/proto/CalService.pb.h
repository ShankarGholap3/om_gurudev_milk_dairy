// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/CalService.proto

#ifndef PROTOBUF_proto_2fCalService_2eproto__INCLUDED
#define PROTOBUF_proto_2fCalService_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "proto/ScannerControl.pb.h"
// @@protoc_insertion_point(includes)

namespace analogic {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_proto_2fCalService_2eproto();
void protobuf_AssignDesc_proto_2fCalService_2eproto();
void protobuf_ShutdownFile_proto_2fCalService_2eproto();

class AirCalRpc;
class AirCalibrationRpc;
class AlarmLibInfo;
class BeltTunnelCalRpc;
class CalibrationRpc;
class ExportCalParamDataRpc;
class ExportFilesRpc;
class GetBadDetectorManualFileRpc;
class GetBadDetectorMapFilesRpc;
class GetErrorLogFileRpc;
class GetImageCalibrationFilesRpc;
class GetImageQualityMassValuesRpc;
class GetInstallableAlarmLibsReply;
class GetInstallableAlarmLibsRpc;
class GetInstalledAlarmLibsReply;
class GetInstalledAlarmLibsRpc;
class GetScannerConfigFileRpc;
class ImageQualityTestRpc;
class ImportCalParamDataRpc;
class InstallAlarmLibRpc;
class InstalledAlarmLibInfo;
class OffsetCalRpc;
class OffsetCalibrationRpc;
class RadSurveyRpcCancel;
class RadiationSurveyRpc;
class RawDataCollectRpc;
class RpcReply;
class RunImageCalibrationRpc;
class SdswStatus;
class UpdateBadDetectorManualFileRpc;
class UpdateImageCalibrationBeltFreqRpc;
class UpdateImageCalibrationBeltHeightRpc;
class UpdateImageCalibrationNylonScaleRpc;
class UpdateScannerConfigFileRpc;
class XrayControlRpc;

enum RpcReply_RPC_REPLY {
  RpcReply_RPC_REPLY_COMPLETE = 0,
  RpcReply_RPC_REPLY_BUSY = 1,
  RpcReply_RPC_REPLY_TIMEOUT = 2,
  RpcReply_RPC_REPLY_ERROR = 3,
  RpcReply_RPC_REPLY_READY = 4,
  RpcReply_RPC_REPLY_RpcReply_RPC_REPLY_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  RpcReply_RPC_REPLY_RpcReply_RPC_REPLY_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool RpcReply_RPC_REPLY_IsValid(int value);
const RpcReply_RPC_REPLY RpcReply_RPC_REPLY_RPC_REPLY_MIN = RpcReply_RPC_REPLY_COMPLETE;
const RpcReply_RPC_REPLY RpcReply_RPC_REPLY_RPC_REPLY_MAX = RpcReply_RPC_REPLY_READY;
const int RpcReply_RPC_REPLY_RPC_REPLY_ARRAYSIZE = RpcReply_RPC_REPLY_RPC_REPLY_MAX + 1;

const ::google::protobuf::EnumDescriptor* RpcReply_RPC_REPLY_descriptor();
inline const ::std::string& RpcReply_RPC_REPLY_Name(RpcReply_RPC_REPLY value) {
  return ::google::protobuf::internal::NameOfEnum(
    RpcReply_RPC_REPLY_descriptor(), value);
}
inline bool RpcReply_RPC_REPLY_Parse(
    const ::std::string& name, RpcReply_RPC_REPLY* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RpcReply_RPC_REPLY>(
    RpcReply_RPC_REPLY_descriptor(), name, value);
}
enum RpcReply_RPC_ERROR_CODE {
  RpcReply_RPC_ERROR_CODE_COMMAND_FAILURE = 0,
  RpcReply_RPC_ERROR_CODE_FILE_NOT_FOUND = 1,
  RpcReply_RPC_ERROR_CODE_FILE_NOT_CREATED = 2,
  RpcReply_RPC_ERROR_CODE_RpcReply_RPC_ERROR_CODE_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  RpcReply_RPC_ERROR_CODE_RpcReply_RPC_ERROR_CODE_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool RpcReply_RPC_ERROR_CODE_IsValid(int value);
const RpcReply_RPC_ERROR_CODE RpcReply_RPC_ERROR_CODE_RPC_ERROR_CODE_MIN = RpcReply_RPC_ERROR_CODE_COMMAND_FAILURE;
const RpcReply_RPC_ERROR_CODE RpcReply_RPC_ERROR_CODE_RPC_ERROR_CODE_MAX = RpcReply_RPC_ERROR_CODE_FILE_NOT_CREATED;
const int RpcReply_RPC_ERROR_CODE_RPC_ERROR_CODE_ARRAYSIZE = RpcReply_RPC_ERROR_CODE_RPC_ERROR_CODE_MAX + 1;

const ::google::protobuf::EnumDescriptor* RpcReply_RPC_ERROR_CODE_descriptor();
inline const ::std::string& RpcReply_RPC_ERROR_CODE_Name(RpcReply_RPC_ERROR_CODE value) {
  return ::google::protobuf::internal::NameOfEnum(
    RpcReply_RPC_ERROR_CODE_descriptor(), value);
}
inline bool RpcReply_RPC_ERROR_CODE_Parse(
    const ::std::string& name, RpcReply_RPC_ERROR_CODE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RpcReply_RPC_ERROR_CODE>(
    RpcReply_RPC_ERROR_CODE_descriptor(), name, value);
}
enum XrayControlRpc_XRAY_STATE {
  XrayControlRpc_XRAY_STATE_XRAY_OFF = 0,
  XrayControlRpc_XRAY_STATE_XRAY_ON = 1,
  XrayControlRpc_XRAY_STATE_XRAY_MINIMIZED = 2,
  XrayControlRpc_XRAY_STATE_XrayControlRpc_XRAY_STATE_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  XrayControlRpc_XRAY_STATE_XrayControlRpc_XRAY_STATE_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool XrayControlRpc_XRAY_STATE_IsValid(int value);
const XrayControlRpc_XRAY_STATE XrayControlRpc_XRAY_STATE_XRAY_STATE_MIN = XrayControlRpc_XRAY_STATE_XRAY_OFF;
const XrayControlRpc_XRAY_STATE XrayControlRpc_XRAY_STATE_XRAY_STATE_MAX = XrayControlRpc_XRAY_STATE_XRAY_MINIMIZED;
const int XrayControlRpc_XRAY_STATE_XRAY_STATE_ARRAYSIZE = XrayControlRpc_XRAY_STATE_XRAY_STATE_MAX + 1;

const ::google::protobuf::EnumDescriptor* XrayControlRpc_XRAY_STATE_descriptor();
inline const ::std::string& XrayControlRpc_XRAY_STATE_Name(XrayControlRpc_XRAY_STATE value) {
  return ::google::protobuf::internal::NameOfEnum(
    XrayControlRpc_XRAY_STATE_descriptor(), value);
}
inline bool XrayControlRpc_XRAY_STATE_Parse(
    const ::std::string& name, XrayControlRpc_XRAY_STATE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<XrayControlRpc_XRAY_STATE>(
    XrayControlRpc_XRAY_STATE_descriptor(), name, value);
}
enum ImageQualityTestRpc_IQ_TEST_TYPE {
  ImageQualityTestRpc_IQ_TEST_TYPE_IQ_NONE = 0,
  ImageQualityTestRpc_IQ_TEST_TYPE_IQT_ANALOGIC = 1,
  ImageQualityTestRpc_IQ_TEST_TYPE_IQT_NIST_A = 2,
  ImageQualityTestRpc_IQ_TEST_TYPE_IQT_NIST_B = 3,
  ImageQualityTestRpc_IQ_TEST_TYPE_ImageQualityTestRpc_IQ_TEST_TYPE_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ImageQualityTestRpc_IQ_TEST_TYPE_ImageQualityTestRpc_IQ_TEST_TYPE_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ImageQualityTestRpc_IQ_TEST_TYPE_IsValid(int value);
const ImageQualityTestRpc_IQ_TEST_TYPE ImageQualityTestRpc_IQ_TEST_TYPE_IQ_TEST_TYPE_MIN = ImageQualityTestRpc_IQ_TEST_TYPE_IQ_NONE;
const ImageQualityTestRpc_IQ_TEST_TYPE ImageQualityTestRpc_IQ_TEST_TYPE_IQ_TEST_TYPE_MAX = ImageQualityTestRpc_IQ_TEST_TYPE_IQT_NIST_B;
const int ImageQualityTestRpc_IQ_TEST_TYPE_IQ_TEST_TYPE_ARRAYSIZE = ImageQualityTestRpc_IQ_TEST_TYPE_IQ_TEST_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* ImageQualityTestRpc_IQ_TEST_TYPE_descriptor();
inline const ::std::string& ImageQualityTestRpc_IQ_TEST_TYPE_Name(ImageQualityTestRpc_IQ_TEST_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    ImageQualityTestRpc_IQ_TEST_TYPE_descriptor(), value);
}
inline bool ImageQualityTestRpc_IQ_TEST_TYPE_Parse(
    const ::std::string& name, ImageQualityTestRpc_IQ_TEST_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ImageQualityTestRpc_IQ_TEST_TYPE>(
    ImageQualityTestRpc_IQ_TEST_TYPE_descriptor(), name, value);
}
enum SdswStatus_AIR_CAL_STATE {
  SdswStatus_AIR_CAL_STATE_AIR_CAL_IDLE = 0,
  SdswStatus_AIR_CAL_STATE_SdswStatus_AIR_CAL_STATE_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SdswStatus_AIR_CAL_STATE_SdswStatus_AIR_CAL_STATE_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SdswStatus_AIR_CAL_STATE_IsValid(int value);
const SdswStatus_AIR_CAL_STATE SdswStatus_AIR_CAL_STATE_AIR_CAL_STATE_MIN = SdswStatus_AIR_CAL_STATE_AIR_CAL_IDLE;
const SdswStatus_AIR_CAL_STATE SdswStatus_AIR_CAL_STATE_AIR_CAL_STATE_MAX = SdswStatus_AIR_CAL_STATE_AIR_CAL_IDLE;
const int SdswStatus_AIR_CAL_STATE_AIR_CAL_STATE_ARRAYSIZE = SdswStatus_AIR_CAL_STATE_AIR_CAL_STATE_MAX + 1;

const ::google::protobuf::EnumDescriptor* SdswStatus_AIR_CAL_STATE_descriptor();
inline const ::std::string& SdswStatus_AIR_CAL_STATE_Name(SdswStatus_AIR_CAL_STATE value) {
  return ::google::protobuf::internal::NameOfEnum(
    SdswStatus_AIR_CAL_STATE_descriptor(), value);
}
inline bool SdswStatus_AIR_CAL_STATE_Parse(
    const ::std::string& name, SdswStatus_AIR_CAL_STATE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SdswStatus_AIR_CAL_STATE>(
    SdswStatus_AIR_CAL_STATE_descriptor(), name, value);
}
enum SdswStatus_OFFSET_CAL_STATE {
  SdswStatus_OFFSET_CAL_STATE_OFFSET_CAL_IDLE = 0,
  SdswStatus_OFFSET_CAL_STATE_SdswStatus_OFFSET_CAL_STATE_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SdswStatus_OFFSET_CAL_STATE_SdswStatus_OFFSET_CAL_STATE_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SdswStatus_OFFSET_CAL_STATE_IsValid(int value);
const SdswStatus_OFFSET_CAL_STATE SdswStatus_OFFSET_CAL_STATE_OFFSET_CAL_STATE_MIN = SdswStatus_OFFSET_CAL_STATE_OFFSET_CAL_IDLE;
const SdswStatus_OFFSET_CAL_STATE SdswStatus_OFFSET_CAL_STATE_OFFSET_CAL_STATE_MAX = SdswStatus_OFFSET_CAL_STATE_OFFSET_CAL_IDLE;
const int SdswStatus_OFFSET_CAL_STATE_OFFSET_CAL_STATE_ARRAYSIZE = SdswStatus_OFFSET_CAL_STATE_OFFSET_CAL_STATE_MAX + 1;

const ::google::protobuf::EnumDescriptor* SdswStatus_OFFSET_CAL_STATE_descriptor();
inline const ::std::string& SdswStatus_OFFSET_CAL_STATE_Name(SdswStatus_OFFSET_CAL_STATE value) {
  return ::google::protobuf::internal::NameOfEnum(
    SdswStatus_OFFSET_CAL_STATE_descriptor(), value);
}
inline bool SdswStatus_OFFSET_CAL_STATE_Parse(
    const ::std::string& name, SdswStatus_OFFSET_CAL_STATE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SdswStatus_OFFSET_CAL_STATE>(
    SdswStatus_OFFSET_CAL_STATE_descriptor(), name, value);
}
enum SdswStatus_PIN_CAL_STATE {
  SdswStatus_PIN_CAL_STATE_PIN_CAL_IDLE = 0,
  SdswStatus_PIN_CAL_STATE_SdswStatus_PIN_CAL_STATE_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SdswStatus_PIN_CAL_STATE_SdswStatus_PIN_CAL_STATE_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SdswStatus_PIN_CAL_STATE_IsValid(int value);
const SdswStatus_PIN_CAL_STATE SdswStatus_PIN_CAL_STATE_PIN_CAL_STATE_MIN = SdswStatus_PIN_CAL_STATE_PIN_CAL_IDLE;
const SdswStatus_PIN_CAL_STATE SdswStatus_PIN_CAL_STATE_PIN_CAL_STATE_MAX = SdswStatus_PIN_CAL_STATE_PIN_CAL_IDLE;
const int SdswStatus_PIN_CAL_STATE_PIN_CAL_STATE_ARRAYSIZE = SdswStatus_PIN_CAL_STATE_PIN_CAL_STATE_MAX + 1;

const ::google::protobuf::EnumDescriptor* SdswStatus_PIN_CAL_STATE_descriptor();
inline const ::std::string& SdswStatus_PIN_CAL_STATE_Name(SdswStatus_PIN_CAL_STATE value) {
  return ::google::protobuf::internal::NameOfEnum(
    SdswStatus_PIN_CAL_STATE_descriptor(), value);
}
inline bool SdswStatus_PIN_CAL_STATE_Parse(
    const ::std::string& name, SdswStatus_PIN_CAL_STATE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SdswStatus_PIN_CAL_STATE>(
    SdswStatus_PIN_CAL_STATE_descriptor(), name, value);
}
enum SdswStatus_BELT_HEIGHT_CAL_STATE {
  SdswStatus_BELT_HEIGHT_CAL_STATE_BELT_HEIGHT_IDLE = 0,
  SdswStatus_BELT_HEIGHT_CAL_STATE_SdswStatus_BELT_HEIGHT_CAL_STATE_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SdswStatus_BELT_HEIGHT_CAL_STATE_SdswStatus_BELT_HEIGHT_CAL_STATE_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SdswStatus_BELT_HEIGHT_CAL_STATE_IsValid(int value);
const SdswStatus_BELT_HEIGHT_CAL_STATE SdswStatus_BELT_HEIGHT_CAL_STATE_BELT_HEIGHT_CAL_STATE_MIN = SdswStatus_BELT_HEIGHT_CAL_STATE_BELT_HEIGHT_IDLE;
const SdswStatus_BELT_HEIGHT_CAL_STATE SdswStatus_BELT_HEIGHT_CAL_STATE_BELT_HEIGHT_CAL_STATE_MAX = SdswStatus_BELT_HEIGHT_CAL_STATE_BELT_HEIGHT_IDLE;
const int SdswStatus_BELT_HEIGHT_CAL_STATE_BELT_HEIGHT_CAL_STATE_ARRAYSIZE = SdswStatus_BELT_HEIGHT_CAL_STATE_BELT_HEIGHT_CAL_STATE_MAX + 1;

const ::google::protobuf::EnumDescriptor* SdswStatus_BELT_HEIGHT_CAL_STATE_descriptor();
inline const ::std::string& SdswStatus_BELT_HEIGHT_CAL_STATE_Name(SdswStatus_BELT_HEIGHT_CAL_STATE value) {
  return ::google::protobuf::internal::NameOfEnum(
    SdswStatus_BELT_HEIGHT_CAL_STATE_descriptor(), value);
}
inline bool SdswStatus_BELT_HEIGHT_CAL_STATE_Parse(
    const ::std::string& name, SdswStatus_BELT_HEIGHT_CAL_STATE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SdswStatus_BELT_HEIGHT_CAL_STATE>(
    SdswStatus_BELT_HEIGHT_CAL_STATE_descriptor(), name, value);
}
enum SdswStatus_SPECTRAL_CAL_STATE {
  SdswStatus_SPECTRAL_CAL_STATE_SPECTRAL_CAL_IDLE = 0,
  SdswStatus_SPECTRAL_CAL_STATE_SdswStatus_SPECTRAL_CAL_STATE_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SdswStatus_SPECTRAL_CAL_STATE_SdswStatus_SPECTRAL_CAL_STATE_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SdswStatus_SPECTRAL_CAL_STATE_IsValid(int value);
const SdswStatus_SPECTRAL_CAL_STATE SdswStatus_SPECTRAL_CAL_STATE_SPECTRAL_CAL_STATE_MIN = SdswStatus_SPECTRAL_CAL_STATE_SPECTRAL_CAL_IDLE;
const SdswStatus_SPECTRAL_CAL_STATE SdswStatus_SPECTRAL_CAL_STATE_SPECTRAL_CAL_STATE_MAX = SdswStatus_SPECTRAL_CAL_STATE_SPECTRAL_CAL_IDLE;
const int SdswStatus_SPECTRAL_CAL_STATE_SPECTRAL_CAL_STATE_ARRAYSIZE = SdswStatus_SPECTRAL_CAL_STATE_SPECTRAL_CAL_STATE_MAX + 1;

const ::google::protobuf::EnumDescriptor* SdswStatus_SPECTRAL_CAL_STATE_descriptor();
inline const ::std::string& SdswStatus_SPECTRAL_CAL_STATE_Name(SdswStatus_SPECTRAL_CAL_STATE value) {
  return ::google::protobuf::internal::NameOfEnum(
    SdswStatus_SPECTRAL_CAL_STATE_descriptor(), value);
}
inline bool SdswStatus_SPECTRAL_CAL_STATE_Parse(
    const ::std::string& name, SdswStatus_SPECTRAL_CAL_STATE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SdswStatus_SPECTRAL_CAL_STATE>(
    SdswStatus_SPECTRAL_CAL_STATE_descriptor(), name, value);
}
enum SdswStatus_RADIATION_SURVEY_STATE {
  SdswStatus_RADIATION_SURVEY_STATE_RADIATION_SURVEY_IDLE = 0,
  SdswStatus_RADIATION_SURVEY_STATE_RADIATION_SURVEY_GO_TO_SCAN = 1,
  SdswStatus_RADIATION_SURVEY_STATE_RADIATION_SURVEY_WAITING_FOR_BAG_TO_BE_PLACED = 2,
  SdswStatus_RADIATION_SURVEY_STATE_RADIATION_SURVEY_WAITING_FOR_BAG_IN_POSITION = 3,
  SdswStatus_RADIATION_SURVEY_STATE_RADIATION_SURVEY_READY = 4,
  SdswStatus_RADIATION_SURVEY_STATE_RADIATION_SURVEY_ERROR = 5,
  SdswStatus_RADIATION_SURVEY_STATE_SdswStatus_RADIATION_SURVEY_STATE_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SdswStatus_RADIATION_SURVEY_STATE_SdswStatus_RADIATION_SURVEY_STATE_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SdswStatus_RADIATION_SURVEY_STATE_IsValid(int value);
const SdswStatus_RADIATION_SURVEY_STATE SdswStatus_RADIATION_SURVEY_STATE_RADIATION_SURVEY_STATE_MIN = SdswStatus_RADIATION_SURVEY_STATE_RADIATION_SURVEY_IDLE;
const SdswStatus_RADIATION_SURVEY_STATE SdswStatus_RADIATION_SURVEY_STATE_RADIATION_SURVEY_STATE_MAX = SdswStatus_RADIATION_SURVEY_STATE_RADIATION_SURVEY_ERROR;
const int SdswStatus_RADIATION_SURVEY_STATE_RADIATION_SURVEY_STATE_ARRAYSIZE = SdswStatus_RADIATION_SURVEY_STATE_RADIATION_SURVEY_STATE_MAX + 1;

const ::google::protobuf::EnumDescriptor* SdswStatus_RADIATION_SURVEY_STATE_descriptor();
inline const ::std::string& SdswStatus_RADIATION_SURVEY_STATE_Name(SdswStatus_RADIATION_SURVEY_STATE value) {
  return ::google::protobuf::internal::NameOfEnum(
    SdswStatus_RADIATION_SURVEY_STATE_descriptor(), value);
}
inline bool SdswStatus_RADIATION_SURVEY_STATE_Parse(
    const ::std::string& name, SdswStatus_RADIATION_SURVEY_STATE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SdswStatus_RADIATION_SURVEY_STATE>(
    SdswStatus_RADIATION_SURVEY_STATE_descriptor(), name, value);
}
enum SdswStatus_RADIATION_SURVEY_CANCEL_STATE {
  SdswStatus_RADIATION_SURVEY_CANCEL_STATE_RADIATION_SURVEY_CANCEL_IDLE = 0,
  SdswStatus_RADIATION_SURVEY_CANCEL_STATE_RADIATION_SURVEY_CANCEL_XRAY_OFF = 1,
  SdswStatus_RADIATION_SURVEY_CANCEL_STATE_RADIATION_SURVEY_CANCEL_CONVEYOR_RUN = 2,
  SdswStatus_RADIATION_SURVEY_CANCEL_STATE_RADIATION_SURVEY_CANCEL_COMPLETE = 3,
  SdswStatus_RADIATION_SURVEY_CANCEL_STATE_RADIATION_SURVEY_CANCEL_ERROR = 4,
  SdswStatus_RADIATION_SURVEY_CANCEL_STATE_SdswStatus_RADIATION_SURVEY_CANCEL_STATE_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SdswStatus_RADIATION_SURVEY_CANCEL_STATE_SdswStatus_RADIATION_SURVEY_CANCEL_STATE_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SdswStatus_RADIATION_SURVEY_CANCEL_STATE_IsValid(int value);
const SdswStatus_RADIATION_SURVEY_CANCEL_STATE SdswStatus_RADIATION_SURVEY_CANCEL_STATE_RADIATION_SURVEY_CANCEL_STATE_MIN = SdswStatus_RADIATION_SURVEY_CANCEL_STATE_RADIATION_SURVEY_CANCEL_IDLE;
const SdswStatus_RADIATION_SURVEY_CANCEL_STATE SdswStatus_RADIATION_SURVEY_CANCEL_STATE_RADIATION_SURVEY_CANCEL_STATE_MAX = SdswStatus_RADIATION_SURVEY_CANCEL_STATE_RADIATION_SURVEY_CANCEL_ERROR;
const int SdswStatus_RADIATION_SURVEY_CANCEL_STATE_RADIATION_SURVEY_CANCEL_STATE_ARRAYSIZE = SdswStatus_RADIATION_SURVEY_CANCEL_STATE_RADIATION_SURVEY_CANCEL_STATE_MAX + 1;

const ::google::protobuf::EnumDescriptor* SdswStatus_RADIATION_SURVEY_CANCEL_STATE_descriptor();
inline const ::std::string& SdswStatus_RADIATION_SURVEY_CANCEL_STATE_Name(SdswStatus_RADIATION_SURVEY_CANCEL_STATE value) {
  return ::google::protobuf::internal::NameOfEnum(
    SdswStatus_RADIATION_SURVEY_CANCEL_STATE_descriptor(), value);
}
inline bool SdswStatus_RADIATION_SURVEY_CANCEL_STATE_Parse(
    const ::std::string& name, SdswStatus_RADIATION_SURVEY_CANCEL_STATE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SdswStatus_RADIATION_SURVEY_CANCEL_STATE>(
    SdswStatus_RADIATION_SURVEY_CANCEL_STATE_descriptor(), name, value);
}
enum SdswStatus_IMAGE_QUALITY_STATE {
  SdswStatus_IMAGE_QUALITY_STATE_IMAGE_QUALITY_IDLE = 0,
  SdswStatus_IMAGE_QUALITY_STATE_IMAGE_QUALITY_GO_TO_SCAN = 1,
  SdswStatus_IMAGE_QUALITY_STATE_IMAGE_QUALITY_PROCESSING = 2,
  SdswStatus_IMAGE_QUALITY_STATE_IMAGE_QUALITY_PROCESSED = 3,
  SdswStatus_IMAGE_QUALITY_STATE_IMAGE_QUALITY_CONVEYOR_FLUSH = 4,
  SdswStatus_IMAGE_QUALITY_STATE_IMAGE_QUALITY_XRAYS_OFF = 5,
  SdswStatus_IMAGE_QUALITY_STATE_IMAGE_QUALITY_COMPLETE = 6,
  SdswStatus_IMAGE_QUALITY_STATE_IMAGE_QUALITY_ERROR = 7,
  SdswStatus_IMAGE_QUALITY_STATE_SdswStatus_IMAGE_QUALITY_STATE_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SdswStatus_IMAGE_QUALITY_STATE_SdswStatus_IMAGE_QUALITY_STATE_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SdswStatus_IMAGE_QUALITY_STATE_IsValid(int value);
const SdswStatus_IMAGE_QUALITY_STATE SdswStatus_IMAGE_QUALITY_STATE_IMAGE_QUALITY_STATE_MIN = SdswStatus_IMAGE_QUALITY_STATE_IMAGE_QUALITY_IDLE;
const SdswStatus_IMAGE_QUALITY_STATE SdswStatus_IMAGE_QUALITY_STATE_IMAGE_QUALITY_STATE_MAX = SdswStatus_IMAGE_QUALITY_STATE_IMAGE_QUALITY_ERROR;
const int SdswStatus_IMAGE_QUALITY_STATE_IMAGE_QUALITY_STATE_ARRAYSIZE = SdswStatus_IMAGE_QUALITY_STATE_IMAGE_QUALITY_STATE_MAX + 1;

const ::google::protobuf::EnumDescriptor* SdswStatus_IMAGE_QUALITY_STATE_descriptor();
inline const ::std::string& SdswStatus_IMAGE_QUALITY_STATE_Name(SdswStatus_IMAGE_QUALITY_STATE value) {
  return ::google::protobuf::internal::NameOfEnum(
    SdswStatus_IMAGE_QUALITY_STATE_descriptor(), value);
}
inline bool SdswStatus_IMAGE_QUALITY_STATE_Parse(
    const ::std::string& name, SdswStatus_IMAGE_QUALITY_STATE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SdswStatus_IMAGE_QUALITY_STATE>(
    SdswStatus_IMAGE_QUALITY_STATE_descriptor(), name, value);
}
enum SdswStatus_IMAGE_QUALITY_CANCEL_STATE {
  SdswStatus_IMAGE_QUALITY_CANCEL_STATE_IMAGE_QUALITY_CANCEL_XRAY_OFF = 0,
  SdswStatus_IMAGE_QUALITY_CANCEL_STATE_IMAGE_QUALITY_CANCEL_CONVEYOR_STOP = 1,
  SdswStatus_IMAGE_QUALITY_CANCEL_STATE_IMAGE_QUALITY_CANCEL_ERROR = 2,
  SdswStatus_IMAGE_QUALITY_CANCEL_STATE_SdswStatus_IMAGE_QUALITY_CANCEL_STATE_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SdswStatus_IMAGE_QUALITY_CANCEL_STATE_SdswStatus_IMAGE_QUALITY_CANCEL_STATE_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SdswStatus_IMAGE_QUALITY_CANCEL_STATE_IsValid(int value);
const SdswStatus_IMAGE_QUALITY_CANCEL_STATE SdswStatus_IMAGE_QUALITY_CANCEL_STATE_IMAGE_QUALITY_CANCEL_STATE_MIN = SdswStatus_IMAGE_QUALITY_CANCEL_STATE_IMAGE_QUALITY_CANCEL_XRAY_OFF;
const SdswStatus_IMAGE_QUALITY_CANCEL_STATE SdswStatus_IMAGE_QUALITY_CANCEL_STATE_IMAGE_QUALITY_CANCEL_STATE_MAX = SdswStatus_IMAGE_QUALITY_CANCEL_STATE_IMAGE_QUALITY_CANCEL_ERROR;
const int SdswStatus_IMAGE_QUALITY_CANCEL_STATE_IMAGE_QUALITY_CANCEL_STATE_ARRAYSIZE = SdswStatus_IMAGE_QUALITY_CANCEL_STATE_IMAGE_QUALITY_CANCEL_STATE_MAX + 1;

const ::google::protobuf::EnumDescriptor* SdswStatus_IMAGE_QUALITY_CANCEL_STATE_descriptor();
inline const ::std::string& SdswStatus_IMAGE_QUALITY_CANCEL_STATE_Name(SdswStatus_IMAGE_QUALITY_CANCEL_STATE value) {
  return ::google::protobuf::internal::NameOfEnum(
    SdswStatus_IMAGE_QUALITY_CANCEL_STATE_descriptor(), value);
}
inline bool SdswStatus_IMAGE_QUALITY_CANCEL_STATE_Parse(
    const ::std::string& name, SdswStatus_IMAGE_QUALITY_CANCEL_STATE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SdswStatus_IMAGE_QUALITY_CANCEL_STATE>(
    SdswStatus_IMAGE_QUALITY_CANCEL_STATE_descriptor(), name, value);
}
enum SdswStatus_BASE_SEQ_1_STATE {
  SdswStatus_BASE_SEQ_1_STATE_BASE_SEQ_1_IDLE = 0,
  SdswStatus_BASE_SEQ_1_STATE_BASE_SEQ_1_GANTRY_STARTUP = 1,
  SdswStatus_BASE_SEQ_1_STATE_BASE_SEQ_1_XRAY_STARTUP = 2,
  SdswStatus_BASE_SEQ_1_STATE_BASE_SEQ_1_CONVEYOR_CONTROL = 3,
  SdswStatus_BASE_SEQ_1_STATE_BASE_SEQ_1_PROCESSING = 4,
  SdswStatus_BASE_SEQ_1_STATE_BASE_SEQ_1_PROCESSED = 5,
  SdswStatus_BASE_SEQ_1_STATE_BASE_SEQ_1_ERROR = 6,
  SdswStatus_BASE_SEQ_1_STATE_SdswStatus_BASE_SEQ_1_STATE_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SdswStatus_BASE_SEQ_1_STATE_SdswStatus_BASE_SEQ_1_STATE_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SdswStatus_BASE_SEQ_1_STATE_IsValid(int value);
const SdswStatus_BASE_SEQ_1_STATE SdswStatus_BASE_SEQ_1_STATE_BASE_SEQ_1_STATE_MIN = SdswStatus_BASE_SEQ_1_STATE_BASE_SEQ_1_IDLE;
const SdswStatus_BASE_SEQ_1_STATE SdswStatus_BASE_SEQ_1_STATE_BASE_SEQ_1_STATE_MAX = SdswStatus_BASE_SEQ_1_STATE_BASE_SEQ_1_ERROR;
const int SdswStatus_BASE_SEQ_1_STATE_BASE_SEQ_1_STATE_ARRAYSIZE = SdswStatus_BASE_SEQ_1_STATE_BASE_SEQ_1_STATE_MAX + 1;

const ::google::protobuf::EnumDescriptor* SdswStatus_BASE_SEQ_1_STATE_descriptor();
inline const ::std::string& SdswStatus_BASE_SEQ_1_STATE_Name(SdswStatus_BASE_SEQ_1_STATE value) {
  return ::google::protobuf::internal::NameOfEnum(
    SdswStatus_BASE_SEQ_1_STATE_descriptor(), value);
}
inline bool SdswStatus_BASE_SEQ_1_STATE_Parse(
    const ::std::string& name, SdswStatus_BASE_SEQ_1_STATE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SdswStatus_BASE_SEQ_1_STATE>(
    SdswStatus_BASE_SEQ_1_STATE_descriptor(), name, value);
}
enum SdswStatus_ZEE_PIN_SPECTRAL_CAL_STATE {
  SdswStatus_ZEE_PIN_SPECTRAL_CAL_STATE_ZEE_PIN_SPECTRAL_CAL_CLEAR_ERROR = 0,
  SdswStatus_ZEE_PIN_SPECTRAL_CAL_STATE_ZEE_PIN_SPECTRAL_CAL_GANTRY_ON = 1,
  SdswStatus_ZEE_PIN_SPECTRAL_CAL_STATE_ZEE_PIN_SPECTRAL_CAL_CONVEYOR_STOP = 2,
  SdswStatus_ZEE_PIN_SPECTRAL_CAL_STATE_ZEE_PIN_SPECTRAL_CAL_XRAY_OFF_1 = 3,
  SdswStatus_ZEE_PIN_SPECTRAL_CAL_STATE_ZEE_PIN_SPECTRAL_CAL_RAW_DATA_COLLECT_1 = 4,
  SdswStatus_ZEE_PIN_SPECTRAL_CAL_STATE_ZEE_PIN_SPECTRAL_CAL_XRAY_ON_1 = 5,
  SdswStatus_ZEE_PIN_SPECTRAL_CAL_STATE_ZEE_PIN_SPECTRAL_CAL_RAW_DATA_COLLECT_2 = 6,
  SdswStatus_ZEE_PIN_SPECTRAL_CAL_STATE_ZEE_PIN_SPECTRAL_CAL_XRAY_OFF_2 = 7,
  SdswStatus_ZEE_PIN_SPECTRAL_CAL_STATE_ZEE_PIN_SPECTRAL_CAL_WAIT_FOR_PLACEMENT = 8,
  SdswStatus_ZEE_PIN_SPECTRAL_CAL_STATE_ZEE_PIN_SPECTRAL_CAL_XRAY_ON_2 = 9,
  SdswStatus_ZEE_PIN_SPECTRAL_CAL_STATE_ZEE_PIN_SPECTRAL_CAL_RAW_DATA_COLLECT_3 = 10,
  SdswStatus_ZEE_PIN_SPECTRAL_CAL_STATE_ZEE_PIN_SPECTRAL_CAL_ANALYZE = 11,
  SdswStatus_ZEE_PIN_SPECTRAL_CAL_STATE_ZEE_PIN_SPECTRAL_CAL_COMPLETE = 12,
  SdswStatus_ZEE_PIN_SPECTRAL_CAL_STATE_ZEE_PIN_SPECTRAL_CAL_ERROR = 13,
  SdswStatus_ZEE_PIN_SPECTRAL_CAL_STATE_SdswStatus_ZEE_PIN_SPECTRAL_CAL_STATE_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SdswStatus_ZEE_PIN_SPECTRAL_CAL_STATE_SdswStatus_ZEE_PIN_SPECTRAL_CAL_STATE_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SdswStatus_ZEE_PIN_SPECTRAL_CAL_STATE_IsValid(int value);
const SdswStatus_ZEE_PIN_SPECTRAL_CAL_STATE SdswStatus_ZEE_PIN_SPECTRAL_CAL_STATE_ZEE_PIN_SPECTRAL_CAL_STATE_MIN = SdswStatus_ZEE_PIN_SPECTRAL_CAL_STATE_ZEE_PIN_SPECTRAL_CAL_CLEAR_ERROR;
const SdswStatus_ZEE_PIN_SPECTRAL_CAL_STATE SdswStatus_ZEE_PIN_SPECTRAL_CAL_STATE_ZEE_PIN_SPECTRAL_CAL_STATE_MAX = SdswStatus_ZEE_PIN_SPECTRAL_CAL_STATE_ZEE_PIN_SPECTRAL_CAL_ERROR;
const int SdswStatus_ZEE_PIN_SPECTRAL_CAL_STATE_ZEE_PIN_SPECTRAL_CAL_STATE_ARRAYSIZE = SdswStatus_ZEE_PIN_SPECTRAL_CAL_STATE_ZEE_PIN_SPECTRAL_CAL_STATE_MAX + 1;

const ::google::protobuf::EnumDescriptor* SdswStatus_ZEE_PIN_SPECTRAL_CAL_STATE_descriptor();
inline const ::std::string& SdswStatus_ZEE_PIN_SPECTRAL_CAL_STATE_Name(SdswStatus_ZEE_PIN_SPECTRAL_CAL_STATE value) {
  return ::google::protobuf::internal::NameOfEnum(
    SdswStatus_ZEE_PIN_SPECTRAL_CAL_STATE_descriptor(), value);
}
inline bool SdswStatus_ZEE_PIN_SPECTRAL_CAL_STATE_Parse(
    const ::std::string& name, SdswStatus_ZEE_PIN_SPECTRAL_CAL_STATE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SdswStatus_ZEE_PIN_SPECTRAL_CAL_STATE>(
    SdswStatus_ZEE_PIN_SPECTRAL_CAL_STATE_descriptor(), name, value);
}
enum SdswStatus_CONV_STOP_XRAY_MIN_STATE {
  SdswStatus_CONV_STOP_XRAY_MIN_STATE_CONV_STOP_XRAY_MIN_CONVEYOR_STOP = 0,
  SdswStatus_CONV_STOP_XRAY_MIN_STATE_CONV_STOP_XRAY_MIN_XRAY_MINIMIZE = 1,
  SdswStatus_CONV_STOP_XRAY_MIN_STATE_CONV_STOP_XRAY_MIN_COMPLETE = 2,
  SdswStatus_CONV_STOP_XRAY_MIN_STATE_CONV_STOP_XRAY_MIN_ERROR = 3,
  SdswStatus_CONV_STOP_XRAY_MIN_STATE_SdswStatus_CONV_STOP_XRAY_MIN_STATE_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SdswStatus_CONV_STOP_XRAY_MIN_STATE_SdswStatus_CONV_STOP_XRAY_MIN_STATE_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SdswStatus_CONV_STOP_XRAY_MIN_STATE_IsValid(int value);
const SdswStatus_CONV_STOP_XRAY_MIN_STATE SdswStatus_CONV_STOP_XRAY_MIN_STATE_CONV_STOP_XRAY_MIN_STATE_MIN = SdswStatus_CONV_STOP_XRAY_MIN_STATE_CONV_STOP_XRAY_MIN_CONVEYOR_STOP;
const SdswStatus_CONV_STOP_XRAY_MIN_STATE SdswStatus_CONV_STOP_XRAY_MIN_STATE_CONV_STOP_XRAY_MIN_STATE_MAX = SdswStatus_CONV_STOP_XRAY_MIN_STATE_CONV_STOP_XRAY_MIN_ERROR;
const int SdswStatus_CONV_STOP_XRAY_MIN_STATE_CONV_STOP_XRAY_MIN_STATE_ARRAYSIZE = SdswStatus_CONV_STOP_XRAY_MIN_STATE_CONV_STOP_XRAY_MIN_STATE_MAX + 1;

const ::google::protobuf::EnumDescriptor* SdswStatus_CONV_STOP_XRAY_MIN_STATE_descriptor();
inline const ::std::string& SdswStatus_CONV_STOP_XRAY_MIN_STATE_Name(SdswStatus_CONV_STOP_XRAY_MIN_STATE value) {
  return ::google::protobuf::internal::NameOfEnum(
    SdswStatus_CONV_STOP_XRAY_MIN_STATE_descriptor(), value);
}
inline bool SdswStatus_CONV_STOP_XRAY_MIN_STATE_Parse(
    const ::std::string& name, SdswStatus_CONV_STOP_XRAY_MIN_STATE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SdswStatus_CONV_STOP_XRAY_MIN_STATE>(
    SdswStatus_CONV_STOP_XRAY_MIN_STATE_descriptor(), name, value);
}
enum SdswStatus_XMAX_CONVEYOR_RUN_STATE {
  SdswStatus_XMAX_CONVEYOR_RUN_STATE_XRAY_MAX_CONV_RUN_XRAY_MAXIMIZE = 0,
  SdswStatus_XMAX_CONVEYOR_RUN_STATE_XRAY_MAX_CONV_RUN_CONVEYOR_RUN = 1,
  SdswStatus_XMAX_CONVEYOR_RUN_STATE_XRAY_MAX_CONV_RUN_COMPLETE = 2,
  SdswStatus_XMAX_CONVEYOR_RUN_STATE_XRAY_MAX_CONV_RUN_ERROR = 3,
  SdswStatus_XMAX_CONVEYOR_RUN_STATE_SdswStatus_XMAX_CONVEYOR_RUN_STATE_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SdswStatus_XMAX_CONVEYOR_RUN_STATE_SdswStatus_XMAX_CONVEYOR_RUN_STATE_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SdswStatus_XMAX_CONVEYOR_RUN_STATE_IsValid(int value);
const SdswStatus_XMAX_CONVEYOR_RUN_STATE SdswStatus_XMAX_CONVEYOR_RUN_STATE_XMAX_CONVEYOR_RUN_STATE_MIN = SdswStatus_XMAX_CONVEYOR_RUN_STATE_XRAY_MAX_CONV_RUN_XRAY_MAXIMIZE;
const SdswStatus_XMAX_CONVEYOR_RUN_STATE SdswStatus_XMAX_CONVEYOR_RUN_STATE_XMAX_CONVEYOR_RUN_STATE_MAX = SdswStatus_XMAX_CONVEYOR_RUN_STATE_XRAY_MAX_CONV_RUN_ERROR;
const int SdswStatus_XMAX_CONVEYOR_RUN_STATE_XMAX_CONVEYOR_RUN_STATE_ARRAYSIZE = SdswStatus_XMAX_CONVEYOR_RUN_STATE_XMAX_CONVEYOR_RUN_STATE_MAX + 1;

const ::google::protobuf::EnumDescriptor* SdswStatus_XMAX_CONVEYOR_RUN_STATE_descriptor();
inline const ::std::string& SdswStatus_XMAX_CONVEYOR_RUN_STATE_Name(SdswStatus_XMAX_CONVEYOR_RUN_STATE value) {
  return ::google::protobuf::internal::NameOfEnum(
    SdswStatus_XMAX_CONVEYOR_RUN_STATE_descriptor(), value);
}
inline bool SdswStatus_XMAX_CONVEYOR_RUN_STATE_Parse(
    const ::std::string& name, SdswStatus_XMAX_CONVEYOR_RUN_STATE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SdswStatus_XMAX_CONVEYOR_RUN_STATE>(
    SdswStatus_XMAX_CONVEYOR_RUN_STATE_descriptor(), name, value);
}
enum SdswStatus_CONV_STOP_XRAY_MIN_STATE_CONV_RUN {
  SdswStatus_CONV_STOP_XRAY_MIN_STATE_CONV_RUN_XRAY_MIN_AND_CONV_STOP = 0,
  SdswStatus_CONV_STOP_XRAY_MIN_STATE_CONV_RUN_CONV_RUN_POST_XRAY_MIN = 1,
  SdswStatus_CONV_STOP_XRAY_MIN_STATE_CONV_RUN_CONV_STOP_XRAY_MIN_CONV_RUN_COMPLETE = 2,
  SdswStatus_CONV_STOP_XRAY_MIN_STATE_CONV_RUN_CONV_STOP_XRAY_MIN_CONV_RUN_ERROR = 3,
  SdswStatus_CONV_STOP_XRAY_MIN_STATE_CONV_RUN_SdswStatus_CONV_STOP_XRAY_MIN_STATE_CONV_RUN_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SdswStatus_CONV_STOP_XRAY_MIN_STATE_CONV_RUN_SdswStatus_CONV_STOP_XRAY_MIN_STATE_CONV_RUN_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SdswStatus_CONV_STOP_XRAY_MIN_STATE_CONV_RUN_IsValid(int value);
const SdswStatus_CONV_STOP_XRAY_MIN_STATE_CONV_RUN SdswStatus_CONV_STOP_XRAY_MIN_STATE_CONV_RUN_CONV_STOP_XRAY_MIN_STATE_CONV_RUN_MIN = SdswStatus_CONV_STOP_XRAY_MIN_STATE_CONV_RUN_XRAY_MIN_AND_CONV_STOP;
const SdswStatus_CONV_STOP_XRAY_MIN_STATE_CONV_RUN SdswStatus_CONV_STOP_XRAY_MIN_STATE_CONV_RUN_CONV_STOP_XRAY_MIN_STATE_CONV_RUN_MAX = SdswStatus_CONV_STOP_XRAY_MIN_STATE_CONV_RUN_CONV_STOP_XRAY_MIN_CONV_RUN_ERROR;
const int SdswStatus_CONV_STOP_XRAY_MIN_STATE_CONV_RUN_CONV_STOP_XRAY_MIN_STATE_CONV_RUN_ARRAYSIZE = SdswStatus_CONV_STOP_XRAY_MIN_STATE_CONV_RUN_CONV_STOP_XRAY_MIN_STATE_CONV_RUN_MAX + 1;

const ::google::protobuf::EnumDescriptor* SdswStatus_CONV_STOP_XRAY_MIN_STATE_CONV_RUN_descriptor();
inline const ::std::string& SdswStatus_CONV_STOP_XRAY_MIN_STATE_CONV_RUN_Name(SdswStatus_CONV_STOP_XRAY_MIN_STATE_CONV_RUN value) {
  return ::google::protobuf::internal::NameOfEnum(
    SdswStatus_CONV_STOP_XRAY_MIN_STATE_CONV_RUN_descriptor(), value);
}
inline bool SdswStatus_CONV_STOP_XRAY_MIN_STATE_CONV_RUN_Parse(
    const ::std::string& name, SdswStatus_CONV_STOP_XRAY_MIN_STATE_CONV_RUN* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SdswStatus_CONV_STOP_XRAY_MIN_STATE_CONV_RUN>(
    SdswStatus_CONV_STOP_XRAY_MIN_STATE_CONV_RUN_descriptor(), name, value);
}
enum SdswStatus_BELT_TUNNEL_CAL_STATE {
  SdswStatus_BELT_TUNNEL_CAL_STATE_BELT_TUNNEL_CAL_CLEAR_ERROR = 0,
  SdswStatus_BELT_TUNNEL_CAL_STATE_BELT_TUNNEL_CAL_GANTRY_ON = 1,
  SdswStatus_BELT_TUNNEL_CAL_STATE_BELT_TUNNEL_CAL_CONVEYOR_STOP = 2,
  SdswStatus_BELT_TUNNEL_CAL_STATE_BELT_TUNNEL_CAL_XRAY_OFF_1 = 3,
  SdswStatus_BELT_TUNNEL_CAL_STATE_BELT_TUNNEL_CAL_RAW_DATA_COLLECT_OFFSET = 4,
  SdswStatus_BELT_TUNNEL_CAL_STATE_BELT_TUNNEL_CAL_XRAY_ON = 5,
  SdswStatus_BELT_TUNNEL_CAL_STATE_BELT_TUNNEL_CAL_RAW_DATA_COLLECT_AIR = 6,
  SdswStatus_BELT_TUNNEL_CAL_STATE_BELT_TUNNEL_CAL_XRAY_OFF_2 = 7,
  SdswStatus_BELT_TUNNEL_CAL_STATE_BELT_TUNNEL_CAL_ANALYZE = 8,
  SdswStatus_BELT_TUNNEL_CAL_STATE_BELT_TUNNEL_CAL_COMPLETE = 9,
  SdswStatus_BELT_TUNNEL_CAL_STATE_BELT_TUNNEL_CAL_ERROR = 10,
  SdswStatus_BELT_TUNNEL_CAL_STATE_SdswStatus_BELT_TUNNEL_CAL_STATE_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SdswStatus_BELT_TUNNEL_CAL_STATE_SdswStatus_BELT_TUNNEL_CAL_STATE_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SdswStatus_BELT_TUNNEL_CAL_STATE_IsValid(int value);
const SdswStatus_BELT_TUNNEL_CAL_STATE SdswStatus_BELT_TUNNEL_CAL_STATE_BELT_TUNNEL_CAL_STATE_MIN = SdswStatus_BELT_TUNNEL_CAL_STATE_BELT_TUNNEL_CAL_CLEAR_ERROR;
const SdswStatus_BELT_TUNNEL_CAL_STATE SdswStatus_BELT_TUNNEL_CAL_STATE_BELT_TUNNEL_CAL_STATE_MAX = SdswStatus_BELT_TUNNEL_CAL_STATE_BELT_TUNNEL_CAL_ERROR;
const int SdswStatus_BELT_TUNNEL_CAL_STATE_BELT_TUNNEL_CAL_STATE_ARRAYSIZE = SdswStatus_BELT_TUNNEL_CAL_STATE_BELT_TUNNEL_CAL_STATE_MAX + 1;

const ::google::protobuf::EnumDescriptor* SdswStatus_BELT_TUNNEL_CAL_STATE_descriptor();
inline const ::std::string& SdswStatus_BELT_TUNNEL_CAL_STATE_Name(SdswStatus_BELT_TUNNEL_CAL_STATE value) {
  return ::google::protobuf::internal::NameOfEnum(
    SdswStatus_BELT_TUNNEL_CAL_STATE_descriptor(), value);
}
inline bool SdswStatus_BELT_TUNNEL_CAL_STATE_Parse(
    const ::std::string& name, SdswStatus_BELT_TUNNEL_CAL_STATE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SdswStatus_BELT_TUNNEL_CAL_STATE>(
    SdswStatus_BELT_TUNNEL_CAL_STATE_descriptor(), name, value);
}
enum ExportFilesRpc_FILE_TYPES {
  ExportFilesRpc_FILE_TYPES_NULL_FILE = 0,
  ExportFilesRpc_FILE_TYPES_ERROR_LOG = 1,
  ExportFilesRpc_FILE_TYPES_TEST_RESULTS = 2,
  ExportFilesRpc_FILE_TYPES_CALIBRATION = 4,
  ExportFilesRpc_FILE_TYPES_CONFIGURATION = 8,
  ExportFilesRpc_FILE_TYPES_OPERATING_SYSTEM = 16,
  ExportFilesRpc_FILE_TYPES_APPLICATION_LOGS = 32,
  ExportFilesRpc_FILE_TYPES_ExportFilesRpc_FILE_TYPES_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ExportFilesRpc_FILE_TYPES_ExportFilesRpc_FILE_TYPES_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ExportFilesRpc_FILE_TYPES_IsValid(int value);
const ExportFilesRpc_FILE_TYPES ExportFilesRpc_FILE_TYPES_FILE_TYPES_MIN = ExportFilesRpc_FILE_TYPES_NULL_FILE;
const ExportFilesRpc_FILE_TYPES ExportFilesRpc_FILE_TYPES_FILE_TYPES_MAX = ExportFilesRpc_FILE_TYPES_APPLICATION_LOGS;
const int ExportFilesRpc_FILE_TYPES_FILE_TYPES_ARRAYSIZE = ExportFilesRpc_FILE_TYPES_FILE_TYPES_MAX + 1;

const ::google::protobuf::EnumDescriptor* ExportFilesRpc_FILE_TYPES_descriptor();
inline const ::std::string& ExportFilesRpc_FILE_TYPES_Name(ExportFilesRpc_FILE_TYPES value) {
  return ::google::protobuf::internal::NameOfEnum(
    ExportFilesRpc_FILE_TYPES_descriptor(), value);
}
inline bool ExportFilesRpc_FILE_TYPES_Parse(
    const ::std::string& name, ExportFilesRpc_FILE_TYPES* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ExportFilesRpc_FILE_TYPES>(
    ExportFilesRpc_FILE_TYPES_descriptor(), name, value);
}
enum CalibrationRpc_CAL_COMMAND {
  CalibrationRpc_CAL_COMMAND_START = 0,
  CalibrationRpc_CAL_COMMAND_PROCEED = 1,
  CalibrationRpc_CAL_COMMAND_CANCEL = 2,
  CalibrationRpc_CAL_COMMAND_CalibrationRpc_CAL_COMMAND_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  CalibrationRpc_CAL_COMMAND_CalibrationRpc_CAL_COMMAND_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool CalibrationRpc_CAL_COMMAND_IsValid(int value);
const CalibrationRpc_CAL_COMMAND CalibrationRpc_CAL_COMMAND_CAL_COMMAND_MIN = CalibrationRpc_CAL_COMMAND_START;
const CalibrationRpc_CAL_COMMAND CalibrationRpc_CAL_COMMAND_CAL_COMMAND_MAX = CalibrationRpc_CAL_COMMAND_CANCEL;
const int CalibrationRpc_CAL_COMMAND_CAL_COMMAND_ARRAYSIZE = CalibrationRpc_CAL_COMMAND_CAL_COMMAND_MAX + 1;

const ::google::protobuf::EnumDescriptor* CalibrationRpc_CAL_COMMAND_descriptor();
inline const ::std::string& CalibrationRpc_CAL_COMMAND_Name(CalibrationRpc_CAL_COMMAND value) {
  return ::google::protobuf::internal::NameOfEnum(
    CalibrationRpc_CAL_COMMAND_descriptor(), value);
}
inline bool CalibrationRpc_CAL_COMMAND_Parse(
    const ::std::string& name, CalibrationRpc_CAL_COMMAND* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CalibrationRpc_CAL_COMMAND>(
    CalibrationRpc_CAL_COMMAND_descriptor(), name, value);
}
// ===================================================================

class RpcReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:analogic.RpcReply) */ {
 public:
  RpcReply();
  virtual ~RpcReply();

  RpcReply(const RpcReply& from);

  inline RpcReply& operator=(const RpcReply& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpcReply& default_instance();

  void Swap(RpcReply* other);

  // implements Message ----------------------------------------------

  inline RpcReply* New() const { return New(NULL); }

  RpcReply* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpcReply& from);
  void MergeFrom(const RpcReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RpcReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef RpcReply_RPC_REPLY RPC_REPLY;
  static const RPC_REPLY COMPLETE =
    RpcReply_RPC_REPLY_COMPLETE;
  static const RPC_REPLY BUSY =
    RpcReply_RPC_REPLY_BUSY;
  static const RPC_REPLY TIMEOUT =
    RpcReply_RPC_REPLY_TIMEOUT;
  static const RPC_REPLY ERROR =
    RpcReply_RPC_REPLY_ERROR;
  static const RPC_REPLY READY =
    RpcReply_RPC_REPLY_READY;
  static inline bool RPC_REPLY_IsValid(int value) {
    return RpcReply_RPC_REPLY_IsValid(value);
  }
  static const RPC_REPLY RPC_REPLY_MIN =
    RpcReply_RPC_REPLY_RPC_REPLY_MIN;
  static const RPC_REPLY RPC_REPLY_MAX =
    RpcReply_RPC_REPLY_RPC_REPLY_MAX;
  static const int RPC_REPLY_ARRAYSIZE =
    RpcReply_RPC_REPLY_RPC_REPLY_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RPC_REPLY_descriptor() {
    return RpcReply_RPC_REPLY_descriptor();
  }
  static inline const ::std::string& RPC_REPLY_Name(RPC_REPLY value) {
    return RpcReply_RPC_REPLY_Name(value);
  }
  static inline bool RPC_REPLY_Parse(const ::std::string& name,
      RPC_REPLY* value) {
    return RpcReply_RPC_REPLY_Parse(name, value);
  }

  typedef RpcReply_RPC_ERROR_CODE RPC_ERROR_CODE;
  static const RPC_ERROR_CODE COMMAND_FAILURE =
    RpcReply_RPC_ERROR_CODE_COMMAND_FAILURE;
  static const RPC_ERROR_CODE FILE_NOT_FOUND =
    RpcReply_RPC_ERROR_CODE_FILE_NOT_FOUND;
  static const RPC_ERROR_CODE FILE_NOT_CREATED =
    RpcReply_RPC_ERROR_CODE_FILE_NOT_CREATED;
  static inline bool RPC_ERROR_CODE_IsValid(int value) {
    return RpcReply_RPC_ERROR_CODE_IsValid(value);
  }
  static const RPC_ERROR_CODE RPC_ERROR_CODE_MIN =
    RpcReply_RPC_ERROR_CODE_RPC_ERROR_CODE_MIN;
  static const RPC_ERROR_CODE RPC_ERROR_CODE_MAX =
    RpcReply_RPC_ERROR_CODE_RPC_ERROR_CODE_MAX;
  static const int RPC_ERROR_CODE_ARRAYSIZE =
    RpcReply_RPC_ERROR_CODE_RPC_ERROR_CODE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RPC_ERROR_CODE_descriptor() {
    return RpcReply_RPC_ERROR_CODE_descriptor();
  }
  static inline const ::std::string& RPC_ERROR_CODE_Name(RPC_ERROR_CODE value) {
    return RpcReply_RPC_ERROR_CODE_Name(value);
  }
  static inline bool RPC_ERROR_CODE_Parse(const ::std::string& name,
      RPC_ERROR_CODE* value) {
    return RpcReply_RPC_ERROR_CODE_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .analogic.RpcReply.RPC_REPLY reply_id = 1;
  void clear_reply_id();
  static const int kReplyIdFieldNumber = 1;
  ::analogic::RpcReply_RPC_REPLY reply_id() const;
  void set_reply_id(::analogic::RpcReply_RPC_REPLY value);

  // optional string file_name = 2;
  void clear_file_name();
  static const int kFileNameFieldNumber = 2;
  const ::std::string& file_name() const;
  void set_file_name(const ::std::string& value);
  void set_file_name(const char* value);
  void set_file_name(const char* value, size_t size);
  ::std::string* mutable_file_name();
  ::std::string* release_file_name();
  void set_allocated_file_name(::std::string* file_name);

  // optional float belt_height = 3;
  void clear_belt_height();
  static const int kBeltHeightFieldNumber = 3;
  float belt_height() const;
  void set_belt_height(float value);

  // optional float nylon_scale = 4;
  void clear_nylon_scale();
  static const int kNylonScaleFieldNumber = 4;
  float nylon_scale() const;
  void set_nylon_scale(float value);

  // optional string file_name_2 = 5;
  void clear_file_name_2();
  static const int kFileName2FieldNumber = 5;
  const ::std::string& file_name_2() const;
  void set_file_name_2(const ::std::string& value);
  void set_file_name_2(const char* value);
  void set_file_name_2(const char* value, size_t size);
  ::std::string* mutable_file_name_2();
  ::std::string* release_file_name_2();
  void set_allocated_file_name_2(::std::string* file_name_2);

  // optional float float_data_1 = 6;
  void clear_float_data_1();
  static const int kFloatData1FieldNumber = 6;
  float float_data_1() const;
  void set_float_data_1(float value);

  // optional float float_data_2 = 7;
  void clear_float_data_2();
  static const int kFloatData2FieldNumber = 7;
  float float_data_2() const;
  void set_float_data_2(float value);

  // optional float float_data_3 = 8;
  void clear_float_data_3();
  static const int kFloatData3FieldNumber = 8;
  float float_data_3() const;
  void set_float_data_3(float value);

  // optional .analogic.RpcReply.RPC_ERROR_CODE error_code = 9;
  void clear_error_code();
  static const int kErrorCodeFieldNumber = 9;
  ::analogic::RpcReply_RPC_ERROR_CODE error_code() const;
  void set_error_code(::analogic::RpcReply_RPC_ERROR_CODE value);

  // optional int32 belt_frequency = 10;
  void clear_belt_frequency();
  static const int kBeltFrequencyFieldNumber = 10;
  ::google::protobuf::int32 belt_frequency() const;
  void set_belt_frequency(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:analogic.RpcReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr file_name_;
  int reply_id_;
  float belt_height_;
  ::google::protobuf::internal::ArenaStringPtr file_name_2_;
  float nylon_scale_;
  float float_data_1_;
  float float_data_2_;
  float float_data_3_;
  int error_code_;
  ::google::protobuf::int32 belt_frequency_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_proto_2fCalService_2eproto();
  friend void protobuf_AssignDesc_proto_2fCalService_2eproto();
  friend void protobuf_ShutdownFile_proto_2fCalService_2eproto();

  void InitAsDefaultInstance();
  static RpcReply* default_instance_;
};
// -------------------------------------------------------------------

class XrayControlRpc : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:analogic.XrayControlRpc) */ {
 public:
  XrayControlRpc();
  virtual ~XrayControlRpc();

  XrayControlRpc(const XrayControlRpc& from);

  inline XrayControlRpc& operator=(const XrayControlRpc& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const XrayControlRpc& default_instance();

  void Swap(XrayControlRpc* other);

  // implements Message ----------------------------------------------

  inline XrayControlRpc* New() const { return New(NULL); }

  XrayControlRpc* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const XrayControlRpc& from);
  void MergeFrom(const XrayControlRpc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(XrayControlRpc* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef XrayControlRpc_XRAY_STATE XRAY_STATE;
  static const XRAY_STATE XRAY_OFF =
    XrayControlRpc_XRAY_STATE_XRAY_OFF;
  static const XRAY_STATE XRAY_ON =
    XrayControlRpc_XRAY_STATE_XRAY_ON;
  static const XRAY_STATE XRAY_MINIMIZED =
    XrayControlRpc_XRAY_STATE_XRAY_MINIMIZED;
  static inline bool XRAY_STATE_IsValid(int value) {
    return XrayControlRpc_XRAY_STATE_IsValid(value);
  }
  static const XRAY_STATE XRAY_STATE_MIN =
    XrayControlRpc_XRAY_STATE_XRAY_STATE_MIN;
  static const XRAY_STATE XRAY_STATE_MAX =
    XrayControlRpc_XRAY_STATE_XRAY_STATE_MAX;
  static const int XRAY_STATE_ARRAYSIZE =
    XrayControlRpc_XRAY_STATE_XRAY_STATE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  XRAY_STATE_descriptor() {
    return XrayControlRpc_XRAY_STATE_descriptor();
  }
  static inline const ::std::string& XRAY_STATE_Name(XRAY_STATE value) {
    return XrayControlRpc_XRAY_STATE_Name(value);
  }
  static inline bool XRAY_STATE_Parse(const ::std::string& name,
      XRAY_STATE* value) {
    return XrayControlRpc_XRAY_STATE_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:analogic.XrayControlRpc)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_proto_2fCalService_2eproto();
  friend void protobuf_AssignDesc_proto_2fCalService_2eproto();
  friend void protobuf_ShutdownFile_proto_2fCalService_2eproto();

  void InitAsDefaultInstance();
  static XrayControlRpc* default_instance_;
};
// -------------------------------------------------------------------

class RawDataCollectRpc : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:analogic.RawDataCollectRpc) */ {
 public:
  RawDataCollectRpc();
  virtual ~RawDataCollectRpc();

  RawDataCollectRpc(const RawDataCollectRpc& from);

  inline RawDataCollectRpc& operator=(const RawDataCollectRpc& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RawDataCollectRpc& default_instance();

  void Swap(RawDataCollectRpc* other);

  // implements Message ----------------------------------------------

  inline RawDataCollectRpc* New() const { return New(NULL); }

  RawDataCollectRpc* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RawDataCollectRpc& from);
  void MergeFrom(const RawDataCollectRpc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RawDataCollectRpc* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .analogic.XrayControlRpc.XRAY_STATE xray_state = 1;
  void clear_xray_state();
  static const int kXrayStateFieldNumber = 1;
  ::analogic::XrayControlRpc_XRAY_STATE xray_state() const;
  void set_xray_state(::analogic::XrayControlRpc_XRAY_STATE value);

  // optional bool gantry_on = 2;
  void clear_gantry_on();
  static const int kGantryOnFieldNumber = 2;
  bool gantry_on() const;
  void set_gantry_on(bool value);

  // optional bool conveyor_on = 3;
  void clear_conveyor_on();
  static const int kConveyorOnFieldNumber = 3;
  bool conveyor_on() const;
  void set_conveyor_on(bool value);

  // optional int32 num_rotations = 4;
  void clear_num_rotations();
  static const int kNumRotationsFieldNumber = 4;
  ::google::protobuf::int32 num_rotations() const;
  void set_num_rotations(::google::protobuf::int32 value);

  // optional string file_path = 5;
  void clear_file_path();
  static const int kFilePathFieldNumber = 5;
  const ::std::string& file_path() const;
  void set_file_path(const ::std::string& value);
  void set_file_path(const char* value);
  void set_file_path(const char* value, size_t size);
  ::std::string* mutable_file_path();
  ::std::string* release_file_path();
  void set_allocated_file_path(::std::string* file_path);

  // @@protoc_insertion_point(class_scope:analogic.RawDataCollectRpc)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  int xray_state_;
  bool gantry_on_;
  bool conveyor_on_;
  ::google::protobuf::internal::ArenaStringPtr file_path_;
  ::google::protobuf::int32 num_rotations_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_proto_2fCalService_2eproto();
  friend void protobuf_AssignDesc_proto_2fCalService_2eproto();
  friend void protobuf_ShutdownFile_proto_2fCalService_2eproto();

  void InitAsDefaultInstance();
  static RawDataCollectRpc* default_instance_;
};
// -------------------------------------------------------------------

class AirCalRpc : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:analogic.AirCalRpc) */ {
 public:
  AirCalRpc();
  virtual ~AirCalRpc();

  AirCalRpc(const AirCalRpc& from);

  inline AirCalRpc& operator=(const AirCalRpc& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AirCalRpc& default_instance();

  void Swap(AirCalRpc* other);

  // implements Message ----------------------------------------------

  inline AirCalRpc* New() const { return New(NULL); }

  AirCalRpc* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AirCalRpc& from);
  void MergeFrom(const AirCalRpc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AirCalRpc* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:analogic.AirCalRpc)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_proto_2fCalService_2eproto();
  friend void protobuf_AssignDesc_proto_2fCalService_2eproto();
  friend void protobuf_ShutdownFile_proto_2fCalService_2eproto();

  void InitAsDefaultInstance();
  static AirCalRpc* default_instance_;
};
// -------------------------------------------------------------------

class OffsetCalRpc : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:analogic.OffsetCalRpc) */ {
 public:
  OffsetCalRpc();
  virtual ~OffsetCalRpc();

  OffsetCalRpc(const OffsetCalRpc& from);

  inline OffsetCalRpc& operator=(const OffsetCalRpc& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OffsetCalRpc& default_instance();

  void Swap(OffsetCalRpc* other);

  // implements Message ----------------------------------------------

  inline OffsetCalRpc* New() const { return New(NULL); }

  OffsetCalRpc* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OffsetCalRpc& from);
  void MergeFrom(const OffsetCalRpc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OffsetCalRpc* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:analogic.OffsetCalRpc)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_proto_2fCalService_2eproto();
  friend void protobuf_AssignDesc_proto_2fCalService_2eproto();
  friend void protobuf_ShutdownFile_proto_2fCalService_2eproto();

  void InitAsDefaultInstance();
  static OffsetCalRpc* default_instance_;
};
// -------------------------------------------------------------------

class ImageQualityTestRpc : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:analogic.ImageQualityTestRpc) */ {
 public:
  ImageQualityTestRpc();
  virtual ~ImageQualityTestRpc();

  ImageQualityTestRpc(const ImageQualityTestRpc& from);

  inline ImageQualityTestRpc& operator=(const ImageQualityTestRpc& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ImageQualityTestRpc& default_instance();

  void Swap(ImageQualityTestRpc* other);

  // implements Message ----------------------------------------------

  inline ImageQualityTestRpc* New() const { return New(NULL); }

  ImageQualityTestRpc* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ImageQualityTestRpc& from);
  void MergeFrom(const ImageQualityTestRpc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ImageQualityTestRpc* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ImageQualityTestRpc_IQ_TEST_TYPE IQ_TEST_TYPE;
  static const IQ_TEST_TYPE IQ_NONE =
    ImageQualityTestRpc_IQ_TEST_TYPE_IQ_NONE;
  static const IQ_TEST_TYPE IQT_ANALOGIC =
    ImageQualityTestRpc_IQ_TEST_TYPE_IQT_ANALOGIC;
  static const IQ_TEST_TYPE IQT_NIST_A =
    ImageQualityTestRpc_IQ_TEST_TYPE_IQT_NIST_A;
  static const IQ_TEST_TYPE IQT_NIST_B =
    ImageQualityTestRpc_IQ_TEST_TYPE_IQT_NIST_B;
  static inline bool IQ_TEST_TYPE_IsValid(int value) {
    return ImageQualityTestRpc_IQ_TEST_TYPE_IsValid(value);
  }
  static const IQ_TEST_TYPE IQ_TEST_TYPE_MIN =
    ImageQualityTestRpc_IQ_TEST_TYPE_IQ_TEST_TYPE_MIN;
  static const IQ_TEST_TYPE IQ_TEST_TYPE_MAX =
    ImageQualityTestRpc_IQ_TEST_TYPE_IQ_TEST_TYPE_MAX;
  static const int IQ_TEST_TYPE_ARRAYSIZE =
    ImageQualityTestRpc_IQ_TEST_TYPE_IQ_TEST_TYPE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  IQ_TEST_TYPE_descriptor() {
    return ImageQualityTestRpc_IQ_TEST_TYPE_descriptor();
  }
  static inline const ::std::string& IQ_TEST_TYPE_Name(IQ_TEST_TYPE value) {
    return ImageQualityTestRpc_IQ_TEST_TYPE_Name(value);
  }
  static inline bool IQ_TEST_TYPE_Parse(const ::std::string& name,
      IQ_TEST_TYPE* value) {
    return ImageQualityTestRpc_IQ_TEST_TYPE_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string dest_folder = 1;
  void clear_dest_folder();
  static const int kDestFolderFieldNumber = 1;
  const ::std::string& dest_folder() const;
  void set_dest_folder(const ::std::string& value);
  void set_dest_folder(const char* value);
  void set_dest_folder(const char* value, size_t size);
  ::std::string* mutable_dest_folder();
  ::std::string* release_dest_folder();
  void set_allocated_dest_folder(::std::string* dest_folder);

  // optional float float_data_1 = 2;
  void clear_float_data_1();
  static const int kFloatData1FieldNumber = 2;
  float float_data_1() const;
  void set_float_data_1(float value);

  // optional float float_data_2 = 3;
  void clear_float_data_2();
  static const int kFloatData2FieldNumber = 3;
  float float_data_2() const;
  void set_float_data_2(float value);

  // optional float float_data_3 = 4;
  void clear_float_data_3();
  static const int kFloatData3FieldNumber = 4;
  float float_data_3() const;
  void set_float_data_3(float value);

  // optional string source_user = 5;
  void clear_source_user();
  static const int kSourceUserFieldNumber = 5;
  const ::std::string& source_user() const;
  void set_source_user(const ::std::string& value);
  void set_source_user(const char* value);
  void set_source_user(const char* value, size_t size);
  ::std::string* mutable_source_user();
  ::std::string* release_source_user();
  void set_allocated_source_user(::std::string* source_user);

  // optional .analogic.ImageQualityTestRpc.IQ_TEST_TYPE iq_test_type = 6;
  void clear_iq_test_type();
  static const int kIqTestTypeFieldNumber = 6;
  ::analogic::ImageQualityTestRpc_IQ_TEST_TYPE iq_test_type() const;
  void set_iq_test_type(::analogic::ImageQualityTestRpc_IQ_TEST_TYPE value);

  // @@protoc_insertion_point(class_scope:analogic.ImageQualityTestRpc)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr dest_folder_;
  float float_data_1_;
  float float_data_2_;
  ::google::protobuf::internal::ArenaStringPtr source_user_;
  float float_data_3_;
  int iq_test_type_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_proto_2fCalService_2eproto();
  friend void protobuf_AssignDesc_proto_2fCalService_2eproto();
  friend void protobuf_ShutdownFile_proto_2fCalService_2eproto();

  void InitAsDefaultInstance();
  static ImageQualityTestRpc* default_instance_;
};
// -------------------------------------------------------------------

class GetImageQualityMassValuesRpc : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:analogic.GetImageQualityMassValuesRpc) */ {
 public:
  GetImageQualityMassValuesRpc();
  virtual ~GetImageQualityMassValuesRpc();

  GetImageQualityMassValuesRpc(const GetImageQualityMassValuesRpc& from);

  inline GetImageQualityMassValuesRpc& operator=(const GetImageQualityMassValuesRpc& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetImageQualityMassValuesRpc& default_instance();

  void Swap(GetImageQualityMassValuesRpc* other);

  // implements Message ----------------------------------------------

  inline GetImageQualityMassValuesRpc* New() const { return New(NULL); }

  GetImageQualityMassValuesRpc* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetImageQualityMassValuesRpc& from);
  void MergeFrom(const GetImageQualityMassValuesRpc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetImageQualityMassValuesRpc* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:analogic.GetImageQualityMassValuesRpc)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_proto_2fCalService_2eproto();
  friend void protobuf_AssignDesc_proto_2fCalService_2eproto();
  friend void protobuf_ShutdownFile_proto_2fCalService_2eproto();

  void InitAsDefaultInstance();
  static GetImageQualityMassValuesRpc* default_instance_;
};
// -------------------------------------------------------------------

class RadiationSurveyRpc : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:analogic.RadiationSurveyRpc) */ {
 public:
  RadiationSurveyRpc();
  virtual ~RadiationSurveyRpc();

  RadiationSurveyRpc(const RadiationSurveyRpc& from);

  inline RadiationSurveyRpc& operator=(const RadiationSurveyRpc& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RadiationSurveyRpc& default_instance();

  void Swap(RadiationSurveyRpc* other);

  // implements Message ----------------------------------------------

  inline RadiationSurveyRpc* New() const { return New(NULL); }

  RadiationSurveyRpc* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RadiationSurveyRpc& from);
  void MergeFrom(const RadiationSurveyRpc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RadiationSurveyRpc* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:analogic.RadiationSurveyRpc)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_proto_2fCalService_2eproto();
  friend void protobuf_AssignDesc_proto_2fCalService_2eproto();
  friend void protobuf_ShutdownFile_proto_2fCalService_2eproto();

  void InitAsDefaultInstance();
  static RadiationSurveyRpc* default_instance_;
};
// -------------------------------------------------------------------

class RadSurveyRpcCancel : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:analogic.RadSurveyRpcCancel) */ {
 public:
  RadSurveyRpcCancel();
  virtual ~RadSurveyRpcCancel();

  RadSurveyRpcCancel(const RadSurveyRpcCancel& from);

  inline RadSurveyRpcCancel& operator=(const RadSurveyRpcCancel& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RadSurveyRpcCancel& default_instance();

  void Swap(RadSurveyRpcCancel* other);

  // implements Message ----------------------------------------------

  inline RadSurveyRpcCancel* New() const { return New(NULL); }

  RadSurveyRpcCancel* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RadSurveyRpcCancel& from);
  void MergeFrom(const RadSurveyRpcCancel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RadSurveyRpcCancel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:analogic.RadSurveyRpcCancel)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_proto_2fCalService_2eproto();
  friend void protobuf_AssignDesc_proto_2fCalService_2eproto();
  friend void protobuf_ShutdownFile_proto_2fCalService_2eproto();

  void InitAsDefaultInstance();
  static RadSurveyRpcCancel* default_instance_;
};
// -------------------------------------------------------------------

class BeltTunnelCalRpc : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:analogic.BeltTunnelCalRpc) */ {
 public:
  BeltTunnelCalRpc();
  virtual ~BeltTunnelCalRpc();

  BeltTunnelCalRpc(const BeltTunnelCalRpc& from);

  inline BeltTunnelCalRpc& operator=(const BeltTunnelCalRpc& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BeltTunnelCalRpc& default_instance();

  void Swap(BeltTunnelCalRpc* other);

  // implements Message ----------------------------------------------

  inline BeltTunnelCalRpc* New() const { return New(NULL); }

  BeltTunnelCalRpc* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BeltTunnelCalRpc& from);
  void MergeFrom(const BeltTunnelCalRpc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BeltTunnelCalRpc* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:analogic.BeltTunnelCalRpc)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_proto_2fCalService_2eproto();
  friend void protobuf_AssignDesc_proto_2fCalService_2eproto();
  friend void protobuf_ShutdownFile_proto_2fCalService_2eproto();

  void InitAsDefaultInstance();
  static BeltTunnelCalRpc* default_instance_;
};
// -------------------------------------------------------------------

class GetBadDetectorMapFilesRpc : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:analogic.GetBadDetectorMapFilesRpc) */ {
 public:
  GetBadDetectorMapFilesRpc();
  virtual ~GetBadDetectorMapFilesRpc();

  GetBadDetectorMapFilesRpc(const GetBadDetectorMapFilesRpc& from);

  inline GetBadDetectorMapFilesRpc& operator=(const GetBadDetectorMapFilesRpc& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetBadDetectorMapFilesRpc& default_instance();

  void Swap(GetBadDetectorMapFilesRpc* other);

  // implements Message ----------------------------------------------

  inline GetBadDetectorMapFilesRpc* New() const { return New(NULL); }

  GetBadDetectorMapFilesRpc* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetBadDetectorMapFilesRpc& from);
  void MergeFrom(const GetBadDetectorMapFilesRpc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetBadDetectorMapFilesRpc* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string file_path = 1;
  void clear_file_path();
  static const int kFilePathFieldNumber = 1;
  const ::std::string& file_path() const;
  void set_file_path(const ::std::string& value);
  void set_file_path(const char* value);
  void set_file_path(const char* value, size_t size);
  ::std::string* mutable_file_path();
  ::std::string* release_file_path();
  void set_allocated_file_path(::std::string* file_path);

  // @@protoc_insertion_point(class_scope:analogic.GetBadDetectorMapFilesRpc)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr file_path_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_proto_2fCalService_2eproto();
  friend void protobuf_AssignDesc_proto_2fCalService_2eproto();
  friend void protobuf_ShutdownFile_proto_2fCalService_2eproto();

  void InitAsDefaultInstance();
  static GetBadDetectorMapFilesRpc* default_instance_;
};
// -------------------------------------------------------------------

class GetBadDetectorManualFileRpc : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:analogic.GetBadDetectorManualFileRpc) */ {
 public:
  GetBadDetectorManualFileRpc();
  virtual ~GetBadDetectorManualFileRpc();

  GetBadDetectorManualFileRpc(const GetBadDetectorManualFileRpc& from);

  inline GetBadDetectorManualFileRpc& operator=(const GetBadDetectorManualFileRpc& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetBadDetectorManualFileRpc& default_instance();

  void Swap(GetBadDetectorManualFileRpc* other);

  // implements Message ----------------------------------------------

  inline GetBadDetectorManualFileRpc* New() const { return New(NULL); }

  GetBadDetectorManualFileRpc* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetBadDetectorManualFileRpc& from);
  void MergeFrom(const GetBadDetectorManualFileRpc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetBadDetectorManualFileRpc* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string file_path = 1;
  void clear_file_path();
  static const int kFilePathFieldNumber = 1;
  const ::std::string& file_path() const;
  void set_file_path(const ::std::string& value);
  void set_file_path(const char* value);
  void set_file_path(const char* value, size_t size);
  ::std::string* mutable_file_path();
  ::std::string* release_file_path();
  void set_allocated_file_path(::std::string* file_path);

  // @@protoc_insertion_point(class_scope:analogic.GetBadDetectorManualFileRpc)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr file_path_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_proto_2fCalService_2eproto();
  friend void protobuf_AssignDesc_proto_2fCalService_2eproto();
  friend void protobuf_ShutdownFile_proto_2fCalService_2eproto();

  void InitAsDefaultInstance();
  static GetBadDetectorManualFileRpc* default_instance_;
};
// -------------------------------------------------------------------

class UpdateBadDetectorManualFileRpc : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:analogic.UpdateBadDetectorManualFileRpc) */ {
 public:
  UpdateBadDetectorManualFileRpc();
  virtual ~UpdateBadDetectorManualFileRpc();

  UpdateBadDetectorManualFileRpc(const UpdateBadDetectorManualFileRpc& from);

  inline UpdateBadDetectorManualFileRpc& operator=(const UpdateBadDetectorManualFileRpc& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateBadDetectorManualFileRpc& default_instance();

  void Swap(UpdateBadDetectorManualFileRpc* other);

  // implements Message ----------------------------------------------

  inline UpdateBadDetectorManualFileRpc* New() const { return New(NULL); }

  UpdateBadDetectorManualFileRpc* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdateBadDetectorManualFileRpc& from);
  void MergeFrom(const UpdateBadDetectorManualFileRpc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UpdateBadDetectorManualFileRpc* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string content = 1;
  void clear_content();
  static const int kContentFieldNumber = 1;
  const ::std::string& content() const;
  void set_content(const ::std::string& value);
  void set_content(const char* value);
  void set_content(const char* value, size_t size);
  ::std::string* mutable_content();
  ::std::string* release_content();
  void set_allocated_content(::std::string* content);

  // @@protoc_insertion_point(class_scope:analogic.UpdateBadDetectorManualFileRpc)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr content_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_proto_2fCalService_2eproto();
  friend void protobuf_AssignDesc_proto_2fCalService_2eproto();
  friend void protobuf_ShutdownFile_proto_2fCalService_2eproto();

  void InitAsDefaultInstance();
  static UpdateBadDetectorManualFileRpc* default_instance_;
};
// -------------------------------------------------------------------

class GetErrorLogFileRpc : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:analogic.GetErrorLogFileRpc) */ {
 public:
  GetErrorLogFileRpc();
  virtual ~GetErrorLogFileRpc();

  GetErrorLogFileRpc(const GetErrorLogFileRpc& from);

  inline GetErrorLogFileRpc& operator=(const GetErrorLogFileRpc& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetErrorLogFileRpc& default_instance();

  void Swap(GetErrorLogFileRpc* other);

  // implements Message ----------------------------------------------

  inline GetErrorLogFileRpc* New() const { return New(NULL); }

  GetErrorLogFileRpc* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetErrorLogFileRpc& from);
  void MergeFrom(const GetErrorLogFileRpc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetErrorLogFileRpc* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string file_path = 1;
  void clear_file_path();
  static const int kFilePathFieldNumber = 1;
  const ::std::string& file_path() const;
  void set_file_path(const ::std::string& value);
  void set_file_path(const char* value);
  void set_file_path(const char* value, size_t size);
  ::std::string* mutable_file_path();
  ::std::string* release_file_path();
  void set_allocated_file_path(::std::string* file_path);

  // @@protoc_insertion_point(class_scope:analogic.GetErrorLogFileRpc)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr file_path_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_proto_2fCalService_2eproto();
  friend void protobuf_AssignDesc_proto_2fCalService_2eproto();
  friend void protobuf_ShutdownFile_proto_2fCalService_2eproto();

  void InitAsDefaultInstance();
  static GetErrorLogFileRpc* default_instance_;
};
// -------------------------------------------------------------------

class GetScannerConfigFileRpc : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:analogic.GetScannerConfigFileRpc) */ {
 public:
  GetScannerConfigFileRpc();
  virtual ~GetScannerConfigFileRpc();

  GetScannerConfigFileRpc(const GetScannerConfigFileRpc& from);

  inline GetScannerConfigFileRpc& operator=(const GetScannerConfigFileRpc& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetScannerConfigFileRpc& default_instance();

  void Swap(GetScannerConfigFileRpc* other);

  // implements Message ----------------------------------------------

  inline GetScannerConfigFileRpc* New() const { return New(NULL); }

  GetScannerConfigFileRpc* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetScannerConfigFileRpc& from);
  void MergeFrom(const GetScannerConfigFileRpc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetScannerConfigFileRpc* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string file_path = 1;
  void clear_file_path();
  static const int kFilePathFieldNumber = 1;
  const ::std::string& file_path() const;
  void set_file_path(const ::std::string& value);
  void set_file_path(const char* value);
  void set_file_path(const char* value, size_t size);
  ::std::string* mutable_file_path();
  ::std::string* release_file_path();
  void set_allocated_file_path(::std::string* file_path);

  // @@protoc_insertion_point(class_scope:analogic.GetScannerConfigFileRpc)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr file_path_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_proto_2fCalService_2eproto();
  friend void protobuf_AssignDesc_proto_2fCalService_2eproto();
  friend void protobuf_ShutdownFile_proto_2fCalService_2eproto();

  void InitAsDefaultInstance();
  static GetScannerConfigFileRpc* default_instance_;
};
// -------------------------------------------------------------------

class UpdateScannerConfigFileRpc : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:analogic.UpdateScannerConfigFileRpc) */ {
 public:
  UpdateScannerConfigFileRpc();
  virtual ~UpdateScannerConfigFileRpc();

  UpdateScannerConfigFileRpc(const UpdateScannerConfigFileRpc& from);

  inline UpdateScannerConfigFileRpc& operator=(const UpdateScannerConfigFileRpc& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateScannerConfigFileRpc& default_instance();

  void Swap(UpdateScannerConfigFileRpc* other);

  // implements Message ----------------------------------------------

  inline UpdateScannerConfigFileRpc* New() const { return New(NULL); }

  UpdateScannerConfigFileRpc* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdateScannerConfigFileRpc& from);
  void MergeFrom(const UpdateScannerConfigFileRpc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UpdateScannerConfigFileRpc* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string content = 1;
  void clear_content();
  static const int kContentFieldNumber = 1;
  const ::std::string& content() const;
  void set_content(const ::std::string& value);
  void set_content(const char* value);
  void set_content(const char* value, size_t size);
  ::std::string* mutable_content();
  ::std::string* release_content();
  void set_allocated_content(::std::string* content);

  // @@protoc_insertion_point(class_scope:analogic.UpdateScannerConfigFileRpc)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr content_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_proto_2fCalService_2eproto();
  friend void protobuf_AssignDesc_proto_2fCalService_2eproto();
  friend void protobuf_ShutdownFile_proto_2fCalService_2eproto();

  void InitAsDefaultInstance();
  static UpdateScannerConfigFileRpc* default_instance_;
};
// -------------------------------------------------------------------

class SdswStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:analogic.SdswStatus) */ {
 public:
  SdswStatus();
  virtual ~SdswStatus();

  SdswStatus(const SdswStatus& from);

  inline SdswStatus& operator=(const SdswStatus& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SdswStatus& default_instance();

  void Swap(SdswStatus* other);

  // implements Message ----------------------------------------------

  inline SdswStatus* New() const { return New(NULL); }

  SdswStatus* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SdswStatus& from);
  void MergeFrom(const SdswStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SdswStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef SdswStatus_AIR_CAL_STATE AIR_CAL_STATE;
  static const AIR_CAL_STATE AIR_CAL_IDLE =
    SdswStatus_AIR_CAL_STATE_AIR_CAL_IDLE;
  static inline bool AIR_CAL_STATE_IsValid(int value) {
    return SdswStatus_AIR_CAL_STATE_IsValid(value);
  }
  static const AIR_CAL_STATE AIR_CAL_STATE_MIN =
    SdswStatus_AIR_CAL_STATE_AIR_CAL_STATE_MIN;
  static const AIR_CAL_STATE AIR_CAL_STATE_MAX =
    SdswStatus_AIR_CAL_STATE_AIR_CAL_STATE_MAX;
  static const int AIR_CAL_STATE_ARRAYSIZE =
    SdswStatus_AIR_CAL_STATE_AIR_CAL_STATE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  AIR_CAL_STATE_descriptor() {
    return SdswStatus_AIR_CAL_STATE_descriptor();
  }
  static inline const ::std::string& AIR_CAL_STATE_Name(AIR_CAL_STATE value) {
    return SdswStatus_AIR_CAL_STATE_Name(value);
  }
  static inline bool AIR_CAL_STATE_Parse(const ::std::string& name,
      AIR_CAL_STATE* value) {
    return SdswStatus_AIR_CAL_STATE_Parse(name, value);
  }

  typedef SdswStatus_OFFSET_CAL_STATE OFFSET_CAL_STATE;
  static const OFFSET_CAL_STATE OFFSET_CAL_IDLE =
    SdswStatus_OFFSET_CAL_STATE_OFFSET_CAL_IDLE;
  static inline bool OFFSET_CAL_STATE_IsValid(int value) {
    return SdswStatus_OFFSET_CAL_STATE_IsValid(value);
  }
  static const OFFSET_CAL_STATE OFFSET_CAL_STATE_MIN =
    SdswStatus_OFFSET_CAL_STATE_OFFSET_CAL_STATE_MIN;
  static const OFFSET_CAL_STATE OFFSET_CAL_STATE_MAX =
    SdswStatus_OFFSET_CAL_STATE_OFFSET_CAL_STATE_MAX;
  static const int OFFSET_CAL_STATE_ARRAYSIZE =
    SdswStatus_OFFSET_CAL_STATE_OFFSET_CAL_STATE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  OFFSET_CAL_STATE_descriptor() {
    return SdswStatus_OFFSET_CAL_STATE_descriptor();
  }
  static inline const ::std::string& OFFSET_CAL_STATE_Name(OFFSET_CAL_STATE value) {
    return SdswStatus_OFFSET_CAL_STATE_Name(value);
  }
  static inline bool OFFSET_CAL_STATE_Parse(const ::std::string& name,
      OFFSET_CAL_STATE* value) {
    return SdswStatus_OFFSET_CAL_STATE_Parse(name, value);
  }

  typedef SdswStatus_PIN_CAL_STATE PIN_CAL_STATE;
  static const PIN_CAL_STATE PIN_CAL_IDLE =
    SdswStatus_PIN_CAL_STATE_PIN_CAL_IDLE;
  static inline bool PIN_CAL_STATE_IsValid(int value) {
    return SdswStatus_PIN_CAL_STATE_IsValid(value);
  }
  static const PIN_CAL_STATE PIN_CAL_STATE_MIN =
    SdswStatus_PIN_CAL_STATE_PIN_CAL_STATE_MIN;
  static const PIN_CAL_STATE PIN_CAL_STATE_MAX =
    SdswStatus_PIN_CAL_STATE_PIN_CAL_STATE_MAX;
  static const int PIN_CAL_STATE_ARRAYSIZE =
    SdswStatus_PIN_CAL_STATE_PIN_CAL_STATE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PIN_CAL_STATE_descriptor() {
    return SdswStatus_PIN_CAL_STATE_descriptor();
  }
  static inline const ::std::string& PIN_CAL_STATE_Name(PIN_CAL_STATE value) {
    return SdswStatus_PIN_CAL_STATE_Name(value);
  }
  static inline bool PIN_CAL_STATE_Parse(const ::std::string& name,
      PIN_CAL_STATE* value) {
    return SdswStatus_PIN_CAL_STATE_Parse(name, value);
  }

  typedef SdswStatus_BELT_HEIGHT_CAL_STATE BELT_HEIGHT_CAL_STATE;
  static const BELT_HEIGHT_CAL_STATE BELT_HEIGHT_IDLE =
    SdswStatus_BELT_HEIGHT_CAL_STATE_BELT_HEIGHT_IDLE;
  static inline bool BELT_HEIGHT_CAL_STATE_IsValid(int value) {
    return SdswStatus_BELT_HEIGHT_CAL_STATE_IsValid(value);
  }
  static const BELT_HEIGHT_CAL_STATE BELT_HEIGHT_CAL_STATE_MIN =
    SdswStatus_BELT_HEIGHT_CAL_STATE_BELT_HEIGHT_CAL_STATE_MIN;
  static const BELT_HEIGHT_CAL_STATE BELT_HEIGHT_CAL_STATE_MAX =
    SdswStatus_BELT_HEIGHT_CAL_STATE_BELT_HEIGHT_CAL_STATE_MAX;
  static const int BELT_HEIGHT_CAL_STATE_ARRAYSIZE =
    SdswStatus_BELT_HEIGHT_CAL_STATE_BELT_HEIGHT_CAL_STATE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  BELT_HEIGHT_CAL_STATE_descriptor() {
    return SdswStatus_BELT_HEIGHT_CAL_STATE_descriptor();
  }
  static inline const ::std::string& BELT_HEIGHT_CAL_STATE_Name(BELT_HEIGHT_CAL_STATE value) {
    return SdswStatus_BELT_HEIGHT_CAL_STATE_Name(value);
  }
  static inline bool BELT_HEIGHT_CAL_STATE_Parse(const ::std::string& name,
      BELT_HEIGHT_CAL_STATE* value) {
    return SdswStatus_BELT_HEIGHT_CAL_STATE_Parse(name, value);
  }

  typedef SdswStatus_SPECTRAL_CAL_STATE SPECTRAL_CAL_STATE;
  static const SPECTRAL_CAL_STATE SPECTRAL_CAL_IDLE =
    SdswStatus_SPECTRAL_CAL_STATE_SPECTRAL_CAL_IDLE;
  static inline bool SPECTRAL_CAL_STATE_IsValid(int value) {
    return SdswStatus_SPECTRAL_CAL_STATE_IsValid(value);
  }
  static const SPECTRAL_CAL_STATE SPECTRAL_CAL_STATE_MIN =
    SdswStatus_SPECTRAL_CAL_STATE_SPECTRAL_CAL_STATE_MIN;
  static const SPECTRAL_CAL_STATE SPECTRAL_CAL_STATE_MAX =
    SdswStatus_SPECTRAL_CAL_STATE_SPECTRAL_CAL_STATE_MAX;
  static const int SPECTRAL_CAL_STATE_ARRAYSIZE =
    SdswStatus_SPECTRAL_CAL_STATE_SPECTRAL_CAL_STATE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SPECTRAL_CAL_STATE_descriptor() {
    return SdswStatus_SPECTRAL_CAL_STATE_descriptor();
  }
  static inline const ::std::string& SPECTRAL_CAL_STATE_Name(SPECTRAL_CAL_STATE value) {
    return SdswStatus_SPECTRAL_CAL_STATE_Name(value);
  }
  static inline bool SPECTRAL_CAL_STATE_Parse(const ::std::string& name,
      SPECTRAL_CAL_STATE* value) {
    return SdswStatus_SPECTRAL_CAL_STATE_Parse(name, value);
  }

  typedef SdswStatus_RADIATION_SURVEY_STATE RADIATION_SURVEY_STATE;
  static const RADIATION_SURVEY_STATE RADIATION_SURVEY_IDLE =
    SdswStatus_RADIATION_SURVEY_STATE_RADIATION_SURVEY_IDLE;
  static const RADIATION_SURVEY_STATE RADIATION_SURVEY_GO_TO_SCAN =
    SdswStatus_RADIATION_SURVEY_STATE_RADIATION_SURVEY_GO_TO_SCAN;
  static const RADIATION_SURVEY_STATE RADIATION_SURVEY_WAITING_FOR_BAG_TO_BE_PLACED =
    SdswStatus_RADIATION_SURVEY_STATE_RADIATION_SURVEY_WAITING_FOR_BAG_TO_BE_PLACED;
  static const RADIATION_SURVEY_STATE RADIATION_SURVEY_WAITING_FOR_BAG_IN_POSITION =
    SdswStatus_RADIATION_SURVEY_STATE_RADIATION_SURVEY_WAITING_FOR_BAG_IN_POSITION;
  static const RADIATION_SURVEY_STATE RADIATION_SURVEY_READY =
    SdswStatus_RADIATION_SURVEY_STATE_RADIATION_SURVEY_READY;
  static const RADIATION_SURVEY_STATE RADIATION_SURVEY_ERROR =
    SdswStatus_RADIATION_SURVEY_STATE_RADIATION_SURVEY_ERROR;
  static inline bool RADIATION_SURVEY_STATE_IsValid(int value) {
    return SdswStatus_RADIATION_SURVEY_STATE_IsValid(value);
  }
  static const RADIATION_SURVEY_STATE RADIATION_SURVEY_STATE_MIN =
    SdswStatus_RADIATION_SURVEY_STATE_RADIATION_SURVEY_STATE_MIN;
  static const RADIATION_SURVEY_STATE RADIATION_SURVEY_STATE_MAX =
    SdswStatus_RADIATION_SURVEY_STATE_RADIATION_SURVEY_STATE_MAX;
  static const int RADIATION_SURVEY_STATE_ARRAYSIZE =
    SdswStatus_RADIATION_SURVEY_STATE_RADIATION_SURVEY_STATE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RADIATION_SURVEY_STATE_descriptor() {
    return SdswStatus_RADIATION_SURVEY_STATE_descriptor();
  }
  static inline const ::std::string& RADIATION_SURVEY_STATE_Name(RADIATION_SURVEY_STATE value) {
    return SdswStatus_RADIATION_SURVEY_STATE_Name(value);
  }
  static inline bool RADIATION_SURVEY_STATE_Parse(const ::std::string& name,
      RADIATION_SURVEY_STATE* value) {
    return SdswStatus_RADIATION_SURVEY_STATE_Parse(name, value);
  }

  typedef SdswStatus_RADIATION_SURVEY_CANCEL_STATE RADIATION_SURVEY_CANCEL_STATE;
  static const RADIATION_SURVEY_CANCEL_STATE RADIATION_SURVEY_CANCEL_IDLE =
    SdswStatus_RADIATION_SURVEY_CANCEL_STATE_RADIATION_SURVEY_CANCEL_IDLE;
  static const RADIATION_SURVEY_CANCEL_STATE RADIATION_SURVEY_CANCEL_XRAY_OFF =
    SdswStatus_RADIATION_SURVEY_CANCEL_STATE_RADIATION_SURVEY_CANCEL_XRAY_OFF;
  static const RADIATION_SURVEY_CANCEL_STATE RADIATION_SURVEY_CANCEL_CONVEYOR_RUN =
    SdswStatus_RADIATION_SURVEY_CANCEL_STATE_RADIATION_SURVEY_CANCEL_CONVEYOR_RUN;
  static const RADIATION_SURVEY_CANCEL_STATE RADIATION_SURVEY_CANCEL_COMPLETE =
    SdswStatus_RADIATION_SURVEY_CANCEL_STATE_RADIATION_SURVEY_CANCEL_COMPLETE;
  static const RADIATION_SURVEY_CANCEL_STATE RADIATION_SURVEY_CANCEL_ERROR =
    SdswStatus_RADIATION_SURVEY_CANCEL_STATE_RADIATION_SURVEY_CANCEL_ERROR;
  static inline bool RADIATION_SURVEY_CANCEL_STATE_IsValid(int value) {
    return SdswStatus_RADIATION_SURVEY_CANCEL_STATE_IsValid(value);
  }
  static const RADIATION_SURVEY_CANCEL_STATE RADIATION_SURVEY_CANCEL_STATE_MIN =
    SdswStatus_RADIATION_SURVEY_CANCEL_STATE_RADIATION_SURVEY_CANCEL_STATE_MIN;
  static const RADIATION_SURVEY_CANCEL_STATE RADIATION_SURVEY_CANCEL_STATE_MAX =
    SdswStatus_RADIATION_SURVEY_CANCEL_STATE_RADIATION_SURVEY_CANCEL_STATE_MAX;
  static const int RADIATION_SURVEY_CANCEL_STATE_ARRAYSIZE =
    SdswStatus_RADIATION_SURVEY_CANCEL_STATE_RADIATION_SURVEY_CANCEL_STATE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RADIATION_SURVEY_CANCEL_STATE_descriptor() {
    return SdswStatus_RADIATION_SURVEY_CANCEL_STATE_descriptor();
  }
  static inline const ::std::string& RADIATION_SURVEY_CANCEL_STATE_Name(RADIATION_SURVEY_CANCEL_STATE value) {
    return SdswStatus_RADIATION_SURVEY_CANCEL_STATE_Name(value);
  }
  static inline bool RADIATION_SURVEY_CANCEL_STATE_Parse(const ::std::string& name,
      RADIATION_SURVEY_CANCEL_STATE* value) {
    return SdswStatus_RADIATION_SURVEY_CANCEL_STATE_Parse(name, value);
  }

  typedef SdswStatus_IMAGE_QUALITY_STATE IMAGE_QUALITY_STATE;
  static const IMAGE_QUALITY_STATE IMAGE_QUALITY_IDLE =
    SdswStatus_IMAGE_QUALITY_STATE_IMAGE_QUALITY_IDLE;
  static const IMAGE_QUALITY_STATE IMAGE_QUALITY_GO_TO_SCAN =
    SdswStatus_IMAGE_QUALITY_STATE_IMAGE_QUALITY_GO_TO_SCAN;
  static const IMAGE_QUALITY_STATE IMAGE_QUALITY_PROCESSING =
    SdswStatus_IMAGE_QUALITY_STATE_IMAGE_QUALITY_PROCESSING;
  static const IMAGE_QUALITY_STATE IMAGE_QUALITY_PROCESSED =
    SdswStatus_IMAGE_QUALITY_STATE_IMAGE_QUALITY_PROCESSED;
  static const IMAGE_QUALITY_STATE IMAGE_QUALITY_CONVEYOR_FLUSH =
    SdswStatus_IMAGE_QUALITY_STATE_IMAGE_QUALITY_CONVEYOR_FLUSH;
  static const IMAGE_QUALITY_STATE IMAGE_QUALITY_XRAYS_OFF =
    SdswStatus_IMAGE_QUALITY_STATE_IMAGE_QUALITY_XRAYS_OFF;
  static const IMAGE_QUALITY_STATE IMAGE_QUALITY_COMPLETE =
    SdswStatus_IMAGE_QUALITY_STATE_IMAGE_QUALITY_COMPLETE;
  static const IMAGE_QUALITY_STATE IMAGE_QUALITY_ERROR =
    SdswStatus_IMAGE_QUALITY_STATE_IMAGE_QUALITY_ERROR;
  static inline bool IMAGE_QUALITY_STATE_IsValid(int value) {
    return SdswStatus_IMAGE_QUALITY_STATE_IsValid(value);
  }
  static const IMAGE_QUALITY_STATE IMAGE_QUALITY_STATE_MIN =
    SdswStatus_IMAGE_QUALITY_STATE_IMAGE_QUALITY_STATE_MIN;
  static const IMAGE_QUALITY_STATE IMAGE_QUALITY_STATE_MAX =
    SdswStatus_IMAGE_QUALITY_STATE_IMAGE_QUALITY_STATE_MAX;
  static const int IMAGE_QUALITY_STATE_ARRAYSIZE =
    SdswStatus_IMAGE_QUALITY_STATE_IMAGE_QUALITY_STATE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  IMAGE_QUALITY_STATE_descriptor() {
    return SdswStatus_IMAGE_QUALITY_STATE_descriptor();
  }
  static inline const ::std::string& IMAGE_QUALITY_STATE_Name(IMAGE_QUALITY_STATE value) {
    return SdswStatus_IMAGE_QUALITY_STATE_Name(value);
  }
  static inline bool IMAGE_QUALITY_STATE_Parse(const ::std::string& name,
      IMAGE_QUALITY_STATE* value) {
    return SdswStatus_IMAGE_QUALITY_STATE_Parse(name, value);
  }

  typedef SdswStatus_IMAGE_QUALITY_CANCEL_STATE IMAGE_QUALITY_CANCEL_STATE;
  static const IMAGE_QUALITY_CANCEL_STATE IMAGE_QUALITY_CANCEL_XRAY_OFF =
    SdswStatus_IMAGE_QUALITY_CANCEL_STATE_IMAGE_QUALITY_CANCEL_XRAY_OFF;
  static const IMAGE_QUALITY_CANCEL_STATE IMAGE_QUALITY_CANCEL_CONVEYOR_STOP =
    SdswStatus_IMAGE_QUALITY_CANCEL_STATE_IMAGE_QUALITY_CANCEL_CONVEYOR_STOP;
  static const IMAGE_QUALITY_CANCEL_STATE IMAGE_QUALITY_CANCEL_ERROR =
    SdswStatus_IMAGE_QUALITY_CANCEL_STATE_IMAGE_QUALITY_CANCEL_ERROR;
  static inline bool IMAGE_QUALITY_CANCEL_STATE_IsValid(int value) {
    return SdswStatus_IMAGE_QUALITY_CANCEL_STATE_IsValid(value);
  }
  static const IMAGE_QUALITY_CANCEL_STATE IMAGE_QUALITY_CANCEL_STATE_MIN =
    SdswStatus_IMAGE_QUALITY_CANCEL_STATE_IMAGE_QUALITY_CANCEL_STATE_MIN;
  static const IMAGE_QUALITY_CANCEL_STATE IMAGE_QUALITY_CANCEL_STATE_MAX =
    SdswStatus_IMAGE_QUALITY_CANCEL_STATE_IMAGE_QUALITY_CANCEL_STATE_MAX;
  static const int IMAGE_QUALITY_CANCEL_STATE_ARRAYSIZE =
    SdswStatus_IMAGE_QUALITY_CANCEL_STATE_IMAGE_QUALITY_CANCEL_STATE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  IMAGE_QUALITY_CANCEL_STATE_descriptor() {
    return SdswStatus_IMAGE_QUALITY_CANCEL_STATE_descriptor();
  }
  static inline const ::std::string& IMAGE_QUALITY_CANCEL_STATE_Name(IMAGE_QUALITY_CANCEL_STATE value) {
    return SdswStatus_IMAGE_QUALITY_CANCEL_STATE_Name(value);
  }
  static inline bool IMAGE_QUALITY_CANCEL_STATE_Parse(const ::std::string& name,
      IMAGE_QUALITY_CANCEL_STATE* value) {
    return SdswStatus_IMAGE_QUALITY_CANCEL_STATE_Parse(name, value);
  }

  typedef SdswStatus_BASE_SEQ_1_STATE BASE_SEQ_1_STATE;
  static const BASE_SEQ_1_STATE BASE_SEQ_1_IDLE =
    SdswStatus_BASE_SEQ_1_STATE_BASE_SEQ_1_IDLE;
  static const BASE_SEQ_1_STATE BASE_SEQ_1_GANTRY_STARTUP =
    SdswStatus_BASE_SEQ_1_STATE_BASE_SEQ_1_GANTRY_STARTUP;
  static const BASE_SEQ_1_STATE BASE_SEQ_1_XRAY_STARTUP =
    SdswStatus_BASE_SEQ_1_STATE_BASE_SEQ_1_XRAY_STARTUP;
  static const BASE_SEQ_1_STATE BASE_SEQ_1_CONVEYOR_CONTROL =
    SdswStatus_BASE_SEQ_1_STATE_BASE_SEQ_1_CONVEYOR_CONTROL;
  static const BASE_SEQ_1_STATE BASE_SEQ_1_PROCESSING =
    SdswStatus_BASE_SEQ_1_STATE_BASE_SEQ_1_PROCESSING;
  static const BASE_SEQ_1_STATE BASE_SEQ_1_PROCESSED =
    SdswStatus_BASE_SEQ_1_STATE_BASE_SEQ_1_PROCESSED;
  static const BASE_SEQ_1_STATE BASE_SEQ_1_ERROR =
    SdswStatus_BASE_SEQ_1_STATE_BASE_SEQ_1_ERROR;
  static inline bool BASE_SEQ_1_STATE_IsValid(int value) {
    return SdswStatus_BASE_SEQ_1_STATE_IsValid(value);
  }
  static const BASE_SEQ_1_STATE BASE_SEQ_1_STATE_MIN =
    SdswStatus_BASE_SEQ_1_STATE_BASE_SEQ_1_STATE_MIN;
  static const BASE_SEQ_1_STATE BASE_SEQ_1_STATE_MAX =
    SdswStatus_BASE_SEQ_1_STATE_BASE_SEQ_1_STATE_MAX;
  static const int BASE_SEQ_1_STATE_ARRAYSIZE =
    SdswStatus_BASE_SEQ_1_STATE_BASE_SEQ_1_STATE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  BASE_SEQ_1_STATE_descriptor() {
    return SdswStatus_BASE_SEQ_1_STATE_descriptor();
  }
  static inline const ::std::string& BASE_SEQ_1_STATE_Name(BASE_SEQ_1_STATE value) {
    return SdswStatus_BASE_SEQ_1_STATE_Name(value);
  }
  static inline bool BASE_SEQ_1_STATE_Parse(const ::std::string& name,
      BASE_SEQ_1_STATE* value) {
    return SdswStatus_BASE_SEQ_1_STATE_Parse(name, value);
  }

  typedef SdswStatus_ZEE_PIN_SPECTRAL_CAL_STATE ZEE_PIN_SPECTRAL_CAL_STATE;
  static const ZEE_PIN_SPECTRAL_CAL_STATE ZEE_PIN_SPECTRAL_CAL_CLEAR_ERROR =
    SdswStatus_ZEE_PIN_SPECTRAL_CAL_STATE_ZEE_PIN_SPECTRAL_CAL_CLEAR_ERROR;
  static const ZEE_PIN_SPECTRAL_CAL_STATE ZEE_PIN_SPECTRAL_CAL_GANTRY_ON =
    SdswStatus_ZEE_PIN_SPECTRAL_CAL_STATE_ZEE_PIN_SPECTRAL_CAL_GANTRY_ON;
  static const ZEE_PIN_SPECTRAL_CAL_STATE ZEE_PIN_SPECTRAL_CAL_CONVEYOR_STOP =
    SdswStatus_ZEE_PIN_SPECTRAL_CAL_STATE_ZEE_PIN_SPECTRAL_CAL_CONVEYOR_STOP;
  static const ZEE_PIN_SPECTRAL_CAL_STATE ZEE_PIN_SPECTRAL_CAL_XRAY_OFF_1 =
    SdswStatus_ZEE_PIN_SPECTRAL_CAL_STATE_ZEE_PIN_SPECTRAL_CAL_XRAY_OFF_1;
  static const ZEE_PIN_SPECTRAL_CAL_STATE ZEE_PIN_SPECTRAL_CAL_RAW_DATA_COLLECT_1 =
    SdswStatus_ZEE_PIN_SPECTRAL_CAL_STATE_ZEE_PIN_SPECTRAL_CAL_RAW_DATA_COLLECT_1;
  static const ZEE_PIN_SPECTRAL_CAL_STATE ZEE_PIN_SPECTRAL_CAL_XRAY_ON_1 =
    SdswStatus_ZEE_PIN_SPECTRAL_CAL_STATE_ZEE_PIN_SPECTRAL_CAL_XRAY_ON_1;
  static const ZEE_PIN_SPECTRAL_CAL_STATE ZEE_PIN_SPECTRAL_CAL_RAW_DATA_COLLECT_2 =
    SdswStatus_ZEE_PIN_SPECTRAL_CAL_STATE_ZEE_PIN_SPECTRAL_CAL_RAW_DATA_COLLECT_2;
  static const ZEE_PIN_SPECTRAL_CAL_STATE ZEE_PIN_SPECTRAL_CAL_XRAY_OFF_2 =
    SdswStatus_ZEE_PIN_SPECTRAL_CAL_STATE_ZEE_PIN_SPECTRAL_CAL_XRAY_OFF_2;
  static const ZEE_PIN_SPECTRAL_CAL_STATE ZEE_PIN_SPECTRAL_CAL_WAIT_FOR_PLACEMENT =
    SdswStatus_ZEE_PIN_SPECTRAL_CAL_STATE_ZEE_PIN_SPECTRAL_CAL_WAIT_FOR_PLACEMENT;
  static const ZEE_PIN_SPECTRAL_CAL_STATE ZEE_PIN_SPECTRAL_CAL_XRAY_ON_2 =
    SdswStatus_ZEE_PIN_SPECTRAL_CAL_STATE_ZEE_PIN_SPECTRAL_CAL_XRAY_ON_2;
  static const ZEE_PIN_SPECTRAL_CAL_STATE ZEE_PIN_SPECTRAL_CAL_RAW_DATA_COLLECT_3 =
    SdswStatus_ZEE_PIN_SPECTRAL_CAL_STATE_ZEE_PIN_SPECTRAL_CAL_RAW_DATA_COLLECT_3;
  static const ZEE_PIN_SPECTRAL_CAL_STATE ZEE_PIN_SPECTRAL_CAL_ANALYZE =
    SdswStatus_ZEE_PIN_SPECTRAL_CAL_STATE_ZEE_PIN_SPECTRAL_CAL_ANALYZE;
  static const ZEE_PIN_SPECTRAL_CAL_STATE ZEE_PIN_SPECTRAL_CAL_COMPLETE =
    SdswStatus_ZEE_PIN_SPECTRAL_CAL_STATE_ZEE_PIN_SPECTRAL_CAL_COMPLETE;
  static const ZEE_PIN_SPECTRAL_CAL_STATE ZEE_PIN_SPECTRAL_CAL_ERROR =
    SdswStatus_ZEE_PIN_SPECTRAL_CAL_STATE_ZEE_PIN_SPECTRAL_CAL_ERROR;
  static inline bool ZEE_PIN_SPECTRAL_CAL_STATE_IsValid(int value) {
    return SdswStatus_ZEE_PIN_SPECTRAL_CAL_STATE_IsValid(value);
  }
  static const ZEE_PIN_SPECTRAL_CAL_STATE ZEE_PIN_SPECTRAL_CAL_STATE_MIN =
    SdswStatus_ZEE_PIN_SPECTRAL_CAL_STATE_ZEE_PIN_SPECTRAL_CAL_STATE_MIN;
  static const ZEE_PIN_SPECTRAL_CAL_STATE ZEE_PIN_SPECTRAL_CAL_STATE_MAX =
    SdswStatus_ZEE_PIN_SPECTRAL_CAL_STATE_ZEE_PIN_SPECTRAL_CAL_STATE_MAX;
  static const int ZEE_PIN_SPECTRAL_CAL_STATE_ARRAYSIZE =
    SdswStatus_ZEE_PIN_SPECTRAL_CAL_STATE_ZEE_PIN_SPECTRAL_CAL_STATE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ZEE_PIN_SPECTRAL_CAL_STATE_descriptor() {
    return SdswStatus_ZEE_PIN_SPECTRAL_CAL_STATE_descriptor();
  }
  static inline const ::std::string& ZEE_PIN_SPECTRAL_CAL_STATE_Name(ZEE_PIN_SPECTRAL_CAL_STATE value) {
    return SdswStatus_ZEE_PIN_SPECTRAL_CAL_STATE_Name(value);
  }
  static inline bool ZEE_PIN_SPECTRAL_CAL_STATE_Parse(const ::std::string& name,
      ZEE_PIN_SPECTRAL_CAL_STATE* value) {
    return SdswStatus_ZEE_PIN_SPECTRAL_CAL_STATE_Parse(name, value);
  }

  typedef SdswStatus_CONV_STOP_XRAY_MIN_STATE CONV_STOP_XRAY_MIN_STATE;
  static const CONV_STOP_XRAY_MIN_STATE CONV_STOP_XRAY_MIN_CONVEYOR_STOP =
    SdswStatus_CONV_STOP_XRAY_MIN_STATE_CONV_STOP_XRAY_MIN_CONVEYOR_STOP;
  static const CONV_STOP_XRAY_MIN_STATE CONV_STOP_XRAY_MIN_XRAY_MINIMIZE =
    SdswStatus_CONV_STOP_XRAY_MIN_STATE_CONV_STOP_XRAY_MIN_XRAY_MINIMIZE;
  static const CONV_STOP_XRAY_MIN_STATE CONV_STOP_XRAY_MIN_COMPLETE =
    SdswStatus_CONV_STOP_XRAY_MIN_STATE_CONV_STOP_XRAY_MIN_COMPLETE;
  static const CONV_STOP_XRAY_MIN_STATE CONV_STOP_XRAY_MIN_ERROR =
    SdswStatus_CONV_STOP_XRAY_MIN_STATE_CONV_STOP_XRAY_MIN_ERROR;
  static inline bool CONV_STOP_XRAY_MIN_STATE_IsValid(int value) {
    return SdswStatus_CONV_STOP_XRAY_MIN_STATE_IsValid(value);
  }
  static const CONV_STOP_XRAY_MIN_STATE CONV_STOP_XRAY_MIN_STATE_MIN =
    SdswStatus_CONV_STOP_XRAY_MIN_STATE_CONV_STOP_XRAY_MIN_STATE_MIN;
  static const CONV_STOP_XRAY_MIN_STATE CONV_STOP_XRAY_MIN_STATE_MAX =
    SdswStatus_CONV_STOP_XRAY_MIN_STATE_CONV_STOP_XRAY_MIN_STATE_MAX;
  static const int CONV_STOP_XRAY_MIN_STATE_ARRAYSIZE =
    SdswStatus_CONV_STOP_XRAY_MIN_STATE_CONV_STOP_XRAY_MIN_STATE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CONV_STOP_XRAY_MIN_STATE_descriptor() {
    return SdswStatus_CONV_STOP_XRAY_MIN_STATE_descriptor();
  }
  static inline const ::std::string& CONV_STOP_XRAY_MIN_STATE_Name(CONV_STOP_XRAY_MIN_STATE value) {
    return SdswStatus_CONV_STOP_XRAY_MIN_STATE_Name(value);
  }
  static inline bool CONV_STOP_XRAY_MIN_STATE_Parse(const ::std::string& name,
      CONV_STOP_XRAY_MIN_STATE* value) {
    return SdswStatus_CONV_STOP_XRAY_MIN_STATE_Parse(name, value);
  }

  typedef SdswStatus_XMAX_CONVEYOR_RUN_STATE XMAX_CONVEYOR_RUN_STATE;
  static const XMAX_CONVEYOR_RUN_STATE XRAY_MAX_CONV_RUN_XRAY_MAXIMIZE =
    SdswStatus_XMAX_CONVEYOR_RUN_STATE_XRAY_MAX_CONV_RUN_XRAY_MAXIMIZE;
  static const XMAX_CONVEYOR_RUN_STATE XRAY_MAX_CONV_RUN_CONVEYOR_RUN =
    SdswStatus_XMAX_CONVEYOR_RUN_STATE_XRAY_MAX_CONV_RUN_CONVEYOR_RUN;
  static const XMAX_CONVEYOR_RUN_STATE XRAY_MAX_CONV_RUN_COMPLETE =
    SdswStatus_XMAX_CONVEYOR_RUN_STATE_XRAY_MAX_CONV_RUN_COMPLETE;
  static const XMAX_CONVEYOR_RUN_STATE XRAY_MAX_CONV_RUN_ERROR =
    SdswStatus_XMAX_CONVEYOR_RUN_STATE_XRAY_MAX_CONV_RUN_ERROR;
  static inline bool XMAX_CONVEYOR_RUN_STATE_IsValid(int value) {
    return SdswStatus_XMAX_CONVEYOR_RUN_STATE_IsValid(value);
  }
  static const XMAX_CONVEYOR_RUN_STATE XMAX_CONVEYOR_RUN_STATE_MIN =
    SdswStatus_XMAX_CONVEYOR_RUN_STATE_XMAX_CONVEYOR_RUN_STATE_MIN;
  static const XMAX_CONVEYOR_RUN_STATE XMAX_CONVEYOR_RUN_STATE_MAX =
    SdswStatus_XMAX_CONVEYOR_RUN_STATE_XMAX_CONVEYOR_RUN_STATE_MAX;
  static const int XMAX_CONVEYOR_RUN_STATE_ARRAYSIZE =
    SdswStatus_XMAX_CONVEYOR_RUN_STATE_XMAX_CONVEYOR_RUN_STATE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  XMAX_CONVEYOR_RUN_STATE_descriptor() {
    return SdswStatus_XMAX_CONVEYOR_RUN_STATE_descriptor();
  }
  static inline const ::std::string& XMAX_CONVEYOR_RUN_STATE_Name(XMAX_CONVEYOR_RUN_STATE value) {
    return SdswStatus_XMAX_CONVEYOR_RUN_STATE_Name(value);
  }
  static inline bool XMAX_CONVEYOR_RUN_STATE_Parse(const ::std::string& name,
      XMAX_CONVEYOR_RUN_STATE* value) {
    return SdswStatus_XMAX_CONVEYOR_RUN_STATE_Parse(name, value);
  }

  typedef SdswStatus_CONV_STOP_XRAY_MIN_STATE_CONV_RUN CONV_STOP_XRAY_MIN_STATE_CONV_RUN;
  static const CONV_STOP_XRAY_MIN_STATE_CONV_RUN XRAY_MIN_AND_CONV_STOP =
    SdswStatus_CONV_STOP_XRAY_MIN_STATE_CONV_RUN_XRAY_MIN_AND_CONV_STOP;
  static const CONV_STOP_XRAY_MIN_STATE_CONV_RUN CONV_RUN_POST_XRAY_MIN =
    SdswStatus_CONV_STOP_XRAY_MIN_STATE_CONV_RUN_CONV_RUN_POST_XRAY_MIN;
  static const CONV_STOP_XRAY_MIN_STATE_CONV_RUN CONV_STOP_XRAY_MIN_CONV_RUN_COMPLETE =
    SdswStatus_CONV_STOP_XRAY_MIN_STATE_CONV_RUN_CONV_STOP_XRAY_MIN_CONV_RUN_COMPLETE;
  static const CONV_STOP_XRAY_MIN_STATE_CONV_RUN CONV_STOP_XRAY_MIN_CONV_RUN_ERROR =
    SdswStatus_CONV_STOP_XRAY_MIN_STATE_CONV_RUN_CONV_STOP_XRAY_MIN_CONV_RUN_ERROR;
  static inline bool CONV_STOP_XRAY_MIN_STATE_CONV_RUN_IsValid(int value) {
    return SdswStatus_CONV_STOP_XRAY_MIN_STATE_CONV_RUN_IsValid(value);
  }
  static const CONV_STOP_XRAY_MIN_STATE_CONV_RUN CONV_STOP_XRAY_MIN_STATE_CONV_RUN_MIN =
    SdswStatus_CONV_STOP_XRAY_MIN_STATE_CONV_RUN_CONV_STOP_XRAY_MIN_STATE_CONV_RUN_MIN;
  static const CONV_STOP_XRAY_MIN_STATE_CONV_RUN CONV_STOP_XRAY_MIN_STATE_CONV_RUN_MAX =
    SdswStatus_CONV_STOP_XRAY_MIN_STATE_CONV_RUN_CONV_STOP_XRAY_MIN_STATE_CONV_RUN_MAX;
  static const int CONV_STOP_XRAY_MIN_STATE_CONV_RUN_ARRAYSIZE =
    SdswStatus_CONV_STOP_XRAY_MIN_STATE_CONV_RUN_CONV_STOP_XRAY_MIN_STATE_CONV_RUN_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CONV_STOP_XRAY_MIN_STATE_CONV_RUN_descriptor() {
    return SdswStatus_CONV_STOP_XRAY_MIN_STATE_CONV_RUN_descriptor();
  }
  static inline const ::std::string& CONV_STOP_XRAY_MIN_STATE_CONV_RUN_Name(CONV_STOP_XRAY_MIN_STATE_CONV_RUN value) {
    return SdswStatus_CONV_STOP_XRAY_MIN_STATE_CONV_RUN_Name(value);
  }
  static inline bool CONV_STOP_XRAY_MIN_STATE_CONV_RUN_Parse(const ::std::string& name,
      CONV_STOP_XRAY_MIN_STATE_CONV_RUN* value) {
    return SdswStatus_CONV_STOP_XRAY_MIN_STATE_CONV_RUN_Parse(name, value);
  }

  typedef SdswStatus_BELT_TUNNEL_CAL_STATE BELT_TUNNEL_CAL_STATE;
  static const BELT_TUNNEL_CAL_STATE BELT_TUNNEL_CAL_CLEAR_ERROR =
    SdswStatus_BELT_TUNNEL_CAL_STATE_BELT_TUNNEL_CAL_CLEAR_ERROR;
  static const BELT_TUNNEL_CAL_STATE BELT_TUNNEL_CAL_GANTRY_ON =
    SdswStatus_BELT_TUNNEL_CAL_STATE_BELT_TUNNEL_CAL_GANTRY_ON;
  static const BELT_TUNNEL_CAL_STATE BELT_TUNNEL_CAL_CONVEYOR_STOP =
    SdswStatus_BELT_TUNNEL_CAL_STATE_BELT_TUNNEL_CAL_CONVEYOR_STOP;
  static const BELT_TUNNEL_CAL_STATE BELT_TUNNEL_CAL_XRAY_OFF_1 =
    SdswStatus_BELT_TUNNEL_CAL_STATE_BELT_TUNNEL_CAL_XRAY_OFF_1;
  static const BELT_TUNNEL_CAL_STATE BELT_TUNNEL_CAL_RAW_DATA_COLLECT_OFFSET =
    SdswStatus_BELT_TUNNEL_CAL_STATE_BELT_TUNNEL_CAL_RAW_DATA_COLLECT_OFFSET;
  static const BELT_TUNNEL_CAL_STATE BELT_TUNNEL_CAL_XRAY_ON =
    SdswStatus_BELT_TUNNEL_CAL_STATE_BELT_TUNNEL_CAL_XRAY_ON;
  static const BELT_TUNNEL_CAL_STATE BELT_TUNNEL_CAL_RAW_DATA_COLLECT_AIR =
    SdswStatus_BELT_TUNNEL_CAL_STATE_BELT_TUNNEL_CAL_RAW_DATA_COLLECT_AIR;
  static const BELT_TUNNEL_CAL_STATE BELT_TUNNEL_CAL_XRAY_OFF_2 =
    SdswStatus_BELT_TUNNEL_CAL_STATE_BELT_TUNNEL_CAL_XRAY_OFF_2;
  static const BELT_TUNNEL_CAL_STATE BELT_TUNNEL_CAL_ANALYZE =
    SdswStatus_BELT_TUNNEL_CAL_STATE_BELT_TUNNEL_CAL_ANALYZE;
  static const BELT_TUNNEL_CAL_STATE BELT_TUNNEL_CAL_COMPLETE =
    SdswStatus_BELT_TUNNEL_CAL_STATE_BELT_TUNNEL_CAL_COMPLETE;
  static const BELT_TUNNEL_CAL_STATE BELT_TUNNEL_CAL_ERROR =
    SdswStatus_BELT_TUNNEL_CAL_STATE_BELT_TUNNEL_CAL_ERROR;
  static inline bool BELT_TUNNEL_CAL_STATE_IsValid(int value) {
    return SdswStatus_BELT_TUNNEL_CAL_STATE_IsValid(value);
  }
  static const BELT_TUNNEL_CAL_STATE BELT_TUNNEL_CAL_STATE_MIN =
    SdswStatus_BELT_TUNNEL_CAL_STATE_BELT_TUNNEL_CAL_STATE_MIN;
  static const BELT_TUNNEL_CAL_STATE BELT_TUNNEL_CAL_STATE_MAX =
    SdswStatus_BELT_TUNNEL_CAL_STATE_BELT_TUNNEL_CAL_STATE_MAX;
  static const int BELT_TUNNEL_CAL_STATE_ARRAYSIZE =
    SdswStatus_BELT_TUNNEL_CAL_STATE_BELT_TUNNEL_CAL_STATE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  BELT_TUNNEL_CAL_STATE_descriptor() {
    return SdswStatus_BELT_TUNNEL_CAL_STATE_descriptor();
  }
  static inline const ::std::string& BELT_TUNNEL_CAL_STATE_Name(BELT_TUNNEL_CAL_STATE value) {
    return SdswStatus_BELT_TUNNEL_CAL_STATE_Name(value);
  }
  static inline bool BELT_TUNNEL_CAL_STATE_Parse(const ::std::string& name,
      BELT_TUNNEL_CAL_STATE* value) {
    return SdswStatus_BELT_TUNNEL_CAL_STATE_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .analogic.ancp00.ScannerControlRpcSeq.SCANNER_CONTROL_RPC_SEQ_ID id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::analogic::ancp00::ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID id() const;
  void set_id(::analogic::ancp00::ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID value);

  // optional uint32 current_step = 2;
  void clear_current_step();
  static const int kCurrentStepFieldNumber = 2;
  ::google::protobuf::uint32 current_step() const;
  void set_current_step(::google::protobuf::uint32 value);

  // optional uint32 number_of_steps = 3;
  void clear_number_of_steps();
  static const int kNumberOfStepsFieldNumber = 3;
  ::google::protobuf::uint32 number_of_steps() const;
  void set_number_of_steps(::google::protobuf::uint32 value);

  // optional string text = 4;
  void clear_text();
  static const int kTextFieldNumber = 4;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // @@protoc_insertion_point(class_scope:analogic.SdswStatus)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  int id_;
  ::google::protobuf::uint32 current_step_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  ::google::protobuf::uint32 number_of_steps_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_proto_2fCalService_2eproto();
  friend void protobuf_AssignDesc_proto_2fCalService_2eproto();
  friend void protobuf_ShutdownFile_proto_2fCalService_2eproto();

  void InitAsDefaultInstance();
  static SdswStatus* default_instance_;
};
// -------------------------------------------------------------------

class GetImageCalibrationFilesRpc : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:analogic.GetImageCalibrationFilesRpc) */ {
 public:
  GetImageCalibrationFilesRpc();
  virtual ~GetImageCalibrationFilesRpc();

  GetImageCalibrationFilesRpc(const GetImageCalibrationFilesRpc& from);

  inline GetImageCalibrationFilesRpc& operator=(const GetImageCalibrationFilesRpc& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetImageCalibrationFilesRpc& default_instance();

  void Swap(GetImageCalibrationFilesRpc* other);

  // implements Message ----------------------------------------------

  inline GetImageCalibrationFilesRpc* New() const { return New(NULL); }

  GetImageCalibrationFilesRpc* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetImageCalibrationFilesRpc& from);
  void MergeFrom(const GetImageCalibrationFilesRpc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetImageCalibrationFilesRpc* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string file_path = 1;
  void clear_file_path();
  static const int kFilePathFieldNumber = 1;
  const ::std::string& file_path() const;
  void set_file_path(const ::std::string& value);
  void set_file_path(const char* value);
  void set_file_path(const char* value, size_t size);
  ::std::string* mutable_file_path();
  ::std::string* release_file_path();
  void set_allocated_file_path(::std::string* file_path);

  // @@protoc_insertion_point(class_scope:analogic.GetImageCalibrationFilesRpc)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr file_path_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_proto_2fCalService_2eproto();
  friend void protobuf_AssignDesc_proto_2fCalService_2eproto();
  friend void protobuf_ShutdownFile_proto_2fCalService_2eproto();

  void InitAsDefaultInstance();
  static GetImageCalibrationFilesRpc* default_instance_;
};
// -------------------------------------------------------------------

class RunImageCalibrationRpc : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:analogic.RunImageCalibrationRpc) */ {
 public:
  RunImageCalibrationRpc();
  virtual ~RunImageCalibrationRpc();

  RunImageCalibrationRpc(const RunImageCalibrationRpc& from);

  inline RunImageCalibrationRpc& operator=(const RunImageCalibrationRpc& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RunImageCalibrationRpc& default_instance();

  void Swap(RunImageCalibrationRpc* other);

  // implements Message ----------------------------------------------

  inline RunImageCalibrationRpc* New() const { return New(NULL); }

  RunImageCalibrationRpc* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RunImageCalibrationRpc& from);
  void MergeFrom(const RunImageCalibrationRpc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RunImageCalibrationRpc* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string filename1 = 1;
  void clear_filename1();
  static const int kFilename1FieldNumber = 1;
  const ::std::string& filename1() const;
  void set_filename1(const ::std::string& value);
  void set_filename1(const char* value);
  void set_filename1(const char* value, size_t size);
  ::std::string* mutable_filename1();
  ::std::string* release_filename1();
  void set_allocated_filename1(::std::string* filename1);

  // optional string filename2 = 2;
  void clear_filename2();
  static const int kFilename2FieldNumber = 2;
  const ::std::string& filename2() const;
  void set_filename2(const ::std::string& value);
  void set_filename2(const char* value);
  void set_filename2(const char* value, size_t size);
  ::std::string* mutable_filename2();
  ::std::string* release_filename2();
  void set_allocated_filename2(::std::string* filename2);

  // optional string filename3 = 3;
  void clear_filename3();
  static const int kFilename3FieldNumber = 3;
  const ::std::string& filename3() const;
  void set_filename3(const ::std::string& value);
  void set_filename3(const char* value);
  void set_filename3(const char* value, size_t size);
  ::std::string* mutable_filename3();
  ::std::string* release_filename3();
  void set_allocated_filename3(::std::string* filename3);

  // optional string filename4 = 4;
  void clear_filename4();
  static const int kFilename4FieldNumber = 4;
  const ::std::string& filename4() const;
  void set_filename4(const ::std::string& value);
  void set_filename4(const char* value);
  void set_filename4(const char* value, size_t size);
  ::std::string* mutable_filename4();
  ::std::string* release_filename4();
  void set_allocated_filename4(::std::string* filename4);

  // optional string filename5 = 5;
  void clear_filename5();
  static const int kFilename5FieldNumber = 5;
  const ::std::string& filename5() const;
  void set_filename5(const ::std::string& value);
  void set_filename5(const char* value);
  void set_filename5(const char* value, size_t size);
  ::std::string* mutable_filename5();
  ::std::string* release_filename5();
  void set_allocated_filename5(::std::string* filename5);

  // @@protoc_insertion_point(class_scope:analogic.RunImageCalibrationRpc)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr filename1_;
  ::google::protobuf::internal::ArenaStringPtr filename2_;
  ::google::protobuf::internal::ArenaStringPtr filename3_;
  ::google::protobuf::internal::ArenaStringPtr filename4_;
  ::google::protobuf::internal::ArenaStringPtr filename5_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_proto_2fCalService_2eproto();
  friend void protobuf_AssignDesc_proto_2fCalService_2eproto();
  friend void protobuf_ShutdownFile_proto_2fCalService_2eproto();

  void InitAsDefaultInstance();
  static RunImageCalibrationRpc* default_instance_;
};
// -------------------------------------------------------------------

class UpdateImageCalibrationBeltHeightRpc : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:analogic.UpdateImageCalibrationBeltHeightRpc) */ {
 public:
  UpdateImageCalibrationBeltHeightRpc();
  virtual ~UpdateImageCalibrationBeltHeightRpc();

  UpdateImageCalibrationBeltHeightRpc(const UpdateImageCalibrationBeltHeightRpc& from);

  inline UpdateImageCalibrationBeltHeightRpc& operator=(const UpdateImageCalibrationBeltHeightRpc& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateImageCalibrationBeltHeightRpc& default_instance();

  void Swap(UpdateImageCalibrationBeltHeightRpc* other);

  // implements Message ----------------------------------------------

  inline UpdateImageCalibrationBeltHeightRpc* New() const { return New(NULL); }

  UpdateImageCalibrationBeltHeightRpc* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdateImageCalibrationBeltHeightRpc& from);
  void MergeFrom(const UpdateImageCalibrationBeltHeightRpc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UpdateImageCalibrationBeltHeightRpc* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float belt_height = 1;
  void clear_belt_height();
  static const int kBeltHeightFieldNumber = 1;
  float belt_height() const;
  void set_belt_height(float value);

  // @@protoc_insertion_point(class_scope:analogic.UpdateImageCalibrationBeltHeightRpc)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  float belt_height_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_proto_2fCalService_2eproto();
  friend void protobuf_AssignDesc_proto_2fCalService_2eproto();
  friend void protobuf_ShutdownFile_proto_2fCalService_2eproto();

  void InitAsDefaultInstance();
  static UpdateImageCalibrationBeltHeightRpc* default_instance_;
};
// -------------------------------------------------------------------

class UpdateImageCalibrationNylonScaleRpc : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:analogic.UpdateImageCalibrationNylonScaleRpc) */ {
 public:
  UpdateImageCalibrationNylonScaleRpc();
  virtual ~UpdateImageCalibrationNylonScaleRpc();

  UpdateImageCalibrationNylonScaleRpc(const UpdateImageCalibrationNylonScaleRpc& from);

  inline UpdateImageCalibrationNylonScaleRpc& operator=(const UpdateImageCalibrationNylonScaleRpc& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateImageCalibrationNylonScaleRpc& default_instance();

  void Swap(UpdateImageCalibrationNylonScaleRpc* other);

  // implements Message ----------------------------------------------

  inline UpdateImageCalibrationNylonScaleRpc* New() const { return New(NULL); }

  UpdateImageCalibrationNylonScaleRpc* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdateImageCalibrationNylonScaleRpc& from);
  void MergeFrom(const UpdateImageCalibrationNylonScaleRpc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UpdateImageCalibrationNylonScaleRpc* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float nylon_scale = 1;
  void clear_nylon_scale();
  static const int kNylonScaleFieldNumber = 1;
  float nylon_scale() const;
  void set_nylon_scale(float value);

  // @@protoc_insertion_point(class_scope:analogic.UpdateImageCalibrationNylonScaleRpc)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  float nylon_scale_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_proto_2fCalService_2eproto();
  friend void protobuf_AssignDesc_proto_2fCalService_2eproto();
  friend void protobuf_ShutdownFile_proto_2fCalService_2eproto();

  void InitAsDefaultInstance();
  static UpdateImageCalibrationNylonScaleRpc* default_instance_;
};
// -------------------------------------------------------------------

class UpdateImageCalibrationBeltFreqRpc : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:analogic.UpdateImageCalibrationBeltFreqRpc) */ {
 public:
  UpdateImageCalibrationBeltFreqRpc();
  virtual ~UpdateImageCalibrationBeltFreqRpc();

  UpdateImageCalibrationBeltFreqRpc(const UpdateImageCalibrationBeltFreqRpc& from);

  inline UpdateImageCalibrationBeltFreqRpc& operator=(const UpdateImageCalibrationBeltFreqRpc& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateImageCalibrationBeltFreqRpc& default_instance();

  void Swap(UpdateImageCalibrationBeltFreqRpc* other);

  // implements Message ----------------------------------------------

  inline UpdateImageCalibrationBeltFreqRpc* New() const { return New(NULL); }

  UpdateImageCalibrationBeltFreqRpc* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdateImageCalibrationBeltFreqRpc& from);
  void MergeFrom(const UpdateImageCalibrationBeltFreqRpc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UpdateImageCalibrationBeltFreqRpc* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 belt_freq = 1;
  void clear_belt_freq();
  static const int kBeltFreqFieldNumber = 1;
  ::google::protobuf::int32 belt_freq() const;
  void set_belt_freq(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:analogic.UpdateImageCalibrationBeltFreqRpc)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::int32 belt_freq_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_proto_2fCalService_2eproto();
  friend void protobuf_AssignDesc_proto_2fCalService_2eproto();
  friend void protobuf_ShutdownFile_proto_2fCalService_2eproto();

  void InitAsDefaultInstance();
  static UpdateImageCalibrationBeltFreqRpc* default_instance_;
};
// -------------------------------------------------------------------

class ExportFilesRpc : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:analogic.ExportFilesRpc) */ {
 public:
  ExportFilesRpc();
  virtual ~ExportFilesRpc();

  ExportFilesRpc(const ExportFilesRpc& from);

  inline ExportFilesRpc& operator=(const ExportFilesRpc& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExportFilesRpc& default_instance();

  void Swap(ExportFilesRpc* other);

  // implements Message ----------------------------------------------

  inline ExportFilesRpc* New() const { return New(NULL); }

  ExportFilesRpc* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExportFilesRpc& from);
  void MergeFrom(const ExportFilesRpc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ExportFilesRpc* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ExportFilesRpc_FILE_TYPES FILE_TYPES;
  static const FILE_TYPES NULL_FILE =
    ExportFilesRpc_FILE_TYPES_NULL_FILE;
  static const FILE_TYPES ERROR_LOG =
    ExportFilesRpc_FILE_TYPES_ERROR_LOG;
  static const FILE_TYPES TEST_RESULTS =
    ExportFilesRpc_FILE_TYPES_TEST_RESULTS;
  static const FILE_TYPES CALIBRATION =
    ExportFilesRpc_FILE_TYPES_CALIBRATION;
  static const FILE_TYPES CONFIGURATION =
    ExportFilesRpc_FILE_TYPES_CONFIGURATION;
  static const FILE_TYPES OPERATING_SYSTEM =
    ExportFilesRpc_FILE_TYPES_OPERATING_SYSTEM;
  static const FILE_TYPES APPLICATION_LOGS =
    ExportFilesRpc_FILE_TYPES_APPLICATION_LOGS;
  static inline bool FILE_TYPES_IsValid(int value) {
    return ExportFilesRpc_FILE_TYPES_IsValid(value);
  }
  static const FILE_TYPES FILE_TYPES_MIN =
    ExportFilesRpc_FILE_TYPES_FILE_TYPES_MIN;
  static const FILE_TYPES FILE_TYPES_MAX =
    ExportFilesRpc_FILE_TYPES_FILE_TYPES_MAX;
  static const int FILE_TYPES_ARRAYSIZE =
    ExportFilesRpc_FILE_TYPES_FILE_TYPES_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FILE_TYPES_descriptor() {
    return ExportFilesRpc_FILE_TYPES_descriptor();
  }
  static inline const ::std::string& FILE_TYPES_Name(FILE_TYPES value) {
    return ExportFilesRpc_FILE_TYPES_Name(value);
  }
  static inline bool FILE_TYPES_Parse(const ::std::string& name,
      FILE_TYPES* value) {
    return ExportFilesRpc_FILE_TYPES_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string file_path = 1;
  void clear_file_path();
  static const int kFilePathFieldNumber = 1;
  const ::std::string& file_path() const;
  void set_file_path(const ::std::string& value);
  void set_file_path(const char* value);
  void set_file_path(const char* value, size_t size);
  ::std::string* mutable_file_path();
  ::std::string* release_file_path();
  void set_allocated_file_path(::std::string* file_path);

  // optional fixed32 file_types = 2;
  void clear_file_types();
  static const int kFileTypesFieldNumber = 2;
  ::google::protobuf::uint32 file_types() const;
  void set_file_types(::google::protobuf::uint32 value);

  // optional string start_time_string = 3;
  void clear_start_time_string();
  static const int kStartTimeStringFieldNumber = 3;
  const ::std::string& start_time_string() const;
  void set_start_time_string(const ::std::string& value);
  void set_start_time_string(const char* value);
  void set_start_time_string(const char* value, size_t size);
  ::std::string* mutable_start_time_string();
  ::std::string* release_start_time_string();
  void set_allocated_start_time_string(::std::string* start_time_string);

  // optional string end_time_string = 4;
  void clear_end_time_string();
  static const int kEndTimeStringFieldNumber = 4;
  const ::std::string& end_time_string() const;
  void set_end_time_string(const ::std::string& value);
  void set_end_time_string(const char* value);
  void set_end_time_string(const char* value, size_t size);
  ::std::string* mutable_end_time_string();
  ::std::string* release_end_time_string();
  void set_allocated_end_time_string(::std::string* end_time_string);

  // @@protoc_insertion_point(class_scope:analogic.ExportFilesRpc)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr file_path_;
  ::google::protobuf::internal::ArenaStringPtr start_time_string_;
  ::google::protobuf::internal::ArenaStringPtr end_time_string_;
  ::google::protobuf::uint32 file_types_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_proto_2fCalService_2eproto();
  friend void protobuf_AssignDesc_proto_2fCalService_2eproto();
  friend void protobuf_ShutdownFile_proto_2fCalService_2eproto();

  void InitAsDefaultInstance();
  static ExportFilesRpc* default_instance_;
};
// -------------------------------------------------------------------

class AirCalibrationRpc : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:analogic.AirCalibrationRpc) */ {
 public:
  AirCalibrationRpc();
  virtual ~AirCalibrationRpc();

  AirCalibrationRpc(const AirCalibrationRpc& from);

  inline AirCalibrationRpc& operator=(const AirCalibrationRpc& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AirCalibrationRpc& default_instance();

  void Swap(AirCalibrationRpc* other);

  // implements Message ----------------------------------------------

  inline AirCalibrationRpc* New() const { return New(NULL); }

  AirCalibrationRpc* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AirCalibrationRpc& from);
  void MergeFrom(const AirCalibrationRpc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AirCalibrationRpc* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:analogic.AirCalibrationRpc)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_proto_2fCalService_2eproto();
  friend void protobuf_AssignDesc_proto_2fCalService_2eproto();
  friend void protobuf_ShutdownFile_proto_2fCalService_2eproto();

  void InitAsDefaultInstance();
  static AirCalibrationRpc* default_instance_;
};
// -------------------------------------------------------------------

class OffsetCalibrationRpc : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:analogic.OffsetCalibrationRpc) */ {
 public:
  OffsetCalibrationRpc();
  virtual ~OffsetCalibrationRpc();

  OffsetCalibrationRpc(const OffsetCalibrationRpc& from);

  inline OffsetCalibrationRpc& operator=(const OffsetCalibrationRpc& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OffsetCalibrationRpc& default_instance();

  void Swap(OffsetCalibrationRpc* other);

  // implements Message ----------------------------------------------

  inline OffsetCalibrationRpc* New() const { return New(NULL); }

  OffsetCalibrationRpc* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OffsetCalibrationRpc& from);
  void MergeFrom(const OffsetCalibrationRpc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OffsetCalibrationRpc* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:analogic.OffsetCalibrationRpc)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_proto_2fCalService_2eproto();
  friend void protobuf_AssignDesc_proto_2fCalService_2eproto();
  friend void protobuf_ShutdownFile_proto_2fCalService_2eproto();

  void InitAsDefaultInstance();
  static OffsetCalibrationRpc* default_instance_;
};
// -------------------------------------------------------------------

class CalibrationRpc : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:analogic.CalibrationRpc) */ {
 public:
  CalibrationRpc();
  virtual ~CalibrationRpc();

  CalibrationRpc(const CalibrationRpc& from);

  inline CalibrationRpc& operator=(const CalibrationRpc& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CalibrationRpc& default_instance();

  void Swap(CalibrationRpc* other);

  // implements Message ----------------------------------------------

  inline CalibrationRpc* New() const { return New(NULL); }

  CalibrationRpc* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CalibrationRpc& from);
  void MergeFrom(const CalibrationRpc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CalibrationRpc* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CalibrationRpc_CAL_COMMAND CAL_COMMAND;
  static const CAL_COMMAND START =
    CalibrationRpc_CAL_COMMAND_START;
  static const CAL_COMMAND PROCEED =
    CalibrationRpc_CAL_COMMAND_PROCEED;
  static const CAL_COMMAND CANCEL =
    CalibrationRpc_CAL_COMMAND_CANCEL;
  static inline bool CAL_COMMAND_IsValid(int value) {
    return CalibrationRpc_CAL_COMMAND_IsValid(value);
  }
  static const CAL_COMMAND CAL_COMMAND_MIN =
    CalibrationRpc_CAL_COMMAND_CAL_COMMAND_MIN;
  static const CAL_COMMAND CAL_COMMAND_MAX =
    CalibrationRpc_CAL_COMMAND_CAL_COMMAND_MAX;
  static const int CAL_COMMAND_ARRAYSIZE =
    CalibrationRpc_CAL_COMMAND_CAL_COMMAND_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CAL_COMMAND_descriptor() {
    return CalibrationRpc_CAL_COMMAND_descriptor();
  }
  static inline const ::std::string& CAL_COMMAND_Name(CAL_COMMAND value) {
    return CalibrationRpc_CAL_COMMAND_Name(value);
  }
  static inline bool CAL_COMMAND_Parse(const ::std::string& name,
      CAL_COMMAND* value) {
    return CalibrationRpc_CAL_COMMAND_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .analogic.CalibrationRpc.CAL_COMMAND cmd = 1;
  void clear_cmd();
  static const int kCmdFieldNumber = 1;
  ::analogic::CalibrationRpc_CAL_COMMAND cmd() const;
  void set_cmd(::analogic::CalibrationRpc_CAL_COMMAND value);

  // @@protoc_insertion_point(class_scope:analogic.CalibrationRpc)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  int cmd_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_proto_2fCalService_2eproto();
  friend void protobuf_AssignDesc_proto_2fCalService_2eproto();
  friend void protobuf_ShutdownFile_proto_2fCalService_2eproto();

  void InitAsDefaultInstance();
  static CalibrationRpc* default_instance_;
};
// -------------------------------------------------------------------

class AlarmLibInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:analogic.AlarmLibInfo) */ {
 public:
  AlarmLibInfo();
  virtual ~AlarmLibInfo();

  AlarmLibInfo(const AlarmLibInfo& from);

  inline AlarmLibInfo& operator=(const AlarmLibInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AlarmLibInfo& default_instance();

  void Swap(AlarmLibInfo* other);

  // implements Message ----------------------------------------------

  inline AlarmLibInfo* New() const { return New(NULL); }

  AlarmLibInfo* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AlarmLibInfo& from);
  void MergeFrom(const AlarmLibInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AlarmLibInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string version = 2;
  void clear_version();
  static const int kVersionFieldNumber = 2;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // @@protoc_insertion_point(class_scope:analogic.AlarmLibInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_proto_2fCalService_2eproto();
  friend void protobuf_AssignDesc_proto_2fCalService_2eproto();
  friend void protobuf_ShutdownFile_proto_2fCalService_2eproto();

  void InitAsDefaultInstance();
  static AlarmLibInfo* default_instance_;
};
// -------------------------------------------------------------------

class InstalledAlarmLibInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:analogic.InstalledAlarmLibInfo) */ {
 public:
  InstalledAlarmLibInfo();
  virtual ~InstalledAlarmLibInfo();

  InstalledAlarmLibInfo(const InstalledAlarmLibInfo& from);

  inline InstalledAlarmLibInfo& operator=(const InstalledAlarmLibInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InstalledAlarmLibInfo& default_instance();

  void Swap(InstalledAlarmLibInfo* other);

  // implements Message ----------------------------------------------

  inline InstalledAlarmLibInfo* New() const { return New(NULL); }

  InstalledAlarmLibInfo* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InstalledAlarmLibInfo& from);
  void MergeFrom(const InstalledAlarmLibInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InstalledAlarmLibInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string version = 2;
  void clear_version();
  static const int kVersionFieldNumber = 2;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // optional bool corrupted = 3;
  void clear_corrupted();
  static const int kCorruptedFieldNumber = 3;
  bool corrupted() const;
  void set_corrupted(bool value);

  // @@protoc_insertion_point(class_scope:analogic.InstalledAlarmLibInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  bool corrupted_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_proto_2fCalService_2eproto();
  friend void protobuf_AssignDesc_proto_2fCalService_2eproto();
  friend void protobuf_ShutdownFile_proto_2fCalService_2eproto();

  void InitAsDefaultInstance();
  static InstalledAlarmLibInfo* default_instance_;
};
// -------------------------------------------------------------------

class GetInstalledAlarmLibsRpc : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:analogic.GetInstalledAlarmLibsRpc) */ {
 public:
  GetInstalledAlarmLibsRpc();
  virtual ~GetInstalledAlarmLibsRpc();

  GetInstalledAlarmLibsRpc(const GetInstalledAlarmLibsRpc& from);

  inline GetInstalledAlarmLibsRpc& operator=(const GetInstalledAlarmLibsRpc& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetInstalledAlarmLibsRpc& default_instance();

  void Swap(GetInstalledAlarmLibsRpc* other);

  // implements Message ----------------------------------------------

  inline GetInstalledAlarmLibsRpc* New() const { return New(NULL); }

  GetInstalledAlarmLibsRpc* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetInstalledAlarmLibsRpc& from);
  void MergeFrom(const GetInstalledAlarmLibsRpc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetInstalledAlarmLibsRpc* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:analogic.GetInstalledAlarmLibsRpc)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_proto_2fCalService_2eproto();
  friend void protobuf_AssignDesc_proto_2fCalService_2eproto();
  friend void protobuf_ShutdownFile_proto_2fCalService_2eproto();

  void InitAsDefaultInstance();
  static GetInstalledAlarmLibsRpc* default_instance_;
};
// -------------------------------------------------------------------

class GetInstalledAlarmLibsReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:analogic.GetInstalledAlarmLibsReply) */ {
 public:
  GetInstalledAlarmLibsReply();
  virtual ~GetInstalledAlarmLibsReply();

  GetInstalledAlarmLibsReply(const GetInstalledAlarmLibsReply& from);

  inline GetInstalledAlarmLibsReply& operator=(const GetInstalledAlarmLibsReply& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetInstalledAlarmLibsReply& default_instance();

  void Swap(GetInstalledAlarmLibsReply* other);

  // implements Message ----------------------------------------------

  inline GetInstalledAlarmLibsReply* New() const { return New(NULL); }

  GetInstalledAlarmLibsReply* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetInstalledAlarmLibsReply& from);
  void MergeFrom(const GetInstalledAlarmLibsReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetInstalledAlarmLibsReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .analogic.InstalledAlarmLibInfo installed_alarmlibs = 1;
  int installed_alarmlibs_size() const;
  void clear_installed_alarmlibs();
  static const int kInstalledAlarmlibsFieldNumber = 1;
  const ::analogic::InstalledAlarmLibInfo& installed_alarmlibs(int index) const;
  ::analogic::InstalledAlarmLibInfo* mutable_installed_alarmlibs(int index);
  ::analogic::InstalledAlarmLibInfo* add_installed_alarmlibs();
  ::google::protobuf::RepeatedPtrField< ::analogic::InstalledAlarmLibInfo >*
      mutable_installed_alarmlibs();
  const ::google::protobuf::RepeatedPtrField< ::analogic::InstalledAlarmLibInfo >&
      installed_alarmlibs() const;

  // @@protoc_insertion_point(class_scope:analogic.GetInstalledAlarmLibsReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::analogic::InstalledAlarmLibInfo > installed_alarmlibs_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_proto_2fCalService_2eproto();
  friend void protobuf_AssignDesc_proto_2fCalService_2eproto();
  friend void protobuf_ShutdownFile_proto_2fCalService_2eproto();

  void InitAsDefaultInstance();
  static GetInstalledAlarmLibsReply* default_instance_;
};
// -------------------------------------------------------------------

class GetInstallableAlarmLibsRpc : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:analogic.GetInstallableAlarmLibsRpc) */ {
 public:
  GetInstallableAlarmLibsRpc();
  virtual ~GetInstallableAlarmLibsRpc();

  GetInstallableAlarmLibsRpc(const GetInstallableAlarmLibsRpc& from);

  inline GetInstallableAlarmLibsRpc& operator=(const GetInstallableAlarmLibsRpc& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetInstallableAlarmLibsRpc& default_instance();

  void Swap(GetInstallableAlarmLibsRpc* other);

  // implements Message ----------------------------------------------

  inline GetInstallableAlarmLibsRpc* New() const { return New(NULL); }

  GetInstallableAlarmLibsRpc* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetInstallableAlarmLibsRpc& from);
  void MergeFrom(const GetInstallableAlarmLibsRpc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetInstallableAlarmLibsRpc* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:analogic.GetInstallableAlarmLibsRpc)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_proto_2fCalService_2eproto();
  friend void protobuf_AssignDesc_proto_2fCalService_2eproto();
  friend void protobuf_ShutdownFile_proto_2fCalService_2eproto();

  void InitAsDefaultInstance();
  static GetInstallableAlarmLibsRpc* default_instance_;
};
// -------------------------------------------------------------------

class GetInstallableAlarmLibsReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:analogic.GetInstallableAlarmLibsReply) */ {
 public:
  GetInstallableAlarmLibsReply();
  virtual ~GetInstallableAlarmLibsReply();

  GetInstallableAlarmLibsReply(const GetInstallableAlarmLibsReply& from);

  inline GetInstallableAlarmLibsReply& operator=(const GetInstallableAlarmLibsReply& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetInstallableAlarmLibsReply& default_instance();

  void Swap(GetInstallableAlarmLibsReply* other);

  // implements Message ----------------------------------------------

  inline GetInstallableAlarmLibsReply* New() const { return New(NULL); }

  GetInstallableAlarmLibsReply* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetInstallableAlarmLibsReply& from);
  void MergeFrom(const GetInstallableAlarmLibsReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetInstallableAlarmLibsReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .analogic.AlarmLibInfo installable_alarmlibs = 1;
  int installable_alarmlibs_size() const;
  void clear_installable_alarmlibs();
  static const int kInstallableAlarmlibsFieldNumber = 1;
  const ::analogic::AlarmLibInfo& installable_alarmlibs(int index) const;
  ::analogic::AlarmLibInfo* mutable_installable_alarmlibs(int index);
  ::analogic::AlarmLibInfo* add_installable_alarmlibs();
  ::google::protobuf::RepeatedPtrField< ::analogic::AlarmLibInfo >*
      mutable_installable_alarmlibs();
  const ::google::protobuf::RepeatedPtrField< ::analogic::AlarmLibInfo >&
      installable_alarmlibs() const;

  // @@protoc_insertion_point(class_scope:analogic.GetInstallableAlarmLibsReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::analogic::AlarmLibInfo > installable_alarmlibs_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_proto_2fCalService_2eproto();
  friend void protobuf_AssignDesc_proto_2fCalService_2eproto();
  friend void protobuf_ShutdownFile_proto_2fCalService_2eproto();

  void InitAsDefaultInstance();
  static GetInstallableAlarmLibsReply* default_instance_;
};
// -------------------------------------------------------------------

class InstallAlarmLibRpc : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:analogic.InstallAlarmLibRpc) */ {
 public:
  InstallAlarmLibRpc();
  virtual ~InstallAlarmLibRpc();

  InstallAlarmLibRpc(const InstallAlarmLibRpc& from);

  inline InstallAlarmLibRpc& operator=(const InstallAlarmLibRpc& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InstallAlarmLibRpc& default_instance();

  void Swap(InstallAlarmLibRpc* other);

  // implements Message ----------------------------------------------

  inline InstallAlarmLibRpc* New() const { return New(NULL); }

  InstallAlarmLibRpc* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InstallAlarmLibRpc& from);
  void MergeFrom(const InstallAlarmLibRpc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InstallAlarmLibRpc* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .analogic.AlarmLibInfo alarmlib_info = 1;
  bool has_alarmlib_info() const;
  void clear_alarmlib_info();
  static const int kAlarmlibInfoFieldNumber = 1;
  const ::analogic::AlarmLibInfo& alarmlib_info() const;
  ::analogic::AlarmLibInfo* mutable_alarmlib_info();
  ::analogic::AlarmLibInfo* release_alarmlib_info();
  void set_allocated_alarmlib_info(::analogic::AlarmLibInfo* alarmlib_info);

  // @@protoc_insertion_point(class_scope:analogic.InstallAlarmLibRpc)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::analogic::AlarmLibInfo* alarmlib_info_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_proto_2fCalService_2eproto();
  friend void protobuf_AssignDesc_proto_2fCalService_2eproto();
  friend void protobuf_ShutdownFile_proto_2fCalService_2eproto();

  void InitAsDefaultInstance();
  static InstallAlarmLibRpc* default_instance_;
};
// -------------------------------------------------------------------

class ExportCalParamDataRpc : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:analogic.ExportCalParamDataRpc) */ {
 public:
  ExportCalParamDataRpc();
  virtual ~ExportCalParamDataRpc();

  ExportCalParamDataRpc(const ExportCalParamDataRpc& from);

  inline ExportCalParamDataRpc& operator=(const ExportCalParamDataRpc& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExportCalParamDataRpc& default_instance();

  void Swap(ExportCalParamDataRpc* other);

  // implements Message ----------------------------------------------

  inline ExportCalParamDataRpc* New() const { return New(NULL); }

  ExportCalParamDataRpc* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExportCalParamDataRpc& from);
  void MergeFrom(const ExportCalParamDataRpc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ExportCalParamDataRpc* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string file_path = 1;
  void clear_file_path();
  static const int kFilePathFieldNumber = 1;
  const ::std::string& file_path() const;
  void set_file_path(const ::std::string& value);
  void set_file_path(const char* value);
  void set_file_path(const char* value, size_t size);
  ::std::string* mutable_file_path();
  ::std::string* release_file_path();
  void set_allocated_file_path(::std::string* file_path);

  // @@protoc_insertion_point(class_scope:analogic.ExportCalParamDataRpc)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr file_path_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_proto_2fCalService_2eproto();
  friend void protobuf_AssignDesc_proto_2fCalService_2eproto();
  friend void protobuf_ShutdownFile_proto_2fCalService_2eproto();

  void InitAsDefaultInstance();
  static ExportCalParamDataRpc* default_instance_;
};
// -------------------------------------------------------------------

class ImportCalParamDataRpc : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:analogic.ImportCalParamDataRpc) */ {
 public:
  ImportCalParamDataRpc();
  virtual ~ImportCalParamDataRpc();

  ImportCalParamDataRpc(const ImportCalParamDataRpc& from);

  inline ImportCalParamDataRpc& operator=(const ImportCalParamDataRpc& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ImportCalParamDataRpc& default_instance();

  void Swap(ImportCalParamDataRpc* other);

  // implements Message ----------------------------------------------

  inline ImportCalParamDataRpc* New() const { return New(NULL); }

  ImportCalParamDataRpc* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ImportCalParamDataRpc& from);
  void MergeFrom(const ImportCalParamDataRpc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ImportCalParamDataRpc* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string file_path = 1;
  void clear_file_path();
  static const int kFilePathFieldNumber = 1;
  const ::std::string& file_path() const;
  void set_file_path(const ::std::string& value);
  void set_file_path(const char* value);
  void set_file_path(const char* value, size_t size);
  ::std::string* mutable_file_path();
  ::std::string* release_file_path();
  void set_allocated_file_path(::std::string* file_path);

  // optional string file_name = 2;
  void clear_file_name();
  static const int kFileNameFieldNumber = 2;
  const ::std::string& file_name() const;
  void set_file_name(const ::std::string& value);
  void set_file_name(const char* value);
  void set_file_name(const char* value, size_t size);
  ::std::string* mutable_file_name();
  ::std::string* release_file_name();
  void set_allocated_file_name(::std::string* file_name);

  // @@protoc_insertion_point(class_scope:analogic.ImportCalParamDataRpc)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr file_path_;
  ::google::protobuf::internal::ArenaStringPtr file_name_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_proto_2fCalService_2eproto();
  friend void protobuf_AssignDesc_proto_2fCalService_2eproto();
  friend void protobuf_ShutdownFile_proto_2fCalService_2eproto();

  void InitAsDefaultInstance();
  static ImportCalParamDataRpc* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// RpcReply

// optional .analogic.RpcReply.RPC_REPLY reply_id = 1;
inline void RpcReply::clear_reply_id() {
  reply_id_ = 0;
}
inline ::analogic::RpcReply_RPC_REPLY RpcReply::reply_id() const {
  // @@protoc_insertion_point(field_get:analogic.RpcReply.reply_id)
  return static_cast< ::analogic::RpcReply_RPC_REPLY >(reply_id_);
}
inline void RpcReply::set_reply_id(::analogic::RpcReply_RPC_REPLY value) {
  
  reply_id_ = value;
  // @@protoc_insertion_point(field_set:analogic.RpcReply.reply_id)
}

// optional string file_name = 2;
inline void RpcReply::clear_file_name() {
  file_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RpcReply::file_name() const {
  // @@protoc_insertion_point(field_get:analogic.RpcReply.file_name)
  return file_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RpcReply::set_file_name(const ::std::string& value) {
  
  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:analogic.RpcReply.file_name)
}
inline void RpcReply::set_file_name(const char* value) {
  
  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:analogic.RpcReply.file_name)
}
inline void RpcReply::set_file_name(const char* value, size_t size) {
  
  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:analogic.RpcReply.file_name)
}
inline ::std::string* RpcReply::mutable_file_name() {
  
  // @@protoc_insertion_point(field_mutable:analogic.RpcReply.file_name)
  return file_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RpcReply::release_file_name() {
  // @@protoc_insertion_point(field_release:analogic.RpcReply.file_name)
  
  return file_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RpcReply::set_allocated_file_name(::std::string* file_name) {
  if (file_name != NULL) {
    
  } else {
    
  }
  file_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), file_name);
  // @@protoc_insertion_point(field_set_allocated:analogic.RpcReply.file_name)
}

// optional float belt_height = 3;
inline void RpcReply::clear_belt_height() {
  belt_height_ = 0;
}
inline float RpcReply::belt_height() const {
  // @@protoc_insertion_point(field_get:analogic.RpcReply.belt_height)
  return belt_height_;
}
inline void RpcReply::set_belt_height(float value) {
  
  belt_height_ = value;
  // @@protoc_insertion_point(field_set:analogic.RpcReply.belt_height)
}

// optional float nylon_scale = 4;
inline void RpcReply::clear_nylon_scale() {
  nylon_scale_ = 0;
}
inline float RpcReply::nylon_scale() const {
  // @@protoc_insertion_point(field_get:analogic.RpcReply.nylon_scale)
  return nylon_scale_;
}
inline void RpcReply::set_nylon_scale(float value) {
  
  nylon_scale_ = value;
  // @@protoc_insertion_point(field_set:analogic.RpcReply.nylon_scale)
}

// optional string file_name_2 = 5;
inline void RpcReply::clear_file_name_2() {
  file_name_2_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RpcReply::file_name_2() const {
  // @@protoc_insertion_point(field_get:analogic.RpcReply.file_name_2)
  return file_name_2_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RpcReply::set_file_name_2(const ::std::string& value) {
  
  file_name_2_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:analogic.RpcReply.file_name_2)
}
inline void RpcReply::set_file_name_2(const char* value) {
  
  file_name_2_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:analogic.RpcReply.file_name_2)
}
inline void RpcReply::set_file_name_2(const char* value, size_t size) {
  
  file_name_2_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:analogic.RpcReply.file_name_2)
}
inline ::std::string* RpcReply::mutable_file_name_2() {
  
  // @@protoc_insertion_point(field_mutable:analogic.RpcReply.file_name_2)
  return file_name_2_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RpcReply::release_file_name_2() {
  // @@protoc_insertion_point(field_release:analogic.RpcReply.file_name_2)
  
  return file_name_2_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RpcReply::set_allocated_file_name_2(::std::string* file_name_2) {
  if (file_name_2 != NULL) {
    
  } else {
    
  }
  file_name_2_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), file_name_2);
  // @@protoc_insertion_point(field_set_allocated:analogic.RpcReply.file_name_2)
}

// optional float float_data_1 = 6;
inline void RpcReply::clear_float_data_1() {
  float_data_1_ = 0;
}
inline float RpcReply::float_data_1() const {
  // @@protoc_insertion_point(field_get:analogic.RpcReply.float_data_1)
  return float_data_1_;
}
inline void RpcReply::set_float_data_1(float value) {
  
  float_data_1_ = value;
  // @@protoc_insertion_point(field_set:analogic.RpcReply.float_data_1)
}

// optional float float_data_2 = 7;
inline void RpcReply::clear_float_data_2() {
  float_data_2_ = 0;
}
inline float RpcReply::float_data_2() const {
  // @@protoc_insertion_point(field_get:analogic.RpcReply.float_data_2)
  return float_data_2_;
}
inline void RpcReply::set_float_data_2(float value) {
  
  float_data_2_ = value;
  // @@protoc_insertion_point(field_set:analogic.RpcReply.float_data_2)
}

// optional float float_data_3 = 8;
inline void RpcReply::clear_float_data_3() {
  float_data_3_ = 0;
}
inline float RpcReply::float_data_3() const {
  // @@protoc_insertion_point(field_get:analogic.RpcReply.float_data_3)
  return float_data_3_;
}
inline void RpcReply::set_float_data_3(float value) {
  
  float_data_3_ = value;
  // @@protoc_insertion_point(field_set:analogic.RpcReply.float_data_3)
}

// optional .analogic.RpcReply.RPC_ERROR_CODE error_code = 9;
inline void RpcReply::clear_error_code() {
  error_code_ = 0;
}
inline ::analogic::RpcReply_RPC_ERROR_CODE RpcReply::error_code() const {
  // @@protoc_insertion_point(field_get:analogic.RpcReply.error_code)
  return static_cast< ::analogic::RpcReply_RPC_ERROR_CODE >(error_code_);
}
inline void RpcReply::set_error_code(::analogic::RpcReply_RPC_ERROR_CODE value) {
  
  error_code_ = value;
  // @@protoc_insertion_point(field_set:analogic.RpcReply.error_code)
}

// optional int32 belt_frequency = 10;
inline void RpcReply::clear_belt_frequency() {
  belt_frequency_ = 0;
}
inline ::google::protobuf::int32 RpcReply::belt_frequency() const {
  // @@protoc_insertion_point(field_get:analogic.RpcReply.belt_frequency)
  return belt_frequency_;
}
inline void RpcReply::set_belt_frequency(::google::protobuf::int32 value) {
  
  belt_frequency_ = value;
  // @@protoc_insertion_point(field_set:analogic.RpcReply.belt_frequency)
}

// -------------------------------------------------------------------

// XrayControlRpc

// -------------------------------------------------------------------

// RawDataCollectRpc

// optional .analogic.XrayControlRpc.XRAY_STATE xray_state = 1;
inline void RawDataCollectRpc::clear_xray_state() {
  xray_state_ = 0;
}
inline ::analogic::XrayControlRpc_XRAY_STATE RawDataCollectRpc::xray_state() const {
  // @@protoc_insertion_point(field_get:analogic.RawDataCollectRpc.xray_state)
  return static_cast< ::analogic::XrayControlRpc_XRAY_STATE >(xray_state_);
}
inline void RawDataCollectRpc::set_xray_state(::analogic::XrayControlRpc_XRAY_STATE value) {
  
  xray_state_ = value;
  // @@protoc_insertion_point(field_set:analogic.RawDataCollectRpc.xray_state)
}

// optional bool gantry_on = 2;
inline void RawDataCollectRpc::clear_gantry_on() {
  gantry_on_ = false;
}
inline bool RawDataCollectRpc::gantry_on() const {
  // @@protoc_insertion_point(field_get:analogic.RawDataCollectRpc.gantry_on)
  return gantry_on_;
}
inline void RawDataCollectRpc::set_gantry_on(bool value) {
  
  gantry_on_ = value;
  // @@protoc_insertion_point(field_set:analogic.RawDataCollectRpc.gantry_on)
}

// optional bool conveyor_on = 3;
inline void RawDataCollectRpc::clear_conveyor_on() {
  conveyor_on_ = false;
}
inline bool RawDataCollectRpc::conveyor_on() const {
  // @@protoc_insertion_point(field_get:analogic.RawDataCollectRpc.conveyor_on)
  return conveyor_on_;
}
inline void RawDataCollectRpc::set_conveyor_on(bool value) {
  
  conveyor_on_ = value;
  // @@protoc_insertion_point(field_set:analogic.RawDataCollectRpc.conveyor_on)
}

// optional int32 num_rotations = 4;
inline void RawDataCollectRpc::clear_num_rotations() {
  num_rotations_ = 0;
}
inline ::google::protobuf::int32 RawDataCollectRpc::num_rotations() const {
  // @@protoc_insertion_point(field_get:analogic.RawDataCollectRpc.num_rotations)
  return num_rotations_;
}
inline void RawDataCollectRpc::set_num_rotations(::google::protobuf::int32 value) {
  
  num_rotations_ = value;
  // @@protoc_insertion_point(field_set:analogic.RawDataCollectRpc.num_rotations)
}

// optional string file_path = 5;
inline void RawDataCollectRpc::clear_file_path() {
  file_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RawDataCollectRpc::file_path() const {
  // @@protoc_insertion_point(field_get:analogic.RawDataCollectRpc.file_path)
  return file_path_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RawDataCollectRpc::set_file_path(const ::std::string& value) {
  
  file_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:analogic.RawDataCollectRpc.file_path)
}
inline void RawDataCollectRpc::set_file_path(const char* value) {
  
  file_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:analogic.RawDataCollectRpc.file_path)
}
inline void RawDataCollectRpc::set_file_path(const char* value, size_t size) {
  
  file_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:analogic.RawDataCollectRpc.file_path)
}
inline ::std::string* RawDataCollectRpc::mutable_file_path() {
  
  // @@protoc_insertion_point(field_mutable:analogic.RawDataCollectRpc.file_path)
  return file_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RawDataCollectRpc::release_file_path() {
  // @@protoc_insertion_point(field_release:analogic.RawDataCollectRpc.file_path)
  
  return file_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RawDataCollectRpc::set_allocated_file_path(::std::string* file_path) {
  if (file_path != NULL) {
    
  } else {
    
  }
  file_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), file_path);
  // @@protoc_insertion_point(field_set_allocated:analogic.RawDataCollectRpc.file_path)
}

// -------------------------------------------------------------------

// AirCalRpc

// -------------------------------------------------------------------

// OffsetCalRpc

// -------------------------------------------------------------------

// ImageQualityTestRpc

// optional string dest_folder = 1;
inline void ImageQualityTestRpc::clear_dest_folder() {
  dest_folder_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ImageQualityTestRpc::dest_folder() const {
  // @@protoc_insertion_point(field_get:analogic.ImageQualityTestRpc.dest_folder)
  return dest_folder_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImageQualityTestRpc::set_dest_folder(const ::std::string& value) {
  
  dest_folder_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:analogic.ImageQualityTestRpc.dest_folder)
}
inline void ImageQualityTestRpc::set_dest_folder(const char* value) {
  
  dest_folder_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:analogic.ImageQualityTestRpc.dest_folder)
}
inline void ImageQualityTestRpc::set_dest_folder(const char* value, size_t size) {
  
  dest_folder_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:analogic.ImageQualityTestRpc.dest_folder)
}
inline ::std::string* ImageQualityTestRpc::mutable_dest_folder() {
  
  // @@protoc_insertion_point(field_mutable:analogic.ImageQualityTestRpc.dest_folder)
  return dest_folder_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImageQualityTestRpc::release_dest_folder() {
  // @@protoc_insertion_point(field_release:analogic.ImageQualityTestRpc.dest_folder)
  
  return dest_folder_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImageQualityTestRpc::set_allocated_dest_folder(::std::string* dest_folder) {
  if (dest_folder != NULL) {
    
  } else {
    
  }
  dest_folder_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), dest_folder);
  // @@protoc_insertion_point(field_set_allocated:analogic.ImageQualityTestRpc.dest_folder)
}

// optional float float_data_1 = 2;
inline void ImageQualityTestRpc::clear_float_data_1() {
  float_data_1_ = 0;
}
inline float ImageQualityTestRpc::float_data_1() const {
  // @@protoc_insertion_point(field_get:analogic.ImageQualityTestRpc.float_data_1)
  return float_data_1_;
}
inline void ImageQualityTestRpc::set_float_data_1(float value) {
  
  float_data_1_ = value;
  // @@protoc_insertion_point(field_set:analogic.ImageQualityTestRpc.float_data_1)
}

// optional float float_data_2 = 3;
inline void ImageQualityTestRpc::clear_float_data_2() {
  float_data_2_ = 0;
}
inline float ImageQualityTestRpc::float_data_2() const {
  // @@protoc_insertion_point(field_get:analogic.ImageQualityTestRpc.float_data_2)
  return float_data_2_;
}
inline void ImageQualityTestRpc::set_float_data_2(float value) {
  
  float_data_2_ = value;
  // @@protoc_insertion_point(field_set:analogic.ImageQualityTestRpc.float_data_2)
}

// optional float float_data_3 = 4;
inline void ImageQualityTestRpc::clear_float_data_3() {
  float_data_3_ = 0;
}
inline float ImageQualityTestRpc::float_data_3() const {
  // @@protoc_insertion_point(field_get:analogic.ImageQualityTestRpc.float_data_3)
  return float_data_3_;
}
inline void ImageQualityTestRpc::set_float_data_3(float value) {
  
  float_data_3_ = value;
  // @@protoc_insertion_point(field_set:analogic.ImageQualityTestRpc.float_data_3)
}

// optional string source_user = 5;
inline void ImageQualityTestRpc::clear_source_user() {
  source_user_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ImageQualityTestRpc::source_user() const {
  // @@protoc_insertion_point(field_get:analogic.ImageQualityTestRpc.source_user)
  return source_user_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImageQualityTestRpc::set_source_user(const ::std::string& value) {
  
  source_user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:analogic.ImageQualityTestRpc.source_user)
}
inline void ImageQualityTestRpc::set_source_user(const char* value) {
  
  source_user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:analogic.ImageQualityTestRpc.source_user)
}
inline void ImageQualityTestRpc::set_source_user(const char* value, size_t size) {
  
  source_user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:analogic.ImageQualityTestRpc.source_user)
}
inline ::std::string* ImageQualityTestRpc::mutable_source_user() {
  
  // @@protoc_insertion_point(field_mutable:analogic.ImageQualityTestRpc.source_user)
  return source_user_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImageQualityTestRpc::release_source_user() {
  // @@protoc_insertion_point(field_release:analogic.ImageQualityTestRpc.source_user)
  
  return source_user_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImageQualityTestRpc::set_allocated_source_user(::std::string* source_user) {
  if (source_user != NULL) {
    
  } else {
    
  }
  source_user_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), source_user);
  // @@protoc_insertion_point(field_set_allocated:analogic.ImageQualityTestRpc.source_user)
}

// optional .analogic.ImageQualityTestRpc.IQ_TEST_TYPE iq_test_type = 6;
inline void ImageQualityTestRpc::clear_iq_test_type() {
  iq_test_type_ = 0;
}
inline ::analogic::ImageQualityTestRpc_IQ_TEST_TYPE ImageQualityTestRpc::iq_test_type() const {
  // @@protoc_insertion_point(field_get:analogic.ImageQualityTestRpc.iq_test_type)
  return static_cast< ::analogic::ImageQualityTestRpc_IQ_TEST_TYPE >(iq_test_type_);
}
inline void ImageQualityTestRpc::set_iq_test_type(::analogic::ImageQualityTestRpc_IQ_TEST_TYPE value) {
  
  iq_test_type_ = value;
  // @@protoc_insertion_point(field_set:analogic.ImageQualityTestRpc.iq_test_type)
}

// -------------------------------------------------------------------

// GetImageQualityMassValuesRpc

// -------------------------------------------------------------------

// RadiationSurveyRpc

// -------------------------------------------------------------------

// RadSurveyRpcCancel

// -------------------------------------------------------------------

// BeltTunnelCalRpc

// -------------------------------------------------------------------

// GetBadDetectorMapFilesRpc

// optional string file_path = 1;
inline void GetBadDetectorMapFilesRpc::clear_file_path() {
  file_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetBadDetectorMapFilesRpc::file_path() const {
  // @@protoc_insertion_point(field_get:analogic.GetBadDetectorMapFilesRpc.file_path)
  return file_path_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetBadDetectorMapFilesRpc::set_file_path(const ::std::string& value) {
  
  file_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:analogic.GetBadDetectorMapFilesRpc.file_path)
}
inline void GetBadDetectorMapFilesRpc::set_file_path(const char* value) {
  
  file_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:analogic.GetBadDetectorMapFilesRpc.file_path)
}
inline void GetBadDetectorMapFilesRpc::set_file_path(const char* value, size_t size) {
  
  file_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:analogic.GetBadDetectorMapFilesRpc.file_path)
}
inline ::std::string* GetBadDetectorMapFilesRpc::mutable_file_path() {
  
  // @@protoc_insertion_point(field_mutable:analogic.GetBadDetectorMapFilesRpc.file_path)
  return file_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetBadDetectorMapFilesRpc::release_file_path() {
  // @@protoc_insertion_point(field_release:analogic.GetBadDetectorMapFilesRpc.file_path)
  
  return file_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetBadDetectorMapFilesRpc::set_allocated_file_path(::std::string* file_path) {
  if (file_path != NULL) {
    
  } else {
    
  }
  file_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), file_path);
  // @@protoc_insertion_point(field_set_allocated:analogic.GetBadDetectorMapFilesRpc.file_path)
}

// -------------------------------------------------------------------

// GetBadDetectorManualFileRpc

// optional string file_path = 1;
inline void GetBadDetectorManualFileRpc::clear_file_path() {
  file_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetBadDetectorManualFileRpc::file_path() const {
  // @@protoc_insertion_point(field_get:analogic.GetBadDetectorManualFileRpc.file_path)
  return file_path_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetBadDetectorManualFileRpc::set_file_path(const ::std::string& value) {
  
  file_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:analogic.GetBadDetectorManualFileRpc.file_path)
}
inline void GetBadDetectorManualFileRpc::set_file_path(const char* value) {
  
  file_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:analogic.GetBadDetectorManualFileRpc.file_path)
}
inline void GetBadDetectorManualFileRpc::set_file_path(const char* value, size_t size) {
  
  file_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:analogic.GetBadDetectorManualFileRpc.file_path)
}
inline ::std::string* GetBadDetectorManualFileRpc::mutable_file_path() {
  
  // @@protoc_insertion_point(field_mutable:analogic.GetBadDetectorManualFileRpc.file_path)
  return file_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetBadDetectorManualFileRpc::release_file_path() {
  // @@protoc_insertion_point(field_release:analogic.GetBadDetectorManualFileRpc.file_path)
  
  return file_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetBadDetectorManualFileRpc::set_allocated_file_path(::std::string* file_path) {
  if (file_path != NULL) {
    
  } else {
    
  }
  file_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), file_path);
  // @@protoc_insertion_point(field_set_allocated:analogic.GetBadDetectorManualFileRpc.file_path)
}

// -------------------------------------------------------------------

// UpdateBadDetectorManualFileRpc

// optional string content = 1;
inline void UpdateBadDetectorManualFileRpc::clear_content() {
  content_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UpdateBadDetectorManualFileRpc::content() const {
  // @@protoc_insertion_point(field_get:analogic.UpdateBadDetectorManualFileRpc.content)
  return content_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UpdateBadDetectorManualFileRpc::set_content(const ::std::string& value) {
  
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:analogic.UpdateBadDetectorManualFileRpc.content)
}
inline void UpdateBadDetectorManualFileRpc::set_content(const char* value) {
  
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:analogic.UpdateBadDetectorManualFileRpc.content)
}
inline void UpdateBadDetectorManualFileRpc::set_content(const char* value, size_t size) {
  
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:analogic.UpdateBadDetectorManualFileRpc.content)
}
inline ::std::string* UpdateBadDetectorManualFileRpc::mutable_content() {
  
  // @@protoc_insertion_point(field_mutable:analogic.UpdateBadDetectorManualFileRpc.content)
  return content_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UpdateBadDetectorManualFileRpc::release_content() {
  // @@protoc_insertion_point(field_release:analogic.UpdateBadDetectorManualFileRpc.content)
  
  return content_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UpdateBadDetectorManualFileRpc::set_allocated_content(::std::string* content) {
  if (content != NULL) {
    
  } else {
    
  }
  content_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), content);
  // @@protoc_insertion_point(field_set_allocated:analogic.UpdateBadDetectorManualFileRpc.content)
}

// -------------------------------------------------------------------

// GetErrorLogFileRpc

// optional string file_path = 1;
inline void GetErrorLogFileRpc::clear_file_path() {
  file_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetErrorLogFileRpc::file_path() const {
  // @@protoc_insertion_point(field_get:analogic.GetErrorLogFileRpc.file_path)
  return file_path_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetErrorLogFileRpc::set_file_path(const ::std::string& value) {
  
  file_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:analogic.GetErrorLogFileRpc.file_path)
}
inline void GetErrorLogFileRpc::set_file_path(const char* value) {
  
  file_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:analogic.GetErrorLogFileRpc.file_path)
}
inline void GetErrorLogFileRpc::set_file_path(const char* value, size_t size) {
  
  file_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:analogic.GetErrorLogFileRpc.file_path)
}
inline ::std::string* GetErrorLogFileRpc::mutable_file_path() {
  
  // @@protoc_insertion_point(field_mutable:analogic.GetErrorLogFileRpc.file_path)
  return file_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetErrorLogFileRpc::release_file_path() {
  // @@protoc_insertion_point(field_release:analogic.GetErrorLogFileRpc.file_path)
  
  return file_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetErrorLogFileRpc::set_allocated_file_path(::std::string* file_path) {
  if (file_path != NULL) {
    
  } else {
    
  }
  file_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), file_path);
  // @@protoc_insertion_point(field_set_allocated:analogic.GetErrorLogFileRpc.file_path)
}

// -------------------------------------------------------------------

// GetScannerConfigFileRpc

// optional string file_path = 1;
inline void GetScannerConfigFileRpc::clear_file_path() {
  file_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetScannerConfigFileRpc::file_path() const {
  // @@protoc_insertion_point(field_get:analogic.GetScannerConfigFileRpc.file_path)
  return file_path_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetScannerConfigFileRpc::set_file_path(const ::std::string& value) {
  
  file_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:analogic.GetScannerConfigFileRpc.file_path)
}
inline void GetScannerConfigFileRpc::set_file_path(const char* value) {
  
  file_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:analogic.GetScannerConfigFileRpc.file_path)
}
inline void GetScannerConfigFileRpc::set_file_path(const char* value, size_t size) {
  
  file_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:analogic.GetScannerConfigFileRpc.file_path)
}
inline ::std::string* GetScannerConfigFileRpc::mutable_file_path() {
  
  // @@protoc_insertion_point(field_mutable:analogic.GetScannerConfigFileRpc.file_path)
  return file_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetScannerConfigFileRpc::release_file_path() {
  // @@protoc_insertion_point(field_release:analogic.GetScannerConfigFileRpc.file_path)
  
  return file_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetScannerConfigFileRpc::set_allocated_file_path(::std::string* file_path) {
  if (file_path != NULL) {
    
  } else {
    
  }
  file_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), file_path);
  // @@protoc_insertion_point(field_set_allocated:analogic.GetScannerConfigFileRpc.file_path)
}

// -------------------------------------------------------------------

// UpdateScannerConfigFileRpc

// optional string content = 1;
inline void UpdateScannerConfigFileRpc::clear_content() {
  content_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UpdateScannerConfigFileRpc::content() const {
  // @@protoc_insertion_point(field_get:analogic.UpdateScannerConfigFileRpc.content)
  return content_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UpdateScannerConfigFileRpc::set_content(const ::std::string& value) {
  
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:analogic.UpdateScannerConfigFileRpc.content)
}
inline void UpdateScannerConfigFileRpc::set_content(const char* value) {
  
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:analogic.UpdateScannerConfigFileRpc.content)
}
inline void UpdateScannerConfigFileRpc::set_content(const char* value, size_t size) {
  
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:analogic.UpdateScannerConfigFileRpc.content)
}
inline ::std::string* UpdateScannerConfigFileRpc::mutable_content() {
  
  // @@protoc_insertion_point(field_mutable:analogic.UpdateScannerConfigFileRpc.content)
  return content_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UpdateScannerConfigFileRpc::release_content() {
  // @@protoc_insertion_point(field_release:analogic.UpdateScannerConfigFileRpc.content)
  
  return content_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UpdateScannerConfigFileRpc::set_allocated_content(::std::string* content) {
  if (content != NULL) {
    
  } else {
    
  }
  content_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), content);
  // @@protoc_insertion_point(field_set_allocated:analogic.UpdateScannerConfigFileRpc.content)
}

// -------------------------------------------------------------------

// SdswStatus

// optional .analogic.ancp00.ScannerControlRpcSeq.SCANNER_CONTROL_RPC_SEQ_ID id = 1;
inline void SdswStatus::clear_id() {
  id_ = 0;
}
inline ::analogic::ancp00::ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID SdswStatus::id() const {
  // @@protoc_insertion_point(field_get:analogic.SdswStatus.id)
  return static_cast< ::analogic::ancp00::ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID >(id_);
}
inline void SdswStatus::set_id(::analogic::ancp00::ScannerControlRpcSeq_SCANNER_CONTROL_RPC_SEQ_ID value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:analogic.SdswStatus.id)
}

// optional uint32 current_step = 2;
inline void SdswStatus::clear_current_step() {
  current_step_ = 0u;
}
inline ::google::protobuf::uint32 SdswStatus::current_step() const {
  // @@protoc_insertion_point(field_get:analogic.SdswStatus.current_step)
  return current_step_;
}
inline void SdswStatus::set_current_step(::google::protobuf::uint32 value) {
  
  current_step_ = value;
  // @@protoc_insertion_point(field_set:analogic.SdswStatus.current_step)
}

// optional uint32 number_of_steps = 3;
inline void SdswStatus::clear_number_of_steps() {
  number_of_steps_ = 0u;
}
inline ::google::protobuf::uint32 SdswStatus::number_of_steps() const {
  // @@protoc_insertion_point(field_get:analogic.SdswStatus.number_of_steps)
  return number_of_steps_;
}
inline void SdswStatus::set_number_of_steps(::google::protobuf::uint32 value) {
  
  number_of_steps_ = value;
  // @@protoc_insertion_point(field_set:analogic.SdswStatus.number_of_steps)
}

// optional string text = 4;
inline void SdswStatus::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SdswStatus::text() const {
  // @@protoc_insertion_point(field_get:analogic.SdswStatus.text)
  return text_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SdswStatus::set_text(const ::std::string& value) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:analogic.SdswStatus.text)
}
inline void SdswStatus::set_text(const char* value) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:analogic.SdswStatus.text)
}
inline void SdswStatus::set_text(const char* value, size_t size) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:analogic.SdswStatus.text)
}
inline ::std::string* SdswStatus::mutable_text() {
  
  // @@protoc_insertion_point(field_mutable:analogic.SdswStatus.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SdswStatus::release_text() {
  // @@protoc_insertion_point(field_release:analogic.SdswStatus.text)
  
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SdswStatus::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    
  } else {
    
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:analogic.SdswStatus.text)
}

// -------------------------------------------------------------------

// GetImageCalibrationFilesRpc

// optional string file_path = 1;
inline void GetImageCalibrationFilesRpc::clear_file_path() {
  file_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetImageCalibrationFilesRpc::file_path() const {
  // @@protoc_insertion_point(field_get:analogic.GetImageCalibrationFilesRpc.file_path)
  return file_path_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetImageCalibrationFilesRpc::set_file_path(const ::std::string& value) {
  
  file_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:analogic.GetImageCalibrationFilesRpc.file_path)
}
inline void GetImageCalibrationFilesRpc::set_file_path(const char* value) {
  
  file_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:analogic.GetImageCalibrationFilesRpc.file_path)
}
inline void GetImageCalibrationFilesRpc::set_file_path(const char* value, size_t size) {
  
  file_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:analogic.GetImageCalibrationFilesRpc.file_path)
}
inline ::std::string* GetImageCalibrationFilesRpc::mutable_file_path() {
  
  // @@protoc_insertion_point(field_mutable:analogic.GetImageCalibrationFilesRpc.file_path)
  return file_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetImageCalibrationFilesRpc::release_file_path() {
  // @@protoc_insertion_point(field_release:analogic.GetImageCalibrationFilesRpc.file_path)
  
  return file_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetImageCalibrationFilesRpc::set_allocated_file_path(::std::string* file_path) {
  if (file_path != NULL) {
    
  } else {
    
  }
  file_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), file_path);
  // @@protoc_insertion_point(field_set_allocated:analogic.GetImageCalibrationFilesRpc.file_path)
}

// -------------------------------------------------------------------

// RunImageCalibrationRpc

// optional string filename1 = 1;
inline void RunImageCalibrationRpc::clear_filename1() {
  filename1_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RunImageCalibrationRpc::filename1() const {
  // @@protoc_insertion_point(field_get:analogic.RunImageCalibrationRpc.filename1)
  return filename1_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RunImageCalibrationRpc::set_filename1(const ::std::string& value) {
  
  filename1_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:analogic.RunImageCalibrationRpc.filename1)
}
inline void RunImageCalibrationRpc::set_filename1(const char* value) {
  
  filename1_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:analogic.RunImageCalibrationRpc.filename1)
}
inline void RunImageCalibrationRpc::set_filename1(const char* value, size_t size) {
  
  filename1_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:analogic.RunImageCalibrationRpc.filename1)
}
inline ::std::string* RunImageCalibrationRpc::mutable_filename1() {
  
  // @@protoc_insertion_point(field_mutable:analogic.RunImageCalibrationRpc.filename1)
  return filename1_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RunImageCalibrationRpc::release_filename1() {
  // @@protoc_insertion_point(field_release:analogic.RunImageCalibrationRpc.filename1)
  
  return filename1_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RunImageCalibrationRpc::set_allocated_filename1(::std::string* filename1) {
  if (filename1 != NULL) {
    
  } else {
    
  }
  filename1_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), filename1);
  // @@protoc_insertion_point(field_set_allocated:analogic.RunImageCalibrationRpc.filename1)
}

// optional string filename2 = 2;
inline void RunImageCalibrationRpc::clear_filename2() {
  filename2_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RunImageCalibrationRpc::filename2() const {
  // @@protoc_insertion_point(field_get:analogic.RunImageCalibrationRpc.filename2)
  return filename2_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RunImageCalibrationRpc::set_filename2(const ::std::string& value) {
  
  filename2_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:analogic.RunImageCalibrationRpc.filename2)
}
inline void RunImageCalibrationRpc::set_filename2(const char* value) {
  
  filename2_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:analogic.RunImageCalibrationRpc.filename2)
}
inline void RunImageCalibrationRpc::set_filename2(const char* value, size_t size) {
  
  filename2_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:analogic.RunImageCalibrationRpc.filename2)
}
inline ::std::string* RunImageCalibrationRpc::mutable_filename2() {
  
  // @@protoc_insertion_point(field_mutable:analogic.RunImageCalibrationRpc.filename2)
  return filename2_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RunImageCalibrationRpc::release_filename2() {
  // @@protoc_insertion_point(field_release:analogic.RunImageCalibrationRpc.filename2)
  
  return filename2_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RunImageCalibrationRpc::set_allocated_filename2(::std::string* filename2) {
  if (filename2 != NULL) {
    
  } else {
    
  }
  filename2_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), filename2);
  // @@protoc_insertion_point(field_set_allocated:analogic.RunImageCalibrationRpc.filename2)
}

// optional string filename3 = 3;
inline void RunImageCalibrationRpc::clear_filename3() {
  filename3_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RunImageCalibrationRpc::filename3() const {
  // @@protoc_insertion_point(field_get:analogic.RunImageCalibrationRpc.filename3)
  return filename3_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RunImageCalibrationRpc::set_filename3(const ::std::string& value) {
  
  filename3_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:analogic.RunImageCalibrationRpc.filename3)
}
inline void RunImageCalibrationRpc::set_filename3(const char* value) {
  
  filename3_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:analogic.RunImageCalibrationRpc.filename3)
}
inline void RunImageCalibrationRpc::set_filename3(const char* value, size_t size) {
  
  filename3_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:analogic.RunImageCalibrationRpc.filename3)
}
inline ::std::string* RunImageCalibrationRpc::mutable_filename3() {
  
  // @@protoc_insertion_point(field_mutable:analogic.RunImageCalibrationRpc.filename3)
  return filename3_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RunImageCalibrationRpc::release_filename3() {
  // @@protoc_insertion_point(field_release:analogic.RunImageCalibrationRpc.filename3)
  
  return filename3_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RunImageCalibrationRpc::set_allocated_filename3(::std::string* filename3) {
  if (filename3 != NULL) {
    
  } else {
    
  }
  filename3_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), filename3);
  // @@protoc_insertion_point(field_set_allocated:analogic.RunImageCalibrationRpc.filename3)
}

// optional string filename4 = 4;
inline void RunImageCalibrationRpc::clear_filename4() {
  filename4_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RunImageCalibrationRpc::filename4() const {
  // @@protoc_insertion_point(field_get:analogic.RunImageCalibrationRpc.filename4)
  return filename4_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RunImageCalibrationRpc::set_filename4(const ::std::string& value) {
  
  filename4_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:analogic.RunImageCalibrationRpc.filename4)
}
inline void RunImageCalibrationRpc::set_filename4(const char* value) {
  
  filename4_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:analogic.RunImageCalibrationRpc.filename4)
}
inline void RunImageCalibrationRpc::set_filename4(const char* value, size_t size) {
  
  filename4_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:analogic.RunImageCalibrationRpc.filename4)
}
inline ::std::string* RunImageCalibrationRpc::mutable_filename4() {
  
  // @@protoc_insertion_point(field_mutable:analogic.RunImageCalibrationRpc.filename4)
  return filename4_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RunImageCalibrationRpc::release_filename4() {
  // @@protoc_insertion_point(field_release:analogic.RunImageCalibrationRpc.filename4)
  
  return filename4_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RunImageCalibrationRpc::set_allocated_filename4(::std::string* filename4) {
  if (filename4 != NULL) {
    
  } else {
    
  }
  filename4_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), filename4);
  // @@protoc_insertion_point(field_set_allocated:analogic.RunImageCalibrationRpc.filename4)
}

// optional string filename5 = 5;
inline void RunImageCalibrationRpc::clear_filename5() {
  filename5_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RunImageCalibrationRpc::filename5() const {
  // @@protoc_insertion_point(field_get:analogic.RunImageCalibrationRpc.filename5)
  return filename5_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RunImageCalibrationRpc::set_filename5(const ::std::string& value) {
  
  filename5_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:analogic.RunImageCalibrationRpc.filename5)
}
inline void RunImageCalibrationRpc::set_filename5(const char* value) {
  
  filename5_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:analogic.RunImageCalibrationRpc.filename5)
}
inline void RunImageCalibrationRpc::set_filename5(const char* value, size_t size) {
  
  filename5_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:analogic.RunImageCalibrationRpc.filename5)
}
inline ::std::string* RunImageCalibrationRpc::mutable_filename5() {
  
  // @@protoc_insertion_point(field_mutable:analogic.RunImageCalibrationRpc.filename5)
  return filename5_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RunImageCalibrationRpc::release_filename5() {
  // @@protoc_insertion_point(field_release:analogic.RunImageCalibrationRpc.filename5)
  
  return filename5_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RunImageCalibrationRpc::set_allocated_filename5(::std::string* filename5) {
  if (filename5 != NULL) {
    
  } else {
    
  }
  filename5_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), filename5);
  // @@protoc_insertion_point(field_set_allocated:analogic.RunImageCalibrationRpc.filename5)
}

// -------------------------------------------------------------------

// UpdateImageCalibrationBeltHeightRpc

// optional float belt_height = 1;
inline void UpdateImageCalibrationBeltHeightRpc::clear_belt_height() {
  belt_height_ = 0;
}
inline float UpdateImageCalibrationBeltHeightRpc::belt_height() const {
  // @@protoc_insertion_point(field_get:analogic.UpdateImageCalibrationBeltHeightRpc.belt_height)
  return belt_height_;
}
inline void UpdateImageCalibrationBeltHeightRpc::set_belt_height(float value) {
  
  belt_height_ = value;
  // @@protoc_insertion_point(field_set:analogic.UpdateImageCalibrationBeltHeightRpc.belt_height)
}

// -------------------------------------------------------------------

// UpdateImageCalibrationNylonScaleRpc

// optional float nylon_scale = 1;
inline void UpdateImageCalibrationNylonScaleRpc::clear_nylon_scale() {
  nylon_scale_ = 0;
}
inline float UpdateImageCalibrationNylonScaleRpc::nylon_scale() const {
  // @@protoc_insertion_point(field_get:analogic.UpdateImageCalibrationNylonScaleRpc.nylon_scale)
  return nylon_scale_;
}
inline void UpdateImageCalibrationNylonScaleRpc::set_nylon_scale(float value) {
  
  nylon_scale_ = value;
  // @@protoc_insertion_point(field_set:analogic.UpdateImageCalibrationNylonScaleRpc.nylon_scale)
}

// -------------------------------------------------------------------

// UpdateImageCalibrationBeltFreqRpc

// optional int32 belt_freq = 1;
inline void UpdateImageCalibrationBeltFreqRpc::clear_belt_freq() {
  belt_freq_ = 0;
}
inline ::google::protobuf::int32 UpdateImageCalibrationBeltFreqRpc::belt_freq() const {
  // @@protoc_insertion_point(field_get:analogic.UpdateImageCalibrationBeltFreqRpc.belt_freq)
  return belt_freq_;
}
inline void UpdateImageCalibrationBeltFreqRpc::set_belt_freq(::google::protobuf::int32 value) {
  
  belt_freq_ = value;
  // @@protoc_insertion_point(field_set:analogic.UpdateImageCalibrationBeltFreqRpc.belt_freq)
}

// -------------------------------------------------------------------

// ExportFilesRpc

// optional string file_path = 1;
inline void ExportFilesRpc::clear_file_path() {
  file_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ExportFilesRpc::file_path() const {
  // @@protoc_insertion_point(field_get:analogic.ExportFilesRpc.file_path)
  return file_path_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExportFilesRpc::set_file_path(const ::std::string& value) {
  
  file_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:analogic.ExportFilesRpc.file_path)
}
inline void ExportFilesRpc::set_file_path(const char* value) {
  
  file_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:analogic.ExportFilesRpc.file_path)
}
inline void ExportFilesRpc::set_file_path(const char* value, size_t size) {
  
  file_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:analogic.ExportFilesRpc.file_path)
}
inline ::std::string* ExportFilesRpc::mutable_file_path() {
  
  // @@protoc_insertion_point(field_mutable:analogic.ExportFilesRpc.file_path)
  return file_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ExportFilesRpc::release_file_path() {
  // @@protoc_insertion_point(field_release:analogic.ExportFilesRpc.file_path)
  
  return file_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExportFilesRpc::set_allocated_file_path(::std::string* file_path) {
  if (file_path != NULL) {
    
  } else {
    
  }
  file_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), file_path);
  // @@protoc_insertion_point(field_set_allocated:analogic.ExportFilesRpc.file_path)
}

// optional fixed32 file_types = 2;
inline void ExportFilesRpc::clear_file_types() {
  file_types_ = 0u;
}
inline ::google::protobuf::uint32 ExportFilesRpc::file_types() const {
  // @@protoc_insertion_point(field_get:analogic.ExportFilesRpc.file_types)
  return file_types_;
}
inline void ExportFilesRpc::set_file_types(::google::protobuf::uint32 value) {
  
  file_types_ = value;
  // @@protoc_insertion_point(field_set:analogic.ExportFilesRpc.file_types)
}

// optional string start_time_string = 3;
inline void ExportFilesRpc::clear_start_time_string() {
  start_time_string_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ExportFilesRpc::start_time_string() const {
  // @@protoc_insertion_point(field_get:analogic.ExportFilesRpc.start_time_string)
  return start_time_string_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExportFilesRpc::set_start_time_string(const ::std::string& value) {
  
  start_time_string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:analogic.ExportFilesRpc.start_time_string)
}
inline void ExportFilesRpc::set_start_time_string(const char* value) {
  
  start_time_string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:analogic.ExportFilesRpc.start_time_string)
}
inline void ExportFilesRpc::set_start_time_string(const char* value, size_t size) {
  
  start_time_string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:analogic.ExportFilesRpc.start_time_string)
}
inline ::std::string* ExportFilesRpc::mutable_start_time_string() {
  
  // @@protoc_insertion_point(field_mutable:analogic.ExportFilesRpc.start_time_string)
  return start_time_string_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ExportFilesRpc::release_start_time_string() {
  // @@protoc_insertion_point(field_release:analogic.ExportFilesRpc.start_time_string)
  
  return start_time_string_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExportFilesRpc::set_allocated_start_time_string(::std::string* start_time_string) {
  if (start_time_string != NULL) {
    
  } else {
    
  }
  start_time_string_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), start_time_string);
  // @@protoc_insertion_point(field_set_allocated:analogic.ExportFilesRpc.start_time_string)
}

// optional string end_time_string = 4;
inline void ExportFilesRpc::clear_end_time_string() {
  end_time_string_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ExportFilesRpc::end_time_string() const {
  // @@protoc_insertion_point(field_get:analogic.ExportFilesRpc.end_time_string)
  return end_time_string_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExportFilesRpc::set_end_time_string(const ::std::string& value) {
  
  end_time_string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:analogic.ExportFilesRpc.end_time_string)
}
inline void ExportFilesRpc::set_end_time_string(const char* value) {
  
  end_time_string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:analogic.ExportFilesRpc.end_time_string)
}
inline void ExportFilesRpc::set_end_time_string(const char* value, size_t size) {
  
  end_time_string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:analogic.ExportFilesRpc.end_time_string)
}
inline ::std::string* ExportFilesRpc::mutable_end_time_string() {
  
  // @@protoc_insertion_point(field_mutable:analogic.ExportFilesRpc.end_time_string)
  return end_time_string_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ExportFilesRpc::release_end_time_string() {
  // @@protoc_insertion_point(field_release:analogic.ExportFilesRpc.end_time_string)
  
  return end_time_string_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExportFilesRpc::set_allocated_end_time_string(::std::string* end_time_string) {
  if (end_time_string != NULL) {
    
  } else {
    
  }
  end_time_string_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), end_time_string);
  // @@protoc_insertion_point(field_set_allocated:analogic.ExportFilesRpc.end_time_string)
}

// -------------------------------------------------------------------

// AirCalibrationRpc

// -------------------------------------------------------------------

// OffsetCalibrationRpc

// -------------------------------------------------------------------

// CalibrationRpc

// optional .analogic.CalibrationRpc.CAL_COMMAND cmd = 1;
inline void CalibrationRpc::clear_cmd() {
  cmd_ = 0;
}
inline ::analogic::CalibrationRpc_CAL_COMMAND CalibrationRpc::cmd() const {
  // @@protoc_insertion_point(field_get:analogic.CalibrationRpc.cmd)
  return static_cast< ::analogic::CalibrationRpc_CAL_COMMAND >(cmd_);
}
inline void CalibrationRpc::set_cmd(::analogic::CalibrationRpc_CAL_COMMAND value) {
  
  cmd_ = value;
  // @@protoc_insertion_point(field_set:analogic.CalibrationRpc.cmd)
}

// -------------------------------------------------------------------

// AlarmLibInfo

// optional string name = 1;
inline void AlarmLibInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AlarmLibInfo::name() const {
  // @@protoc_insertion_point(field_get:analogic.AlarmLibInfo.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AlarmLibInfo::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:analogic.AlarmLibInfo.name)
}
inline void AlarmLibInfo::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:analogic.AlarmLibInfo.name)
}
inline void AlarmLibInfo::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:analogic.AlarmLibInfo.name)
}
inline ::std::string* AlarmLibInfo::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:analogic.AlarmLibInfo.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AlarmLibInfo::release_name() {
  // @@protoc_insertion_point(field_release:analogic.AlarmLibInfo.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AlarmLibInfo::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:analogic.AlarmLibInfo.name)
}

// optional string version = 2;
inline void AlarmLibInfo::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AlarmLibInfo::version() const {
  // @@protoc_insertion_point(field_get:analogic.AlarmLibInfo.version)
  return version_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AlarmLibInfo::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:analogic.AlarmLibInfo.version)
}
inline void AlarmLibInfo::set_version(const char* value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:analogic.AlarmLibInfo.version)
}
inline void AlarmLibInfo::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:analogic.AlarmLibInfo.version)
}
inline ::std::string* AlarmLibInfo::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:analogic.AlarmLibInfo.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AlarmLibInfo::release_version() {
  // @@protoc_insertion_point(field_release:analogic.AlarmLibInfo.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AlarmLibInfo::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:analogic.AlarmLibInfo.version)
}

// -------------------------------------------------------------------

// InstalledAlarmLibInfo

// optional string name = 1;
inline void InstalledAlarmLibInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& InstalledAlarmLibInfo::name() const {
  // @@protoc_insertion_point(field_get:analogic.InstalledAlarmLibInfo.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InstalledAlarmLibInfo::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:analogic.InstalledAlarmLibInfo.name)
}
inline void InstalledAlarmLibInfo::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:analogic.InstalledAlarmLibInfo.name)
}
inline void InstalledAlarmLibInfo::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:analogic.InstalledAlarmLibInfo.name)
}
inline ::std::string* InstalledAlarmLibInfo::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:analogic.InstalledAlarmLibInfo.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InstalledAlarmLibInfo::release_name() {
  // @@protoc_insertion_point(field_release:analogic.InstalledAlarmLibInfo.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InstalledAlarmLibInfo::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:analogic.InstalledAlarmLibInfo.name)
}

// optional string version = 2;
inline void InstalledAlarmLibInfo::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& InstalledAlarmLibInfo::version() const {
  // @@protoc_insertion_point(field_get:analogic.InstalledAlarmLibInfo.version)
  return version_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InstalledAlarmLibInfo::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:analogic.InstalledAlarmLibInfo.version)
}
inline void InstalledAlarmLibInfo::set_version(const char* value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:analogic.InstalledAlarmLibInfo.version)
}
inline void InstalledAlarmLibInfo::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:analogic.InstalledAlarmLibInfo.version)
}
inline ::std::string* InstalledAlarmLibInfo::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:analogic.InstalledAlarmLibInfo.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InstalledAlarmLibInfo::release_version() {
  // @@protoc_insertion_point(field_release:analogic.InstalledAlarmLibInfo.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InstalledAlarmLibInfo::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:analogic.InstalledAlarmLibInfo.version)
}

// optional bool corrupted = 3;
inline void InstalledAlarmLibInfo::clear_corrupted() {
  corrupted_ = false;
}
inline bool InstalledAlarmLibInfo::corrupted() const {
  // @@protoc_insertion_point(field_get:analogic.InstalledAlarmLibInfo.corrupted)
  return corrupted_;
}
inline void InstalledAlarmLibInfo::set_corrupted(bool value) {
  
  corrupted_ = value;
  // @@protoc_insertion_point(field_set:analogic.InstalledAlarmLibInfo.corrupted)
}

// -------------------------------------------------------------------

// GetInstalledAlarmLibsRpc

// -------------------------------------------------------------------

// GetInstalledAlarmLibsReply

// repeated .analogic.InstalledAlarmLibInfo installed_alarmlibs = 1;
inline int GetInstalledAlarmLibsReply::installed_alarmlibs_size() const {
  return installed_alarmlibs_.size();
}
inline void GetInstalledAlarmLibsReply::clear_installed_alarmlibs() {
  installed_alarmlibs_.Clear();
}
inline const ::analogic::InstalledAlarmLibInfo& GetInstalledAlarmLibsReply::installed_alarmlibs(int index) const {
  // @@protoc_insertion_point(field_get:analogic.GetInstalledAlarmLibsReply.installed_alarmlibs)
  return installed_alarmlibs_.Get(index);
}
inline ::analogic::InstalledAlarmLibInfo* GetInstalledAlarmLibsReply::mutable_installed_alarmlibs(int index) {
  // @@protoc_insertion_point(field_mutable:analogic.GetInstalledAlarmLibsReply.installed_alarmlibs)
  return installed_alarmlibs_.Mutable(index);
}
inline ::analogic::InstalledAlarmLibInfo* GetInstalledAlarmLibsReply::add_installed_alarmlibs() {
  // @@protoc_insertion_point(field_add:analogic.GetInstalledAlarmLibsReply.installed_alarmlibs)
  return installed_alarmlibs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::analogic::InstalledAlarmLibInfo >*
GetInstalledAlarmLibsReply::mutable_installed_alarmlibs() {
  // @@protoc_insertion_point(field_mutable_list:analogic.GetInstalledAlarmLibsReply.installed_alarmlibs)
  return &installed_alarmlibs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::analogic::InstalledAlarmLibInfo >&
GetInstalledAlarmLibsReply::installed_alarmlibs() const {
  // @@protoc_insertion_point(field_list:analogic.GetInstalledAlarmLibsReply.installed_alarmlibs)
  return installed_alarmlibs_;
}

// -------------------------------------------------------------------

// GetInstallableAlarmLibsRpc

// -------------------------------------------------------------------

// GetInstallableAlarmLibsReply

// repeated .analogic.AlarmLibInfo installable_alarmlibs = 1;
inline int GetInstallableAlarmLibsReply::installable_alarmlibs_size() const {
  return installable_alarmlibs_.size();
}
inline void GetInstallableAlarmLibsReply::clear_installable_alarmlibs() {
  installable_alarmlibs_.Clear();
}
inline const ::analogic::AlarmLibInfo& GetInstallableAlarmLibsReply::installable_alarmlibs(int index) const {
  // @@protoc_insertion_point(field_get:analogic.GetInstallableAlarmLibsReply.installable_alarmlibs)
  return installable_alarmlibs_.Get(index);
}
inline ::analogic::AlarmLibInfo* GetInstallableAlarmLibsReply::mutable_installable_alarmlibs(int index) {
  // @@protoc_insertion_point(field_mutable:analogic.GetInstallableAlarmLibsReply.installable_alarmlibs)
  return installable_alarmlibs_.Mutable(index);
}
inline ::analogic::AlarmLibInfo* GetInstallableAlarmLibsReply::add_installable_alarmlibs() {
  // @@protoc_insertion_point(field_add:analogic.GetInstallableAlarmLibsReply.installable_alarmlibs)
  return installable_alarmlibs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::analogic::AlarmLibInfo >*
GetInstallableAlarmLibsReply::mutable_installable_alarmlibs() {
  // @@protoc_insertion_point(field_mutable_list:analogic.GetInstallableAlarmLibsReply.installable_alarmlibs)
  return &installable_alarmlibs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::analogic::AlarmLibInfo >&
GetInstallableAlarmLibsReply::installable_alarmlibs() const {
  // @@protoc_insertion_point(field_list:analogic.GetInstallableAlarmLibsReply.installable_alarmlibs)
  return installable_alarmlibs_;
}

// -------------------------------------------------------------------

// InstallAlarmLibRpc

// optional .analogic.AlarmLibInfo alarmlib_info = 1;
inline bool InstallAlarmLibRpc::has_alarmlib_info() const {
  return !_is_default_instance_ && alarmlib_info_ != NULL;
}
inline void InstallAlarmLibRpc::clear_alarmlib_info() {
  if (GetArenaNoVirtual() == NULL && alarmlib_info_ != NULL) delete alarmlib_info_;
  alarmlib_info_ = NULL;
}
inline const ::analogic::AlarmLibInfo& InstallAlarmLibRpc::alarmlib_info() const {
  // @@protoc_insertion_point(field_get:analogic.InstallAlarmLibRpc.alarmlib_info)
  return alarmlib_info_ != NULL ? *alarmlib_info_ : *default_instance_->alarmlib_info_;
}
inline ::analogic::AlarmLibInfo* InstallAlarmLibRpc::mutable_alarmlib_info() {
  
  if (alarmlib_info_ == NULL) {
    alarmlib_info_ = new ::analogic::AlarmLibInfo;
  }
  // @@protoc_insertion_point(field_mutable:analogic.InstallAlarmLibRpc.alarmlib_info)
  return alarmlib_info_;
}
inline ::analogic::AlarmLibInfo* InstallAlarmLibRpc::release_alarmlib_info() {
  // @@protoc_insertion_point(field_release:analogic.InstallAlarmLibRpc.alarmlib_info)
  
  ::analogic::AlarmLibInfo* temp = alarmlib_info_;
  alarmlib_info_ = NULL;
  return temp;
}
inline void InstallAlarmLibRpc::set_allocated_alarmlib_info(::analogic::AlarmLibInfo* alarmlib_info) {
  delete alarmlib_info_;
  alarmlib_info_ = alarmlib_info;
  if (alarmlib_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:analogic.InstallAlarmLibRpc.alarmlib_info)
}

// -------------------------------------------------------------------

// ExportCalParamDataRpc

// optional string file_path = 1;
inline void ExportCalParamDataRpc::clear_file_path() {
  file_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ExportCalParamDataRpc::file_path() const {
  // @@protoc_insertion_point(field_get:analogic.ExportCalParamDataRpc.file_path)
  return file_path_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExportCalParamDataRpc::set_file_path(const ::std::string& value) {
  
  file_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:analogic.ExportCalParamDataRpc.file_path)
}
inline void ExportCalParamDataRpc::set_file_path(const char* value) {
  
  file_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:analogic.ExportCalParamDataRpc.file_path)
}
inline void ExportCalParamDataRpc::set_file_path(const char* value, size_t size) {
  
  file_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:analogic.ExportCalParamDataRpc.file_path)
}
inline ::std::string* ExportCalParamDataRpc::mutable_file_path() {
  
  // @@protoc_insertion_point(field_mutable:analogic.ExportCalParamDataRpc.file_path)
  return file_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ExportCalParamDataRpc::release_file_path() {
  // @@protoc_insertion_point(field_release:analogic.ExportCalParamDataRpc.file_path)
  
  return file_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExportCalParamDataRpc::set_allocated_file_path(::std::string* file_path) {
  if (file_path != NULL) {
    
  } else {
    
  }
  file_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), file_path);
  // @@protoc_insertion_point(field_set_allocated:analogic.ExportCalParamDataRpc.file_path)
}

// -------------------------------------------------------------------

// ImportCalParamDataRpc

// optional string file_path = 1;
inline void ImportCalParamDataRpc::clear_file_path() {
  file_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ImportCalParamDataRpc::file_path() const {
  // @@protoc_insertion_point(field_get:analogic.ImportCalParamDataRpc.file_path)
  return file_path_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImportCalParamDataRpc::set_file_path(const ::std::string& value) {
  
  file_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:analogic.ImportCalParamDataRpc.file_path)
}
inline void ImportCalParamDataRpc::set_file_path(const char* value) {
  
  file_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:analogic.ImportCalParamDataRpc.file_path)
}
inline void ImportCalParamDataRpc::set_file_path(const char* value, size_t size) {
  
  file_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:analogic.ImportCalParamDataRpc.file_path)
}
inline ::std::string* ImportCalParamDataRpc::mutable_file_path() {
  
  // @@protoc_insertion_point(field_mutable:analogic.ImportCalParamDataRpc.file_path)
  return file_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImportCalParamDataRpc::release_file_path() {
  // @@protoc_insertion_point(field_release:analogic.ImportCalParamDataRpc.file_path)
  
  return file_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImportCalParamDataRpc::set_allocated_file_path(::std::string* file_path) {
  if (file_path != NULL) {
    
  } else {
    
  }
  file_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), file_path);
  // @@protoc_insertion_point(field_set_allocated:analogic.ImportCalParamDataRpc.file_path)
}

// optional string file_name = 2;
inline void ImportCalParamDataRpc::clear_file_name() {
  file_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ImportCalParamDataRpc::file_name() const {
  // @@protoc_insertion_point(field_get:analogic.ImportCalParamDataRpc.file_name)
  return file_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImportCalParamDataRpc::set_file_name(const ::std::string& value) {
  
  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:analogic.ImportCalParamDataRpc.file_name)
}
inline void ImportCalParamDataRpc::set_file_name(const char* value) {
  
  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:analogic.ImportCalParamDataRpc.file_name)
}
inline void ImportCalParamDataRpc::set_file_name(const char* value, size_t size) {
  
  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:analogic.ImportCalParamDataRpc.file_name)
}
inline ::std::string* ImportCalParamDataRpc::mutable_file_name() {
  
  // @@protoc_insertion_point(field_mutable:analogic.ImportCalParamDataRpc.file_name)
  return file_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImportCalParamDataRpc::release_file_name() {
  // @@protoc_insertion_point(field_release:analogic.ImportCalParamDataRpc.file_name)
  
  return file_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImportCalParamDataRpc::set_allocated_file_name(::std::string* file_name) {
  if (file_name != NULL) {
    
  } else {
    
  }
  file_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), file_name);
  // @@protoc_insertion_point(field_set_allocated:analogic.ImportCalParamDataRpc.file_name)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace analogic

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::analogic::RpcReply_RPC_REPLY> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::analogic::RpcReply_RPC_REPLY>() {
  return ::analogic::RpcReply_RPC_REPLY_descriptor();
}
template <> struct is_proto_enum< ::analogic::RpcReply_RPC_ERROR_CODE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::analogic::RpcReply_RPC_ERROR_CODE>() {
  return ::analogic::RpcReply_RPC_ERROR_CODE_descriptor();
}
template <> struct is_proto_enum< ::analogic::XrayControlRpc_XRAY_STATE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::analogic::XrayControlRpc_XRAY_STATE>() {
  return ::analogic::XrayControlRpc_XRAY_STATE_descriptor();
}
template <> struct is_proto_enum< ::analogic::ImageQualityTestRpc_IQ_TEST_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::analogic::ImageQualityTestRpc_IQ_TEST_TYPE>() {
  return ::analogic::ImageQualityTestRpc_IQ_TEST_TYPE_descriptor();
}
template <> struct is_proto_enum< ::analogic::SdswStatus_AIR_CAL_STATE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::analogic::SdswStatus_AIR_CAL_STATE>() {
  return ::analogic::SdswStatus_AIR_CAL_STATE_descriptor();
}
template <> struct is_proto_enum< ::analogic::SdswStatus_OFFSET_CAL_STATE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::analogic::SdswStatus_OFFSET_CAL_STATE>() {
  return ::analogic::SdswStatus_OFFSET_CAL_STATE_descriptor();
}
template <> struct is_proto_enum< ::analogic::SdswStatus_PIN_CAL_STATE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::analogic::SdswStatus_PIN_CAL_STATE>() {
  return ::analogic::SdswStatus_PIN_CAL_STATE_descriptor();
}
template <> struct is_proto_enum< ::analogic::SdswStatus_BELT_HEIGHT_CAL_STATE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::analogic::SdswStatus_BELT_HEIGHT_CAL_STATE>() {
  return ::analogic::SdswStatus_BELT_HEIGHT_CAL_STATE_descriptor();
}
template <> struct is_proto_enum< ::analogic::SdswStatus_SPECTRAL_CAL_STATE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::analogic::SdswStatus_SPECTRAL_CAL_STATE>() {
  return ::analogic::SdswStatus_SPECTRAL_CAL_STATE_descriptor();
}
template <> struct is_proto_enum< ::analogic::SdswStatus_RADIATION_SURVEY_STATE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::analogic::SdswStatus_RADIATION_SURVEY_STATE>() {
  return ::analogic::SdswStatus_RADIATION_SURVEY_STATE_descriptor();
}
template <> struct is_proto_enum< ::analogic::SdswStatus_RADIATION_SURVEY_CANCEL_STATE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::analogic::SdswStatus_RADIATION_SURVEY_CANCEL_STATE>() {
  return ::analogic::SdswStatus_RADIATION_SURVEY_CANCEL_STATE_descriptor();
}
template <> struct is_proto_enum< ::analogic::SdswStatus_IMAGE_QUALITY_STATE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::analogic::SdswStatus_IMAGE_QUALITY_STATE>() {
  return ::analogic::SdswStatus_IMAGE_QUALITY_STATE_descriptor();
}
template <> struct is_proto_enum< ::analogic::SdswStatus_IMAGE_QUALITY_CANCEL_STATE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::analogic::SdswStatus_IMAGE_QUALITY_CANCEL_STATE>() {
  return ::analogic::SdswStatus_IMAGE_QUALITY_CANCEL_STATE_descriptor();
}
template <> struct is_proto_enum< ::analogic::SdswStatus_BASE_SEQ_1_STATE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::analogic::SdswStatus_BASE_SEQ_1_STATE>() {
  return ::analogic::SdswStatus_BASE_SEQ_1_STATE_descriptor();
}
template <> struct is_proto_enum< ::analogic::SdswStatus_ZEE_PIN_SPECTRAL_CAL_STATE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::analogic::SdswStatus_ZEE_PIN_SPECTRAL_CAL_STATE>() {
  return ::analogic::SdswStatus_ZEE_PIN_SPECTRAL_CAL_STATE_descriptor();
}
template <> struct is_proto_enum< ::analogic::SdswStatus_CONV_STOP_XRAY_MIN_STATE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::analogic::SdswStatus_CONV_STOP_XRAY_MIN_STATE>() {
  return ::analogic::SdswStatus_CONV_STOP_XRAY_MIN_STATE_descriptor();
}
template <> struct is_proto_enum< ::analogic::SdswStatus_XMAX_CONVEYOR_RUN_STATE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::analogic::SdswStatus_XMAX_CONVEYOR_RUN_STATE>() {
  return ::analogic::SdswStatus_XMAX_CONVEYOR_RUN_STATE_descriptor();
}
template <> struct is_proto_enum< ::analogic::SdswStatus_CONV_STOP_XRAY_MIN_STATE_CONV_RUN> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::analogic::SdswStatus_CONV_STOP_XRAY_MIN_STATE_CONV_RUN>() {
  return ::analogic::SdswStatus_CONV_STOP_XRAY_MIN_STATE_CONV_RUN_descriptor();
}
template <> struct is_proto_enum< ::analogic::SdswStatus_BELT_TUNNEL_CAL_STATE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::analogic::SdswStatus_BELT_TUNNEL_CAL_STATE>() {
  return ::analogic::SdswStatus_BELT_TUNNEL_CAL_STATE_descriptor();
}
template <> struct is_proto_enum< ::analogic::ExportFilesRpc_FILE_TYPES> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::analogic::ExportFilesRpc_FILE_TYPES>() {
  return ::analogic::ExportFilesRpc_FILE_TYPES_descriptor();
}
template <> struct is_proto_enum< ::analogic::CalibrationRpc_CAL_COMMAND> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::analogic::CalibrationRpc_CAL_COMMAND>() {
  return ::analogic::CalibrationRpc_CAL_COMMAND_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_proto_2fCalService_2eproto__INCLUDED
